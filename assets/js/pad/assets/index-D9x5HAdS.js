var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var rjquery = {};
var jquery = { exports: {} };
/*!
 * jQuery JavaScript Library v3.7.0
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-05-11T18:29Z
 */
(function(module) {
  (function(global2, factory) {
    {
      module.exports = global2.document ? factory(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice2 = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push2 = arr.push;
    var indexOf2 = arr.indexOf;
    var class2type = {};
    var toString2 = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction2 = function isFunction3(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow2(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc) {
      doc = doc || document2;
      var i, val, script = doc.createElement("script");
      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {
          val = node[i] || node.getAttribute && node.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
    }
    var version = "3.7.0", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
      return new jQuery2.fn.init(selector, context);
    };
    jQuery2.fn = jQuery2.prototype = {
      // The current version of jQuery being used
      jquery: version,
      constructor: jQuery2,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice2.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        if (num == null) {
          return slice2.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery2.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery2.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery2.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice2.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery2.grep(this, function(_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery2.grep(this, function(_elem, i) {
          return i % 2;
        }));
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push2,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery2.extend = jQuery2.fn.extend = function() {
      var options, name, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction2(target)) {
        target = {};
      }
      if (i === length) {
        target = this;
        i--;
      }
      for (; i < length; i++) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            copy = options[name];
            if (name === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name];
              if (copyIsArray && !Array.isArray(src)) {
                clone2 = [];
              } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                clone2 = {};
              } else {
                clone2 = src;
              }
              copyIsArray = false;
              target[name] = jQuery2.extend(deep, clone2, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery2.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString2.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(code, options, doc) {
        DOMEval(code, { nonce: options && options.nonce }, doc);
      },
      each: function(obj, callback) {
        var length, i = 0;
        if (isArrayLike2(obj)) {
          length = obj.length;
          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // Retrieve the text value of an array of DOM nodes
      text: function(elem) {
        var node, ret = "", i = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node = elem[i++]) {
            ret += jQuery2.text(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          return elem.textContent;
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      },
      // results is for internal usage only
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike2(Object(arr2))) {
            jQuery2.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push2.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i) {
        return arr2 == null ? -1 : indexOf2.call(arr2, elem, i);
      },
      isXMLDoc: function(elem) {
        var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
        return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function(first2, second) {
        var len = +second.length, j = 0, i = first2.length;
        for (; j < len; j++) {
          first2[i++] = second[j];
        }
        first2.length = i;
        return first2;
      },
      grep: function(elems, callback, invert2) {
        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert2;
        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i = 0, ret = [];
        if (isArrayLike2(elems)) {
          length = elems.length;
          for (; i < length; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery2.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      }
    );
    function isArrayLike2(obj) {
      var length = !!obj && "length" in obj && obj.length, type = toType(obj);
      if (isFunction2(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var pop = arr.pop;
    var sort = arr.sort;
    var splice = arr.splice;
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );
    jQuery2.contains = function(a, b) {
      var bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
      // IE doesn't have `contains` on SVG.
      (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    };
    var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        if (ch === "\0") {
          return "ï¿½";
        }
        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      }
      return "\\" + ch;
    }
    jQuery2.escapeSelector = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    var preferredDoc = document2, pushNative = push2;
    (function() {
      var i, Expr, outermostContext, sortInput, hasDuplicate, push3 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes2 = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
      `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes2 + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
        ID: new RegExp("^#(" + identifier + ")"),
        CLASS: new RegExp("^\\.(" + identifier + ")"),
        TAG: new RegExp("^(" + identifier + "|[*])"),
        ATTR: new RegExp("^" + attributes2),
        PSEUDO: new RegExp("^" + pseudos),
        CHILD: new RegExp(
          "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
          "i"
        ),
        bool: new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
        var high = "0x" + escape2.slice(1) - 65536;
        if (nonHex) {
          return nonHex;
        }
        return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      }, unloadHandler = function() {
        setDocument();
      }, inDisabledFieldset = addCombinator(
        function(elem) {
          return elem.disabled === true && nodeName(elem, "fieldset");
        },
        { dir: "parentNode", next: "legend" }
      );
      function safeActiveElement() {
        try {
          return document3.activeElement;
        } catch (err) {
        }
      }
      try {
        push3.apply(
          arr = slice2.call(preferredDoc.childNodes),
          preferredDoc.childNodes
        );
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push3 = {
          apply: function(target, els) {
            pushNative.apply(target, slice2.call(els));
          },
          call: function(target) {
            pushNative.apply(target, slice2.call(arguments, 1));
          }
        };
      }
      function find2(selector, context, results, seed) {
        var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
        results = results || [];
        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed) {
          setDocument(context);
          context = context || document3;
          if (documentIsHTML) {
            if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
              if (m = match[1]) {
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    if (elem.id === m) {
                      push3.call(results, elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (newContext && (elem = newContext.getElementById(m)) && find2.contains(context, elem) && elem.id === m) {
                    push3.call(results, elem);
                    return results;
                  }
                }
              } else if (match[2]) {
                push3.apply(results, context.getElementsByTagName(selector));
                return results;
              } else if ((m = match[3]) && context.getElementsByClassName) {
                push3.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }
            if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              newSelector = selector;
              newContext = context;
              if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                if (newContext != context || !support.scope) {
                  if (nid = context.getAttribute("id")) {
                    nid = jQuery2.escapeSelector(nid);
                  } else {
                    context.setAttribute("id", nid = expando);
                  }
                }
                groups = tokenize(selector);
                i2 = groups.length;
                while (i2--) {
                  groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                }
                newSelector = groups.join(",");
              }
              try {
                push3.apply(
                  results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {
                nonnativeSelectorCache(selector, true);
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
      }
      function createCache() {
        var keys2 = [];
        function cache(key, value) {
          if (keys2.push(key + " ") > Expr.cacheLength) {
            delete cache[keys2.shift()];
          }
          return cache[key + " "] = value;
        }
        return cache;
      }
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      function assert(fn) {
        var el = document3.createElement("fieldset");
        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
          el = null;
        }
      }
      function createInputPseudo(type) {
        return function(elem) {
          return nodeName(elem, "input") && elem.type === type;
        };
      }
      function createButtonPseudo(type) {
        return function(elem) {
          return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
        };
      }
      function createDisabledPseudo(disabled) {
        return function(elem) {
          if ("form" in elem) {
            if (elem.parentNode && elem.disabled === false) {
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }
              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
            }
            return elem.disabled === disabled;
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }
          return false;
        };
      }
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches2) {
            var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
            while (i2--) {
              if (seed[j = matchIndexes[i2]]) {
                seed[j] = !(matches2[j] = seed[j]);
              }
            }
          });
        });
      }
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }
      function setDocument(node) {
        var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
        if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
          return document3;
        }
        document3 = doc;
        documentElement2 = document3.documentElement;
        documentIsHTML = !jQuery2.isXMLDoc(document3);
        matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
        if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
          subWindow.addEventListener("unload", unloadHandler);
        }
        support.getById = assert(function(el) {
          documentElement2.appendChild(el).id = jQuery2.expando;
          return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
        });
        support.disconnectedMatch = assert(function(el) {
          return matches.call(el, "*");
        });
        support.scope = assert(function() {
          return document3.querySelectorAll(":scope");
        });
        support.cssHas = assert(function() {
          try {
            document3.querySelector(":has(*,:jqfake)");
            return false;
          } catch (e) {
            return true;
          }
        });
        if (support.getById) {
          Expr.filter.ID = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find.ID = function(id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter.ID = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node2 && node2.value === attrId;
            };
          };
          Expr.find.ID = function(id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node2, i2, elems, elem = context.getElementById(id);
              if (elem) {
                node2 = elem.getAttributeNode("id");
                if (node2 && node2.value === id) {
                  return [elem];
                }
                elems = context.getElementsByName(id);
                i2 = 0;
                while (elem = elems[i2++]) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                }
              }
              return [];
            }
          };
        }
        Expr.find.TAG = function(tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);
          } else {
            return context.querySelectorAll(tag);
          }
        };
        Expr.find.CLASS = function(className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyQSA = [];
        assert(function(el) {
          var input;
          documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          input = document3.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          documentElement2.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          input = document3.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);
          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
          }
        });
        if (!support.cssHas) {
          rbuggyQSA.push(":has");
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }
          compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
            // Otherwise we know they are disconnected
            1
          );
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === document3 || a.ownerDocument == preferredDoc && find2.contains(preferredDoc, a)) {
              return -1;
            }
            if (b === document3 || b.ownerDocument == preferredDoc && find2.contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf2.call(sortInput, a) - indexOf2.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        };
        return document3;
      }
      find2.matches = function(expr, elements) {
        return find2(expr, null, null, elements);
      };
      find2.matchesSelector = function(elem, expr) {
        setDocument(elem);
        if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
            nonnativeSelectorCache(expr, true);
          }
        }
        return find2(expr, document3, null, [elem]).length > 0;
      };
      find2.contains = function(context, elem) {
        if ((context.ownerDocument || context) != document3) {
          setDocument(context);
        }
        return jQuery2.contains(context, elem);
      };
      find2.attr = function(elem, name) {
        if ((elem.ownerDocument || elem) != document3) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
        if (val !== void 0) {
          return val;
        }
        return elem.getAttribute(name);
      };
      find2.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      jQuery2.uniqueSort = function(results) {
        var elem, duplicates = [], j = 0, i2 = 0;
        hasDuplicate = !support.sortStable;
        sortInput = !support.sortStable && slice2.call(results, 0);
        sort.call(results, sortOrder);
        if (hasDuplicate) {
          while (elem = results[i2++]) {
            if (elem === results[i2]) {
              j = duplicates.push(i2);
            }
          }
          while (j--) {
            splice.call(results, duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      jQuery2.fn.uniqueSort = function() {
        return this.pushStack(jQuery2.uniqueSort(slice2.apply(this)));
      };
      Expr = jQuery2.expr = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },
        preFilter: {
          ATTR: function(match) {
            match[1] = match[1].replace(runescape, funescape);
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
          },
          CHILD: function(match) {
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
              if (!match[3]) {
                find2.error(match[0]);
              }
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd");
            } else if (match[3]) {
              find2.error(match[0]);
            }
            return match;
          },
          PSEUDO: function(match) {
            var excess, unquoted = !match[6] && match[2];
            if (matchExpr.CHILD.test(match[0])) {
              return null;
            }
            if (match[3]) {
              match[2] = match[4] || match[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
            (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            return match.slice(0, 3);
          }
        },
        filter: {
          TAG: function(nodeNameSelector) {
            var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function() {
              return true;
            } : function(elem) {
              return nodeName(elem, expectedNodeName);
            };
          },
          CLASS: function(className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
              return pattern.test(
                typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
              );
            });
          },
          ATTR: function(name, operator, check) {
            return function(elem) {
              var result2 = find2.attr(elem, name);
              if (result2 == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result2 += "";
              if (operator === "=") {
                return result2 === check;
              }
              if (operator === "!=") {
                return result2 !== check;
              }
              if (operator === "^=") {
                return check && result2.indexOf(check) === 0;
              }
              if (operator === "*=") {
                return check && result2.indexOf(check) > -1;
              }
              if (operator === "$=") {
                return check && result2.slice(-check.length) === check;
              }
              if (operator === "~=") {
                return (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
              }
              if (operator === "|=") {
                return result2 === check || result2.slice(0, check.length + 1) === check + "-";
              }
              return false;
            };
          },
          CHILD: function(type, what, _argument, first2, last2) {
            var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
            return first2 === 1 && last2 === 0 ? (
              // Shortcut for :nth-*(n)
              function(elem) {
                return !!elem.parentNode;
              }
            ) : function(elem, _context, xml) {
              var cache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
              if (parent2) {
                if (simple) {
                  while (dir2) {
                    node = elem;
                    while (node = node[dir2]) {
                      if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                        return false;
                      }
                    }
                    start = dir2 = type === "only" && !start && "nextSibling";
                  }
                  return true;
                }
                start = [forward ? parent2.firstChild : parent2.lastChild];
                if (forward && useCache) {
                  outerCache = parent2[expando] || (parent2[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent2.childNodes[nodeIndex];
                  while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                  (diff = nodeIndex = 0) || start.pop()) {
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      outerCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }
                } else {
                  if (useCache) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  }
                  if (diff === false) {
                    while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {});
                          outerCache[type] = [dirruns, diff];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                }
                diff -= last2;
                return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
              }
            };
          },
          PSEUDO: function(pseudo, argument) {
            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                var idx, matched = fn(seed, argument), i2 = matched.length;
                while (i2--) {
                  idx = indexOf2.call(seed, matched[i2]);
                  seed[idx] = !(matches2[idx] = matched[i2]);
                }
              }) : function(elem) {
                return fn(elem, 0, args);
              };
            }
            return fn;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          not: markFunction(function(selector) {
            var input = [], results = [], matcher2 = compile(selector.replace(rtrimCSS, "$1"));
            return matcher2[expando] ? markFunction(function(seed, matches2, _context, xml) {
              var elem, unmatched = matcher2(seed, null, xml, []), i2 = seed.length;
              while (i2--) {
                if (elem = unmatched[i2]) {
                  seed[i2] = !(matches2[i2] = elem);
                }
              }
            }) : function(elem, _context, xml) {
              input[0] = elem;
              matcher2(input, null, xml, results);
              input[0] = null;
              return !results.pop();
            };
          }),
          has: markFunction(function(selector) {
            return function(elem) {
              return find2(selector, elem).length > 0;
            };
          }),
          contains: markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || jQuery2.text(elem)).indexOf(text) > -1;
            };
          }),
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // https://www.w3.org/TR/selectors/#lang-pseudo
          lang: markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              find2.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          // Miscellaneous
          target: function(elem) {
            var hash = window2.location && window2.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          root: function(elem) {
            return elem === documentElement2;
          },
          focus: function(elem) {
            return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          // Boolean properties
          enabled: createDisabledPseudo(false),
          disabled: createDisabledPseudo(true),
          checked: function(elem) {
            return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
          },
          selected: function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          // Contents
          empty: function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          parent: function(elem) {
            return !Expr.pseudos.empty(elem);
          },
          // Element/input types
          header: function(elem) {
            return rheader.test(elem.nodeName);
          },
          input: function(elem) {
            return rinputs.test(elem.nodeName);
          },
          button: function(elem) {
            return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
          },
          text: function(elem) {
            var attr;
            return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
            // New HTML5 attribute values (e.g., "search") appear
            // with elem.type === "text"
            ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          // Position-in-collection
          first: createPositionalPseudo(function() {
            return [0];
          }),
          last: createPositionalPseudo(function(_matchIndexes, length) {
            return [length - 1];
          }),
          eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          even: createPositionalPseudo(function(matchIndexes, length) {
            var i2 = 0;
            for (; i2 < length; i2 += 2) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          odd: createPositionalPseudo(function(matchIndexes, length) {
            var i2 = 1;
            for (; i2 < length; i2 += 2) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          lt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i2;
            if (argument < 0) {
              i2 = argument + length;
            } else if (argument > length) {
              i2 = length;
            } else {
              i2 = argument;
            }
            for (; --i2 >= 0; ) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          }),
          gt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i2 = argument < 0 ? argument + length : argument;
            for (; ++i2 < length; ) {
              matchIndexes.push(i2);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos.nth = Expr.pseudos.eq;
      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }
      function setFilters() {
      }
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      function tokenize(selector, parseOnly) {
        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          if (match = rleadingCombinator.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrimCSS, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        if (parseOnly) {
          return soFar.length;
        }
        return soFar ? find2.error(selector) : (
          // Cache the tokens
          tokenCache(selector, groups).slice(0)
        );
      }
      function toSelector(tokens) {
        var i2 = 0, len = tokens.length, selector = "";
        for (; i2 < len; i2++) {
          selector += tokens[i2].value;
        }
        return selector;
      }
      function addCombinator(matcher2, combinator, base) {
        var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
        return combinator.first ? (
          // Check against closest ancestor/preceding element
          function(elem, context, xml) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher2(elem, context, xml);
              }
            }
            return false;
          }
        ) : (
          // Check against all ancestor/preceding elements
          function(elem, context, xml) {
            var oldCache, outerCache, newCache = [dirruns, doneName];
            if (xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher2(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if (skip && nodeName(elem, skip)) {
                    elem = elem[dir2] || elem;
                  } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return newCache[2] = oldCache[2];
                  } else {
                    outerCache[key] = newCache;
                    if (newCache[2] = matcher2(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          }
        );
      }
      function elementMatcher(matchers) {
        return matchers.length > 1 ? function(elem, context, xml) {
          var i2 = matchers.length;
          while (i2--) {
            if (!matchers[i2](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } : matchers[0];
      }
      function multipleContexts(selector, contexts, results) {
        var i2 = 0, len = contexts.length;
        for (; i2 < len; i2++) {
          find2(selector, contexts[i2], results);
        }
        return results;
      }
      function condense(unmatched, map2, filter2, context, xml) {
        var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
        for (; i2 < len; i2++) {
          if (elem = unmatched[i2]) {
            if (!filter2 || filter2(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map2.push(i2);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector, matcher2, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
            selector || "*",
            context.nodeType ? [context] : context,
            []
          ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
          if (matcher2) {
            matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
              // ...intermediate processing is necessary
              []
            ) : (
              // ...otherwise use results directly
              results
            );
            matcher2(matcherIn, matcherOut, context, xml);
          } else {
            matcherOut = matcherIn;
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            i2 = temp.length;
            while (i2--) {
              if (elem = temp[i2]) {
                matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i2 = matcherOut.length;
                while (i2--) {
                  if (elem = matcherOut[i2]) {
                    temp.push(matcherIn[i2] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml);
              }
              i2 = matcherOut.length;
              while (i2--) {
                if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i2]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(
              matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push3.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher2, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
          return indexOf2.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function(elem, context, xml) {
          var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          checkContext = null;
          return ret;
        }];
        for (; i2 < len; i2++) {
          if (matcher2 = Expr.relative[tokens[i2].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher2)];
          } else {
            matcher2 = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
            if (matcher2[expando]) {
              j = ++i2;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i2 > 1 && elementMatcher(matchers),
                i2 > 1 && toSelector(
                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                ).replace(rtrimCSS, "$1"),
                matcher2,
                i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                j < len && matcherFromTokens(tokens = tokens.slice(j)),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher2);
          }
        }
        return elementMatcher(matchers);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
          var elem, j, matcher2, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            outermostContext = context == document3 || context || outermost;
          }
          for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
            if (byElement && elem) {
              j = 0;
              if (!context && elem.ownerDocument != document3) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher2 = elementMatchers[j++]) {
                if (matcher2(elem, context || document3, xml)) {
                  push3.call(results, elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher2 && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i2;
          if (bySet && i2 !== matchedCount) {
            j = 0;
            while (matcher2 = setMatchers[j++]) {
              matcher2(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i2--) {
                  if (!(unmatched[i2] || setMatched[i2])) {
                    setMatched[i2] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push3.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              jQuery2.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      function compile(selector, match) {
        var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
        if (!cached) {
          if (!match) {
            match = tokenize(selector);
          }
          i2 = match.length;
          while (i2--) {
            cached = matcherFromTokens(match[i2]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(
            selector,
            matcherFromGroupMatchers(elementMatchers, setMatchers)
          );
          cached.selector = selector;
        }
        return cached;
      }
      function select(selector, context, results, seed) {
        var i2, tokens, token, type, find3, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || [];
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find.ID(
              token.matches[0].replace(runescape, funescape),
              context
            ) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
          while (i2--) {
            token = tokens[i2];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find3 = Expr.find[type]) {
              if (seed = find3(
                token.matches[0].replace(runescape, funescape),
                rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
              )) {
                tokens.splice(i2, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push3.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile(selector, match))(
          seed,
          context,
          !documentIsHTML,
          results,
          !context || rsibling.test(selector) && testContext(context.parentNode) || context
        );
        return results;
      }
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      setDocument();
      support.sortDetached = assert(function(el) {
        return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
      });
      jQuery2.find = find2;
      jQuery2.expr[":"] = jQuery2.expr.pseudos;
      jQuery2.unique = jQuery2.uniqueSort;
      find2.compile = compile;
      find2.select = select;
      find2.setDocument = setDocument;
      find2.escape = jQuery2.escapeSelector;
      find2.getText = jQuery2.text;
      find2.isXML = jQuery2.isXMLDoc;
      find2.selectors = jQuery2.expr;
      find2.support = jQuery2.support;
      find2.uniqueSort = jQuery2.uniqueSort;
    })();
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery2(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery2.expr.match.needsContext;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction2(qualifier)) {
        return jQuery2.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery2.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery2.grep(elements, function(elem) {
          return indexOf2.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery2.filter(qualifier, elements, not);
    }
    jQuery2.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery2.fn.extend({
      find: function(selector) {
        var i, ret, len = this.length, self2 = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery2(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery2.contains(self2[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery2.find(selector, self2[i], ret);
        }
        return len > 1 ? jQuery2.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root2) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root2 = root2 || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery2 ? context[0] : context;
            jQuery2.merge(this, jQuery2.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document2,
              true
            ));
            if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
              for (match in context) {
                if (isFunction2(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root2).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction2(selector)) {
        return root2.ready !== void 0 ? root2.ready(selector) : (
          // Execute immediately if ready is not present
          selector(jQuery2)
        );
      }
      return jQuery2.makeArray(selector, this);
    };
    init.prototype = jQuery2.fn;
    rootjQuery = jQuery2(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery2.fn.extend({
      has: function(target) {
        var targets = jQuery2(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery2.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                // Don't pass non-elements to jQuery#find
                cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
              ))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf2.call(jQuery2(elem), this[0]);
        }
        return indexOf2.call(
          this,
          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem
        );
      },
      add: function(selector, context) {
        return this.pushStack(
          jQuery2.uniqueSort(
            jQuery2.merge(this.get(), jQuery2(selector, context))
          )
        );
      },
      addBack: function(selector) {
        return this.add(
          selector == null ? this.prevObject : this.prevObject.filter(selector)
        );
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery2.each({
      parent: function(elem) {
        var parent2 = elem.parentNode;
        return parent2 && parent2.nodeType !== 11 ? parent2 : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery2.merge([], elem.childNodes);
      }
    }, function(name, fn) {
      jQuery2.fn[name] = function(until, selector) {
        var matched = jQuery2.map(this, fn, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery2.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            jQuery2.uniqueSort(matched);
          }
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object2 = {};
      jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
        object2[flag] = true;
      });
      return object2;
    }
    jQuery2.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
      var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              jQuery2.each(args, function(_2, arg) {
                if (isFunction2(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          jQuery2.each(arguments, function(_2, arg) {
            var index;
            while ((index = jQuery2.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn) {
          return fn ? jQuery2.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject2, noValue) {
      var method;
      try {
        if (value && isFunction2(method = value.promise)) {
          method.call(value).done(resolve).fail(reject2);
        } else if (value && isFunction2(method = value.then)) {
          method.call(value, resolve, reject2);
        } else {
          resolve.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject2.apply(void 0, [value2]);
      }
    }
    jQuery2.extend({
      Deferred: function(func) {
        var tuples = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            jQuery2.Callbacks("memory"),
            jQuery2.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery2.Callbacks("once memory"),
            jQuery2.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery2.Callbacks("once memory"),
            jQuery2.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function() {
            var fns = arguments;
            return jQuery2.Deferred(function(newDefer) {
              jQuery2.each(tuples, function(_i, tuple) {
                var fn = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction2(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](
                      this,
                      fn ? [returned] : arguments
                    );
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred2, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction2(then)) {
                    if (special) {
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special)
                      );
                    } else {
                      maxDepth++;
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special),
                        resolve(
                          maxDepth,
                          deferred2,
                          Identity,
                          deferred2.notifyWith
                        )
                      );
                    }
                  } else {
                    if (handler !== Identity) {
                      that = void 0;
                      args = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args);
                  }
                }, process2 = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery2.Deferred.exceptionHook) {
                      jQuery2.Deferred.exceptionHook(
                        e,
                        process2.error
                      );
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = void 0;
                        args = [e];
                      }
                      deferred2.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process2();
                } else {
                  if (jQuery2.Deferred.getErrorHook) {
                    process2.error = jQuery2.Deferred.getErrorHook();
                  } else if (jQuery2.Deferred.getStackHook) {
                    process2.error = jQuery2.Deferred.getStackHook();
                  }
                  window2.setTimeout(process2);
                }
              };
            }
            return jQuery2.Deferred(function(newDefer) {
              tuples[0][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onProgress) ? onProgress : Identity,
                  newDefer.notifyWith
                )
              );
              tuples[1][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onFulfilled) ? onFulfilled : Identity
                )
              );
              tuples[2][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onRejected) ? onRejected : Thrower
                )
              );
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery2.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery2.each(tuples, function(i, tuple) {
          var list = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(
              function() {
                state = stateString;
              },
              // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable,
              // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable,
              // progress_callbacks.lock
              tuples[0][2].lock,
              // progress_handlers.lock
              tuples[0][3].lock
            );
          }
          list.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      // Deferred helper
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice2.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i2) {
          return function(value) {
            resolveContexts[i2] = this;
            resolveValues[i2] = arguments.length > 1 ? slice2.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(
            singleValue,
            primary.done(updateFunc(i)).resolve,
            primary.reject,
            !remaining
          );
          if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery2.Deferred.exceptionHook = function(error, asyncError) {
      if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
        window2.console.warn(
          "jQuery.Deferred exception: " + error.message,
          error.stack,
          asyncError
        );
      }
    };
    jQuery2.readyException = function(error) {
      window2.setTimeout(function() {
        throw error;
      });
    };
    var readyList = jQuery2.Deferred();
    jQuery2.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error) {
        jQuery2.readyException(error);
      });
      return this;
    };
    jQuery2.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function(wait) {
        if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
          return;
        }
        jQuery2.isReady = true;
        if (wait !== true && --jQuery2.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery2]);
      }
    });
    jQuery2.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery2.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery2.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction2(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, _key, value2) {
              return bulk.call(jQuery2(elem), value2);
            };
          }
        }
        if (fn) {
          for (; i < len; i++) {
            fn(
              elems[i],
              key,
              raw ? value : value.call(elems[i], i, fn(elems[i], key))
            );
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery2.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data, value) {
        var prop, cache = this.cache(owner);
        if (typeof data === "string") {
          cache[camelCase(data)] = value;
        } else {
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === void 0 ? this.cache(owner) : (
          // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)]
        );
      },
      access: function(owner, key, value) {
        if (key === void 0 || key && typeof key === "string" && value === void 0) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== void 0 ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key !== void 0) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === void 0 || jQuery2.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery2.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
      if (data === "true") {
        return true;
      }
      if (data === "false") {
        return false;
      }
      if (data === "null") {
        return null;
      }
      if (data === +data + "") {
        return +data;
      }
      if (rbrace.test(data)) {
        return JSON.parse(data);
      }
      return data;
    }
    function dataAttr(elem, key, data) {
      var name;
      if (data === void 0 && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);
        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {
          }
          dataUser.set(elem, key, data);
        } else {
          data = void 0;
        }
      }
      return data;
    }
    jQuery2.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function(elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function(elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function(elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery2.fn.extend({
      data: function(key, value) {
        var i, name, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name = attrs[i].name;
                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value2) {
          var data2;
          if (elem && value2 === void 0) {
            data2 = dataUser.get(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            data2 = dataAttr(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery2.extend({
      queue: function(elem, type, data) {
        var queue;
        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type);
          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
            } else {
              queue.push(data);
            }
          }
          return queue || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue = jQuery2.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks2 = jQuery2._queueHooks(elem, type), next = function() {
          jQuery2.dequeue(elem, type);
        };
        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }
        if (fn) {
          if (type === "fx") {
            queue.unshift("inprogress");
          }
          delete hooks2.stop;
          fn.call(elem, next, hooks2);
        }
        if (!startLength && hooks2) {
          hooks2.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery2.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery2.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery2.queue(this[0], type);
        }
        return data === void 0 ? this : this.each(function() {
          var queue = jQuery2.queue(this, type, data);
          jQuery2._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery2.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery2.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(type, obj) {
        var tmp, count = 1, defer2 = jQuery2.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer2.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer2.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached = function(elem) {
      return jQuery2.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached(elem) && jQuery2.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery2.css(elem, prop, "");
      }, initial2 = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial2) && rcssNum.exec(jQuery2.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial2 = initial2 / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial2 || 1;
        while (maxIterations--) {
          jQuery2.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial2 || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery2.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial2 || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc.body.appendChild(doc.createElement(nodeName2));
      display = jQuery2.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values2 = [], index = 0, length = elements.length;
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values2[index] = dataPriv.get(elem, "display") || null;
            if (!values2[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values2[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values2[index] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index = 0; index < length; index++) {
        if (values2[index] != null) {
          elements[index].style.display = values2[index];
        }
      }
      return elements;
    }
    jQuery2.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery2(this).show();
          } else {
            jQuery2(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context, tag)) {
        return jQuery2.merge([context], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (; i < l; i++) {
        dataPriv.set(
          elems[i],
          "globalEval",
          !refElements || dataPriv.get(refElements[i], "globalEval")
        );
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap2, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap2 = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap2[1] + jQuery2.htmlPrefilter(elem) + wrap2[2];
            j = wrap2[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery2.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery2.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function on2(elem, types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = void 0;
        }
        for (type in types) {
          on2(elem, type, selector, data, types[type], one);
        }
        return elem;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = void 0;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = void 0;
        } else {
          fn = data;
          data = selector;
          selector = void 0;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery2().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
      }
      return elem.each(function() {
        jQuery2.event.add(this, types, fn, data, selector);
      });
    }
    jQuery2.event = {
      global: {},
      add: function(elem, types, handler, data, selector) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery2.find.matchesSelector(documentElement, selector);
        }
        if (!handler.guid) {
          handler.guid = jQuery2.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery2.event.special[type] || {};
          handleObj = jQuery2.extend({
            type,
            origType,
            data,
            handler,
            guid: handler.guid,
            selector,
            needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery2.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery2.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery2.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery2.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name, hook) {
        Object.defineProperty(jQuery2.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction2(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", true);
            }
            return false;
          },
          trigger: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function(event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type, isSetup) {
      if (!isSetup) {
        if (dataPriv.get(el, type) === void 0) {
          jQuery2.event.add(el, type, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type, false);
      jQuery2.event.add(el, type, {
        namespace: false,
        handler: function(event) {
          var result2, saved = dataPriv.get(this, type);
          if (event.isTrigger & 1 && this[type]) {
            if (!saved) {
              saved = slice2.call(arguments);
              dataPriv.set(this, type, saved);
              this[type]();
              result2 = dataPriv.get(this, type);
              dataPriv.set(this, type, false);
              if (saved !== result2) {
                event.stopImmediatePropagation();
                event.preventDefault();
                return result2;
              }
            } else if ((jQuery2.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }
          } else if (saved) {
            dataPriv.set(this, type, jQuery2.event.trigger(
              saved[0],
              saved.slice(1),
              this
            ));
            event.stopPropagation();
            event.isImmediatePropagationStopped = returnTrue;
          }
        }
      });
    }
    jQuery2.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery2.Event = function(src, props) {
      if (!(this instanceof jQuery2.Event)) {
        return new jQuery2.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery2.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery2.expando] = true;
    };
    jQuery2.Event.prototype = {
      constructor: jQuery2.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery2.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery2.event.addProp);
    jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
      function focusMappedHandler(nativeEvent) {
        if (document2.documentMode) {
          var handle = dataPriv.get(this, "handle"), event = jQuery2.event.fix(nativeEvent);
          event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
          event.isSimulated = true;
          handle(nativeEvent);
          if (event.target === event.currentTarget) {
            handle(event);
          }
        } else {
          jQuery2.event.simulate(
            delegateType,
            nativeEvent.target,
            jQuery2.event.fix(nativeEvent)
          );
        }
      }
      jQuery2.event.special[type] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function() {
          var attaches;
          leverageNative(this, type, true);
          if (document2.documentMode) {
            attaches = dataPriv.get(this, delegateType);
            if (!attaches) {
              this.addEventListener(delegateType, focusMappedHandler);
            }
            dataPriv.set(this, delegateType, (attaches || 0) + 1);
          } else {
            return false;
          }
        },
        trigger: function() {
          leverageNative(this, type);
          return true;
        },
        teardown: function() {
          var attaches;
          if (document2.documentMode) {
            attaches = dataPriv.get(this, delegateType) - 1;
            if (!attaches) {
              this.removeEventListener(delegateType, focusMappedHandler);
              dataPriv.remove(this, delegateType);
            } else {
              dataPriv.set(this, delegateType, attaches);
            }
          } else {
            return false;
          }
        },
        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function(event) {
          return dataPriv.get(event.target, type);
        },
        delegateType
      };
      jQuery2.event.special[delegateType] = {
        setup: function() {
          var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
          if (!attaches) {
            if (document2.documentMode) {
              this.addEventListener(delegateType, focusMappedHandler);
            } else {
              doc.addEventListener(type, focusMappedHandler, true);
            }
          }
          dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
          if (!attaches) {
            if (document2.documentMode) {
              this.removeEventListener(delegateType, focusMappedHandler);
            } else {
              doc.removeEventListener(type, focusMappedHandler, true);
            }
            dataPriv.remove(dataHolder, delegateType);
          } else {
            dataPriv.set(dataHolder, delegateType, attaches);
          }
        }
      };
    });
    jQuery2.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery2.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery2.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery2.fn.extend({
      on: function(types, selector, data, fn) {
        return on2(this, types, selector, data, fn);
      },
      one: function(types, selector, data, fn) {
        return on2(this, types, selector, data, fn, 1);
      },
      off: function(types, selector, fn) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery2(types.delegateTarget).off(
            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn = selector;
          selector = void 0;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery2.event.remove(this, types, fn, selector);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery2(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;
        if (events) {
          dataPriv.remove(dest, "handle events");
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery2.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery2.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = flat(args);
      var fragment, first2, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction2(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self2 = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first2 = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first2;
        }
        if (first2 || ignored) {
          scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery2.clone(node, true, true);
              if (hasScripts) {
                jQuery2.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery2.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery2._evalUrl && !node.noModule) {
                    jQuery2._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove(elem, selector, keepData) {
      var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i = 0;
      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery2.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery2.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
          destElements = getAll(clone2);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone2);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone2);
          }
        }
        destElements = getAll(clone2, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone2;
      },
      cleanData: function(elems) {
        var data, elem, type, special = jQuery2.event.special, i = 0;
        for (; (elem = elems[i]) !== void 0; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery2.event.remove(elem, type);
                  } else {
                    jQuery2.removeEvent(elem, type, data.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery2.fn.extend({
      detach: function(selector) {
        return remove(this, selector, true);
      },
      remove: function(selector) {
        return remove(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery2.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery2.htmlPrefilter(value2);
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery2.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent2 = this.parentNode;
          if (jQuery2.inArray(this, ignored) < 0) {
            jQuery2.cleanData(getAll(this));
            if (parent2) {
              parent2.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery2.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name, original) {
      jQuery2.fn[name] = function(selector) {
        var elems, ret = [], insert = jQuery2(selector), last2 = insert.length - 1, i = 0;
        for (; i <= last2; i++) {
          elems = i === last2 ? this : this.clone(true);
          jQuery2(insert[i])[original](elems);
          push2.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.call(elem);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery2.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name, computed) {
      var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
      computed = computed || getStyles(elem);
      if (computed) {
        ret = computed.getPropertyValue(name) || computed[name];
        if (isCustomProp && ret) {
          ret = ret.replace(rtrimCSS, "$1") || void 0;
        }
        if (ret === "" && !isAttached(elem)) {
          ret = jQuery2.style(elem, name);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== void 0 ? (
        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + ""
      ) : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name) {
      var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
      while (i--) {
        name = cssPrefixes[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }
    function finalPropName(name) {
      var final = jQuery2.cssProps[name] || vendorProps[name];
      if (final) {
        return final;
      }
      if (name in emptyStyle) {
        return name;
      }
      return vendorProps[name] = vendorPropName(name) || name;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
      var matches = rcssNum.exec(value);
      return matches ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
      ) : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i < 4; i += 2) {
        if (box === "margin") {
          marginDelta += jQuery2.css(elem, box + cssExpand[i], true, styles);
        }
        if (!isBorderBox) {
          delta += jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
          if (box !== "padding") {
            delta += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } else {
            extra += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta -= jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
          }
          if (box !== "margin") {
            delta -= jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }
      return delta + marginDelta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
      elem.getClientRects().length) {
        isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(
        elem,
        dimension,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles,
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
      ) + "px";
    }
    jQuery2.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageSlice: true,
        columnCount: true,
        flexGrow: true,
        flexShrink: true,
        fontWeight: true,
        gridArea: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnStart: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowStart: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        scale: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeMiterlimit: true,
        strokeOpacity: true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function(elem, name, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks2, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks2 = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }
          if (!hooks2 || !("set" in hooks2) || (value = hooks2.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name];
        }
      },
      css: function(elem, name, extra, styles) {
        var val, num, hooks2, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks2 = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
        if (hooks2 && "get" in hooks2) {
          val = hooks2.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name, styles);
        }
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery2.each(["height", "width"], function(_i, dimension) {
      jQuery2.cssHooks[dimension] = {
        get: function(elem, computed, extra) {
          if (computed) {
            return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles
          ) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
            );
          }
          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery2.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery2.cssHooks.marginLeft = addGetHookIf(
      support.reliableMarginLeft,
      function(elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }
    );
    jQuery2.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery2.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery2.fn.extend({
      css: function(name, value) {
        return access(this, function(elem, name2, value2) {
          var styles, len, map2 = {}, i = 0;
          if (Array.isArray(name2)) {
            styles = getStyles(elem);
            len = name2.length;
            for (; i < len; i++) {
              map2[name2[i]] = jQuery2.css(elem, name2[i], false, styles);
            }
            return map2;
          }
          return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
        }, name, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery2.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery2.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks2 = Tween.propHooks[this.prop];
        return hooks2 && hooks2.get ? hooks2.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks2 = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery2.easing[this.easing](
            percent,
            this.options.duration * percent,
            0,
            1,
            this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks2 && hooks2.set) {
          hooks2.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result2;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result2 = jQuery2.css(tween.elem, tween.prop, "");
          return !result2 || result2 === "auto" ? 0 : result2;
        },
        set: function(tween) {
          if (jQuery2.fx.step[tween.prop]) {
            jQuery2.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery2.easing = {
      linear: function(p) {
        return p;
      },
      swing: function(p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery2.fx = Tween.prototype.init;
    jQuery2.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery2.fx.interval);
        }
        jQuery2.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = { height: type };
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks2, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks2 = jQuery2._queueHooks(elem, "fx");
        if (hooks2.unqueued == null) {
          hooks2.unqueued = 0;
          oldfire = hooks2.empty.fire;
          hooks2.empty.fire = function() {
            if (!hooks2.unqueued) {
              oldfire();
            }
          };
        }
        hooks2.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks2.unqueued--;
            if (!jQuery2.queue(elem, "fx").length) {
              hooks2.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
        }
      }
      propTween = !jQuery2.isEmptyObject(props);
      if (!propTween && jQuery2.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery2.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery2.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery2.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery2.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks2;
      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }
        if (index !== name) {
          props[name] = value;
          delete props[index];
        }
        hooks2 = jQuery2.cssHooks[name];
        if (hooks2 && "expand" in hooks2) {
          value = hooks2.expand(value);
          delete props[name];
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result2, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
        for (; index2 < length2; index2++) {
          animation.tweens[index2].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        }
        if (!length2) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery2.extend({}, properties),
        opts: jQuery2.extend(true, {
          specialEasing: {},
          easing: jQuery2.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery2.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (; index < length; index++) {
        result2 = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result2) {
          if (isFunction2(result2.stop)) {
            jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result2.stop.bind(result2);
          }
          return result2;
        }
      }
      jQuery2.map(props, createTween, animation);
      if (isFunction2(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery2.fx.timer(
        jQuery2.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );
      return animation;
    }
    jQuery2.Animation = jQuery2.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props, callback) {
        if (isFunction2(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index = 0, length = props.length;
        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery2.speed = function(speed, easing, fn) {
      var opt2 = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction2(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction2(easing) && easing
      };
      if (jQuery2.fx.off) {
        opt2.duration = 0;
      } else {
        if (typeof opt2.duration !== "number") {
          if (opt2.duration in jQuery2.fx.speeds) {
            opt2.duration = jQuery2.fx.speeds[opt2.duration];
          } else {
            opt2.duration = jQuery2.fx.speeds._default;
          }
        }
      }
      if (opt2.queue == null || opt2.queue === true) {
        opt2.queue = "fx";
      }
      opt2.old = opt2.complete;
      opt2.complete = function() {
        if (isFunction2(opt2.old)) {
          opt2.old.call(this);
        }
        if (opt2.queue) {
          jQuery2.dequeue(this, opt2.queue);
        }
      };
      return opt2;
    };
    jQuery2.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery2.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks2) {
          var stop = hooks2.stop;
          delete hooks2.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery2.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks2 = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
          data.finish = true;
          jQuery2.queue(this, type, []);
          if (hooks2 && hooks2.stop) {
            hooks2.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery2.each(["toggle", "show", "hide"], function(_i, name) {
      var cssFn = jQuery2.fn[name];
      jQuery2.fn[name] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    });
    jQuery2.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name, props) {
      jQuery2.fn[name] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery2.timers = [];
    jQuery2.fx.tick = function() {
      var timer, i = 0, timers = jQuery2.timers;
      fxNow = Date.now();
      for (; i < timers.length; i++) {
        timer = timers[i];
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery2.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery2.fx.timer = function(timer) {
      jQuery2.timers.push(timer);
      jQuery2.fx.start();
    };
    jQuery2.fx.interval = 13;
    jQuery2.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery2.fx.stop = function() {
      inProgress = null;
    };
    jQuery2.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    };
    jQuery2.fn.delay = function(time, type) {
      time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks2) {
        var timeout = window2.setTimeout(next, time);
        hooks2.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt2 = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt2.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery2.expr.attrHandle;
    jQuery2.fn.extend({
      attr: function(name, value) {
        return access(this, jQuery2.attr, name, value, arguments.length > 1);
      },
      removeAttr: function(name) {
        return this.each(function() {
          jQuery2.removeAttr(this, name);
        });
      }
    });
    jQuery2.extend({
      attr: function(elem, name, value) {
        var ret, hooks2, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery2.prop(elem, name, value);
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          hooks2 = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery2.removeAttr(elem, name);
            return;
          }
          if (hooks2 && "set" in hooks2 && (ret = hooks2.set(elem, value, name)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name, value + "");
          return value;
        }
        if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, name)) !== null) {
          return ret;
        }
        ret = jQuery2.find.attr(elem, name);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name) {
        if (value === false) {
          jQuery2.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }
        return name;
      }
    };
    jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name) {
      var getter = attrHandle[name] || jQuery2.find.attr;
      attrHandle[name] = function(elem, name2, isXML) {
        var ret, handle, lowercaseName = name2.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery2.fn.extend({
      prop: function(name, value) {
        return access(this, jQuery2.prop, name, value, arguments.length > 1);
      },
      removeProp: function(name) {
        return this.each(function() {
          delete this[jQuery2.propFix[name] || name];
        });
      }
    });
    jQuery2.extend({
      prop: function(elem, name, value) {
        var ret, hooks2, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          name = jQuery2.propFix[name] || name;
          hooks2 = jQuery2.propHooks[name];
        }
        if (value !== void 0) {
          if (hooks2 && "set" in hooks2 && (ret = hooks2.set(elem, value, name)) !== void 0) {
            return ret;
          }
          return elem[name] = value;
        }
        if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, name)) !== null) {
          return ret;
        }
        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery2.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery2.propHooks.selected = {
        get: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2 && parent2.parentNode) {
            parent2.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2) {
            parent2.selectedIndex;
            if (parent2.parentNode) {
              parent2.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery2.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery2.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery2.fn.extend({
      addClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery2(this).addClass(value.call(this, j, getClass(this)));
          });
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      removeClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery2(this).removeClass(value.call(this, j, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (isFunction2(value)) {
          return this.each(function(i2) {
            jQuery2(this).toggleClass(
              value.call(this, i2, getClass(this), stateVal),
              stateVal
            );
          });
        }
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        classNames = classesToArray(value);
        return this.each(function() {
          if (isValidValue) {
            self2 = jQuery2(this);
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute(
                "class",
                className || value === false ? "" : dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i = 0;
        className = " " + selector + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery2.fn.extend({
      val: function(value) {
        var hooks2, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks2 = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
            if (hooks2 && "get" in hooks2 && (ret = hooks2.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction2(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery2(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery2.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks2 = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
          if (!hooks2 || !("set" in hooks2) || hooks2.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery2.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery2.find.attr(elem, "value");
            return val != null ? val : (
              // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery2.text(elem))
            );
          }
        },
        select: {
          get: function(elem) {
            var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max2 = one ? index + 1 : options.length;
            if (index < 0) {
              i = max2;
            } else {
              i = one ? index : 0;
            }
            for (; i < max2; i++) {
              option = options[i];
              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                value = jQuery2(option).val();
                if (one) {
                  return value;
                }
                values2.push(value);
              }
            }
            return values2;
          },
          set: function(elem, value) {
            var optionSet, option, options = elem.options, values2 = jQuery2.makeArray(value), i = options.length;
            while (i--) {
              option = options[i];
              if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values2) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values2;
          }
        }
      }
    });
    jQuery2.each(["radio", "checkbox"], function() {
      jQuery2.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery2.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    var location2 = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery2.parseXML = function(data) {
      var xml, parserErrorElem;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        xml = new window2.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
      }
      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data));
      }
      return xml;
    };
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery2.extend(jQuery2.event, {
      trigger: function(event, data, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery2.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [event] : jQuery2.makeArray(data, [event]);
        special = jQuery2.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery2.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery2.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function(type, elem, event) {
        var e = jQuery2.extend(
          new jQuery2.Event(),
          event,
          {
            type,
            isSimulated: true
          }
        );
        jQuery2.event.trigger(e, null, elem);
      }
    });
    jQuery2.fn.extend({
      trigger: function(type, data) {
        return this.each(function() {
          jQuery2.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery2.event.trigger(type, data, elem, true);
        }
      }
    });
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
      var name;
      if (Array.isArray(obj)) {
        jQuery2.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix)) {
            add(prefix, v);
          } else {
            buildParams(
              prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
              v,
              traditional,
              add
            );
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        add(prefix, obj);
      }
    }
    jQuery2.param = function(a, traditional) {
      var prefix, s = [], add = function(key, valueOrFunction) {
        var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a == null) {
        return "";
      }
      if (Array.isArray(a) || a.jquery && !jQuery2.isPlainObject(a)) {
        jQuery2.each(a, function() {
          add(this.name, this.value);
        });
      } else {
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      }
      return s.join("&");
    };
    jQuery2.fn.extend({
      serialize: function() {
        return jQuery2.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery2.prop(this, "elements");
          return elements ? jQuery2.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(_i, elem) {
          var val = jQuery2(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery2.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports2 = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location2.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction2(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports2;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery2.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery2.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location2.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location2.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery2.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(target, settings) {
        return settings ? (
          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
        ) : (
          // Extending ajaxSettings
          ajaxExtend(jQuery2.ajaxSettings, target)
        );
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports2),
      // Main method
      ajax: function(url2, options) {
        if (typeof url2 === "object") {
          options = url2;
          url2 = void 0;
        }
        options = options || {};
        var transport2, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery2.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                }
              }
              match = responseHeaders[key.toLowerCase() + " "];
            }
            return match == null ? null : match.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function(name, value) {
            if (completed2 == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (completed2 == null) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function(map2) {
            var code;
            if (map2) {
              if (completed2) {
                jqXHR.always(map2[jqXHR.status]);
              } else {
                for (code in map2) {
                  statusCode[code] = [statusCode[code], map2[code]];
                }
              }
            }
            return this;
          },
          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport2) {
              transport2.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url2 || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery2.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery2.event && s.global;
        if (fireGlobals && jQuery2.active++ === 0) {
          jQuery2.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery2.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
          }
          if (jQuery2.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader(
          "Accept",
          s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
        );
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport2 = inspectPrefiltersOrTransports(transports2, s, options, jqXHR);
        if (!transport2) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed2 = false;
            transport2.send(requestHeaders, done);
          } catch (e) {
            if (completed2) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport2 = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          if (!isSuccess && jQuery2.inArray("script", s.dataTypes) > -1 && jQuery2.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery2.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery2.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(
              isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s, isSuccess ? success : error]
            );
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery2.active) {
              jQuery2.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url2, data, callback) {
        return jQuery2.get(url2, data, callback, "json");
      },
      getScript: function(url2, callback) {
        return jQuery2.get(url2, void 0, callback, "script");
      }
    });
    jQuery2.each(["get", "post"], function(_i, method) {
      jQuery2[method] = function(url2, data, callback, type) {
        if (isFunction2(data)) {
          type = type || callback;
          callback = data;
          data = void 0;
        }
        return jQuery2.ajax(jQuery2.extend({
          url: url2,
          type: method,
          dataType: type,
          data,
          success: callback
        }, jQuery2.isPlainObject(url2) && url2));
      };
    });
    jQuery2.ajaxPrefilter(function(s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });
    jQuery2._evalUrl = function(url2, options, doc) {
      return jQuery2.ajax({
        url: url2,
        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery2.globalEval(response, options, doc);
        }
      });
    };
    jQuery2.fn.extend({
      wrapAll: function(html) {
        var wrap2;
        if (this[0]) {
          if (isFunction2(html)) {
            html = html.call(this[0]);
          }
          wrap2 = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap2.insertBefore(this[0]);
          }
          wrap2.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction2(html)) {
          return this.each(function(i) {
            jQuery2(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self2 = jQuery2(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction2(html);
        return this.each(function(i) {
          jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery2(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery2.expr.pseudos.hidden = function(elem) {
      return !jQuery2.expr.pseudos.visible(elem);
    };
    jQuery2.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery2.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    };
    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    }, xhrSupported = jQuery2.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery2.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(
                        // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status,
                        xhr.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr.status] || xhr.status,
                      xhr.statusText,
                      // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                      xhr.getAllResponseHeaders()
                    );
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== void 0) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery2.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery2.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery2.globalEval(text);
          return text;
        }
      }
    });
    jQuery2.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery2.ajaxTransport("script", function(s) {
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function(_2, complete) {
            script = jQuery2("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery2.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery2.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction2(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery2.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery2(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction2(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery2.parseHTML = function(data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document2.implementation.createHTMLDocument("");
          base = context.createElement("base");
          base.href = document2.location.href;
          context.head.appendChild(base);
        } else {
          context = document2;
        }
      }
      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data], context, scripts);
      if (scripts && scripts.length) {
        jQuery2(scripts).remove();
      }
      return jQuery2.merge([], parsed.childNodes);
    };
    jQuery2.fn.load = function(url2, params, callback) {
      var selector, type, response, self2 = this, off = url2.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url2.slice(off));
        url2 = url2.slice(0, off);
      }
      if (isFunction2(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery2.ajax({
          url: url2,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? (
            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
          ) : (
            // Otherwise use the full result
            responseText
          ));
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery2.expr.pseudos.animated = function(elem) {
      return jQuery2.grep(jQuery2.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery2.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery2.css(elem, "top");
        curCSSLeft = jQuery2.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction2(options)) {
          options = options.call(elem, i, jQuery2.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery2.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i) {
            jQuery2.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery2.css(elem, "position") === "fixed") {
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset();
          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;
          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery2(offsetParent).offset();
            parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
      var top = "pageYOffset" === prop;
      jQuery2.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method2];
          }
          if (win) {
            win.scrollTo(
              !top ? val2 : win.pageXOffset,
              top ? val2 : win.pageYOffset
            );
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery2.each(["top", "left"], function(_i, prop) {
      jQuery2.cssHooks[prop] = addGetHookIf(
        support.pixelPosition,
        function(elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);
            return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
          }
        }
      );
    });
    jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
      jQuery2.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function(defaultExtra, funcName) {
        jQuery2.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            }
            if (elem.nodeType === 9) {
              doc = elem.documentElement;
              return Math.max(
                elem.body["scroll" + name],
                doc["scroll" + name],
                elem.body["offset" + name],
                doc["offset" + name],
                doc["client" + name]
              );
            }
            return value2 === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery2.css(elem, type2, extra)
            ) : (
              // Set width or height on the element
              jQuery2.style(elem, type2, value2, extra)
            );
          }, type, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery2.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type) {
      jQuery2.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    });
    jQuery2.fn.extend({
      bind: function(types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function(types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function(selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function(selector, types, fn) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery2.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(_i, name) {
        jQuery2.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      }
    );
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    jQuery2.proxy = function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!isFunction2(fn)) {
        return void 0;
      }
      args = slice2.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice2.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery2.guid++;
      return proxy;
    };
    jQuery2.holdReady = function(hold) {
      if (hold) {
        jQuery2.readyWait++;
      } else {
        jQuery2.ready(true);
      }
    };
    jQuery2.isArray = Array.isArray;
    jQuery2.parseJSON = JSON.parse;
    jQuery2.nodeName = nodeName;
    jQuery2.isFunction = isFunction2;
    jQuery2.isWindow = isWindow;
    jQuery2.camelCase = camelCase;
    jQuery2.type = toType;
    jQuery2.now = Date.now;
    jQuery2.isNumeric = function(obj) {
      var type = jQuery2.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };
    jQuery2.trim = function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "$1");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery2.noConflict = function(deep) {
      if (window2.$ === jQuery2) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery2) {
        window2.jQuery = _jQuery;
      }
      return jQuery2;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery2;
    }
    return jQuery2;
  });
})(jquery);
var jqueryExports = jquery.exports;
window.$ = jqueryExports;
const jq = window.$.noConflict(true);
rjquery.jQuery = rjquery.$ = jq;
var browser$2 = { exports: {} };
(function(module) {
  /*!
    * Bowser - a browser detector
    * https://github.com/ded/bowser
    * MIT License | (c) Dustin Diaz 2015
    */
  !function(name, definition) {
    if (module.exports)
      module.exports = definition();
    else
      this[name] = definition();
  }("bowser", function() {
    var t = true;
    function detect(ua) {
      function getFirstMatch(regex) {
        var match = ua.match(regex);
        return match && match.length > 1 && match[1] || "";
      }
      function getSecondMatch(regex) {
        var match = ua.match(regex);
        return match && match.length > 1 && match[2] || "";
      }
      var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(), likeAndroid = /like android/i.test(ua), android = !likeAndroid && /android/i.test(ua), chromeos = /CrOS/.test(ua), silk = /silk/i.test(ua), sailfish = /sailfish/i.test(ua), tizen = /tizen/i.test(ua), webos = /(web|hpw)os/i.test(ua), windowsphone = /windows phone/i.test(ua), windows = !windowsphone && /windows/i.test(ua), mac = !iosdevice && !silk && /macintosh/i.test(ua), linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua), edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i), versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i), tablet = /tablet/i.test(ua), mobile = !tablet && /[^-]mobi/i.test(ua), result2;
      if (/opera|opr/i.test(ua)) {
        result2 = {
          name: "Opera",
          opera: t,
          version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
        };
      } else if (/yabrowser/i.test(ua)) {
        result2 = {
          name: "Yandex Browser",
          yandexbrowser: t,
          version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
        };
      } else if (windowsphone) {
        result2 = {
          name: "Windows Phone",
          windowsphone: t
        };
        if (edgeVersion) {
          result2.msedge = t;
          result2.version = edgeVersion;
        } else {
          result2.msie = t;
          result2.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
        }
      } else if (/msie|trident/i.test(ua)) {
        result2 = {
          name: "Internet Explorer",
          msie: t,
          version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
        };
      } else if (chromeos) {
        result2 = {
          name: "Chrome",
          chromeos: t,
          chromeBook: t,
          chrome: t,
          version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
        };
      } else if (/chrome.+? edge/i.test(ua)) {
        result2 = {
          name: "Microsoft Edge",
          msedge: t,
          version: edgeVersion
        };
      } else if (/chrome|crios|crmo/i.test(ua)) {
        result2 = {
          name: "Chrome",
          chrome: t,
          version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
        };
      } else if (iosdevice) {
        result2 = {
          name: iosdevice == "iphone" ? "iPhone" : iosdevice == "ipad" ? "iPad" : "iPod"
        };
        if (versionIdentifier) {
          result2.version = versionIdentifier;
        }
      } else if (sailfish) {
        result2 = {
          name: "Sailfish",
          sailfish: t,
          version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
        };
      } else if (/seamonkey\//i.test(ua)) {
        result2 = {
          name: "SeaMonkey",
          seamonkey: t,
          version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
        };
      } else if (/firefox|iceweasel/i.test(ua)) {
        result2 = {
          name: "Firefox",
          firefox: t,
          version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
        };
        if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
          result2.firefoxos = t;
        }
      } else if (silk) {
        result2 = {
          name: "Amazon Silk",
          silk: t,
          version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
        };
      } else if (android) {
        result2 = {
          name: "Android",
          version: versionIdentifier
        };
      } else if (/phantom/i.test(ua)) {
        result2 = {
          name: "PhantomJS",
          phantom: t,
          version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
        };
      } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
        result2 = {
          name: "BlackBerry",
          blackberry: t,
          version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
        };
      } else if (webos) {
        result2 = {
          name: "WebOS",
          webos: t,
          version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
        };
        /touchpad\//i.test(ua) && (result2.touchpad = t);
      } else if (/bada/i.test(ua)) {
        result2 = {
          name: "Bada",
          bada: t,
          version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
        };
      } else if (tizen) {
        result2 = {
          name: "Tizen",
          tizen: t,
          version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
        };
      } else if (/safari/i.test(ua)) {
        result2 = {
          name: "Safari",
          safari: t,
          version: versionIdentifier
        };
      } else {
        result2 = {
          name: getFirstMatch(/^(.*)\/(.*) /),
          version: getSecondMatch(/^(.*)\/(.*) /)
        };
      }
      if (!result2.msedge && /(apple)?webkit/i.test(ua)) {
        result2.name = result2.name || "Webkit";
        result2.webkit = t;
        if (!result2.version && versionIdentifier) {
          result2.version = versionIdentifier;
        }
      } else if (!result2.opera && /gecko\//i.test(ua)) {
        result2.name = result2.name || "Gecko";
        result2.gecko = t;
        result2.version = result2.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
      }
      if (!result2.msedge && (android || result2.silk)) {
        result2.android = t;
      } else if (iosdevice) {
        result2[iosdevice] = t;
        result2.ios = t;
      } else if (windows) {
        result2.windows = t;
      } else if (mac) {
        result2.mac = t;
      } else if (linux) {
        result2.linux = t;
      }
      var osVersion = "";
      if (result2.windowsphone) {
        osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
      } else if (iosdevice) {
        osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
        osVersion = osVersion.replace(/[_\s]/g, ".");
      } else if (android) {
        osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
      } else if (result2.webos) {
        osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
      } else if (result2.blackberry) {
        osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
      } else if (result2.bada) {
        osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
      } else if (result2.tizen) {
        osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
      }
      if (osVersion) {
        result2.osversion = osVersion;
      }
      var osMajorVersion = osVersion.split(".")[0];
      if (tablet || iosdevice == "ipad" || android && (osMajorVersion == 3 || osMajorVersion == 4 && !mobile) || result2.silk) {
        result2.tablet = t;
      } else if (mobile || iosdevice == "iphone" || iosdevice == "ipod" || android || result2.blackberry || result2.webos || result2.bada) {
        result2.mobile = t;
      }
      if (result2.msedge || result2.msie && result2.version >= 10 || result2.yandexbrowser && result2.version >= 15 || result2.chrome && result2.version >= 20 || result2.firefox && result2.version >= 20 || result2.safari && result2.version >= 6 || result2.opera && result2.version >= 10 || result2.ios && result2.osversion && result2.osversion.split(".")[0] >= 6 || result2.blackberry && result2.version >= 10.1) {
        result2.a = t;
      } else if (result2.msie && result2.version < 10 || result2.chrome && result2.version < 20 || result2.firefox && result2.version < 20 || result2.safari && result2.version < 6 || result2.opera && result2.version < 10 || result2.ios && result2.osversion && result2.osversion.split(".")[0] < 6) {
        result2.c = t;
      } else
        result2.x = t;
      return result2;
    }
    var bowser = detect(typeof navigator !== "undefined" ? navigator.userAgent : "");
    bowser.test = function(browserList) {
      for (var i = 0; i < browserList.length; ++i) {
        var browserItem = browserList[i];
        if (typeof browserItem === "string") {
          if (browserItem in bowser) {
            return true;
          }
        }
      }
      return false;
    };
    bowser._detect = detect;
    return bowser;
  });
})(browser$2);
var browserExports = browser$2.exports;
var client_plugins = {};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var shared = {};
var plugin_defs = {};
plugin_defs.hooks = {};
plugin_defs.loaded = false;
plugin_defs.parts = [];
plugin_defs.plugins = {};
const defs = plugin_defs;
const disabledHookReasons = {
  hooks: {
    indexCustomInlineScripts: "The hook makes it impossible to use a Content Security Policy that prohibits inline code. Permitting inline code makes XSS vulnerabilities more likely"
  }
};
const loadFn = (path, hookName) => {
  let functionName;
  const parts = path.split(":");
  if (parts[0].length === 1) {
    if (parts.length === 3) {
      functionName = parts.pop();
    }
    path = parts.join(":");
  } else {
    path = parts[0];
    functionName = parts[1];
  }
  let fn = commonjsRequire(path);
  functionName = functionName ? functionName : hookName;
  for (const name of functionName.split(".")) {
    fn = fn[name];
  }
  return fn;
};
const extractHooks = (parts, hookSetName, normalizer) => {
  const hooks2 = {};
  for (const part of parts || []) {
    for (const [hookName, regHookFnName] of Object.entries(part[hookSetName] || {})) {
      const hookFnName = normalizer ? normalizer(part, regHookFnName, hookName) : regHookFnName;
      const disabledReason = (disabledHookReasons[hookSetName] || {})[hookName];
      if (disabledReason) {
        console.error(`Hook ${hookSetName}/${hookName} is disabled. Reason: ${disabledReason}`);
        console.error(`The hook function ${hookFnName} from plugin ${part.plugin} will never be called, which may cause the plugin to fail`);
        console.error(`Please update the ${part.plugin} plugin to not use the ${hookName} hook`);
        return;
      }
      let hookFn;
      try {
        console.log("Loading hook", hookFnName, hookName);
        hookFn = loadFn(hookFnName, hookName);
        if (!hookFn)
          throw new Error("Not a function");
      } catch (err) {
        console.error(`Failed to load hook function "${hookFnName}" for plugin "${part.plugin}" part "${part.name}" hook set "${hookSetName}" hook "${hookName}": ${err.stack || err}`);
      }
      if (hookFn) {
        if (hooks2[hookName] == null)
          hooks2[hookName] = [];
        hooks2[hookName].push({
          hook_name: hookName,
          hook_fn: hookFn,
          hook_fn_name: hookFnName,
          part
        });
      }
    }
  }
  return hooks2;
};
shared.extractHooks = extractHooks;
shared.clientPluginNames = () => {
  const clientPluginNames = defs.parts.filter((part) => Object.prototype.hasOwnProperty.call(part, "client_hooks")).map((part) => `plugin-${part.plugin}`);
  return [...new Set(clientPluginNames)];
};
(function(exports) {
  const pluginUtils = shared;
  const defs2 = plugin_defs;
  exports.baseURL = "";
  exports.ensure = (cb2) => !defs2.loaded ? exports.update(cb2) : cb2();
  exports.update = (cb2) => {
    const callback = () => setTimeout(cb2, 0);
    jQuery.getJSON(
      `${exports.baseURL}pluginfw/plugin-definitions.json?v=${clientVars.randomVersionString}`
    ).done((data) => {
      defs2.plugins = data.plugins;
      defs2.parts = data.parts;
      defs2.hooks = pluginUtils.extractHooks(defs2.parts, "client_hooks");
      defs2.loaded = true;
      callback();
    }).fail((err) => {
      console.error(`Failed to load plugin-definitions: ${err}`);
      callback();
    });
  };
  const adoptPluginsFromAncestorsOf = (require3) => {
    if (!require3)
      throw new Error("Parent plugins could not be found.");
    const ancestorPluginDefs = {
      hooks: {},
      loaded: true,
      parts: [],
      plugins: {}
    };
    defs2.hooks = ancestorPluginDefs.hooks;
    defs2.loaded = ancestorPluginDefs.loaded;
    defs2.parts = ancestorPluginDefs.parts;
    defs2.plugins = ancestorPluginDefs.plugins;
    const ancestorPlugins = {
      baseURL: "/",
      ensure: (cb2) => !defs2.loaded ? exports.update(cb2) : cb2(),
      update: exports.update
    };
    exports.baseURL = ancestorPlugins.baseURL;
    exports.ensure = ancestorPlugins.ensure;
    exports.update = ancestorPlugins.update;
  };
  exports.adoptPluginsFromAncestorsOf = adoptPluginsFromAncestorsOf;
})(client_plugins);
var hooks = {};
(function(exports) {
  const pluginDefs = plugin_defs;
  exports.deprecationNotices = {};
  const deprecationWarned = {};
  const checkDeprecation = (hook) => {
    const notice = exports.deprecationNotices[hook.hook_name];
    if (notice == null)
      return;
    if (deprecationWarned[hook.hook_fn_name])
      return;
    console.warn(`${hook.hook_name} hook used by the ${hook.part.plugin} plugin (${hook.hook_fn_name}) is deprecated: ${notice}`);
    deprecationWarned[hook.hook_fn_name] = true;
  };
  const attachCallback = (p, cb2) => p.then(
    (val) => cb2(null, val),
    // Callbacks often only check the truthiness, not the nullness, of the first parameter. To avoid
    // problems, always pass a truthy value as the first argument if the Promise is rejected.
    (err) => cb2(err || new Error(err))
  );
  const normalizeValue = (val) => {
    if (val === void 0)
      return [];
    if (Array.isArray(val))
      return val;
    return [val];
  };
  const flatten1 = (array) => array.reduce((a, b) => a.concat(b), []);
  const callHookFnSync = (hook, context) => {
    checkDeprecation(hook);
    let outcome;
    let doubleSettleErr;
    const settle = (err, val2, how) => {
      doubleSettleErr = null;
      const state = err == null ? "resolved" : "rejected";
      if (outcome != null) {
        const action = err == null ? "resolve" : "reject";
        const msg = `DOUBLE SETTLE BUG IN HOOK FUNCTION (plugin: ${hook.part.plugin}, function name: ${hook.hook_fn_name}, hook: ${hook.hook_name}): Attempt to ${action} via ${how} but it already ${outcome.state} via ${outcome.how}. Ignoring this attempt to ${action}.`;
        console.error(msg);
        if (state !== outcome.state || (err == null ? val2 !== outcome.val : err !== outcome.err)) {
          doubleSettleErr = new Error(msg);
          throw doubleSettleErr;
        }
        return;
      }
      outcome = { state, err, val: val2, how };
      if (val2 && typeof val2.then === "function") {
        console.error(`PROHIBITED PROMISE BUG IN HOOK FUNCTION (plugin: ${hook.part.plugin}, function name: ${hook.hook_fn_name}, hook: ${hook.hook_name}): The hook function provided a "thenable" (e.g., a Promise) which is prohibited because the hook expects to get the value synchronously.`);
      }
    };
    const callback = (ret) => {
      settle(null, ret, "callback");
    };
    let val;
    try {
      val = hook.hook_fn(hook.hook_name, context, callback);
    } catch (err) {
      if (err === doubleSettleErr)
        throw err;
      try {
        settle(err, null, "thrown exception");
      } catch (doubleSettleErr2) {
        Promise.resolve().then(() => {
          throw doubleSettleErr2;
        });
      }
      throw err;
    }
    if (val === void 0) {
      if (outcome != null)
        return outcome.val;
      if (hook.hook_fn.length >= 3) {
        console.error(`UNSETTLED FUNCTION BUG IN HOOK FUNCTION (plugin: ${hook.part.plugin}, function name: ${hook.hook_fn_name}, hook: ${hook.hook_name}): The hook function neither called the callback nor returned a non-undefined value. This is prohibited because it will result in freezes when a future version of Etherpad updates the hook to support asynchronous behavior.`);
      }
    }
    settle(null, val, "returned value");
    return outcome.val;
  };
  exports.callAll = (hookName, context) => {
    if (context == null)
      context = {};
    const hooks2 = pluginDefs.hooks[hookName] || [];
    return flatten1(hooks2.map((hook) => normalizeValue(callHookFnSync(hook, context))));
  };
  const callHookFnAsync = async (hook, context) => {
    checkDeprecation(hook);
    return await new Promise((resolve, reject2) => {
      let outcome;
      const settle = (err, val, how) => {
        const state = err == null ? "resolved" : "rejected";
        if (outcome != null) {
          const action = err == null ? "resolve" : "reject";
          const msg = `DOUBLE SETTLE BUG IN HOOK FUNCTION (plugin: ${hook.part.plugin}, function name: ${hook.hook_fn_name}, hook: ${hook.hook_name}): Attempt to ${action} via ${how} but it already ${outcome.state} via ${outcome.how}. Ignoring this attempt to ${action}.`;
          console.error(msg);
          if (state !== outcome.state || (err == null ? val !== outcome.val : err !== outcome.err)) {
            throw new Error(msg);
          }
          return;
        }
        outcome = { state, err, val, how };
        if (err == null) {
          resolve(val);
        } else {
          reject2(err);
        }
      };
      const callback = (ret2) => {
        Promise.resolve(ret2).then(
          (val) => settle(null, val, "callback"),
          (err) => settle(err, null, "rejected Promise passed to callback")
        );
      };
      let ret;
      try {
        ret = hook.hook_fn(hook.hook_name, context, callback);
      } catch (err) {
        try {
          settle(err, null, "thrown exception");
        } catch (doubleSettleErr) {
          Promise.resolve().then(() => {
            throw doubleSettleErr;
          });
        }
        throw err;
      }
      if (ret === void 0) {
        if (hook.hook_fn.length >= 3) {
          return;
        }
      }
      Promise.resolve(ret).then(
        (val) => settle(null, val, "returned value"),
        (err) => settle(err, null, "Promise rejection")
      );
    });
  };
  exports.aCallAll = async (hookName, context, cb2 = null) => {
    if (cb2 != null)
      return await attachCallback(exports.aCallAll(hookName, context), cb2);
    if (context == null)
      context = {};
    const hooks2 = pluginDefs.hooks[hookName] || [];
    const results = await Promise.all(
      hooks2.map(async (hook) => normalizeValue(await callHookFnAsync(hook, context)))
    );
    return flatten1(results);
  };
  exports.callAllSerial = async (hookName, context) => {
    if (context == null)
      context = {};
    const hooks2 = pluginDefs.hooks[hookName] || [];
    const results = [];
    for (const hook of hooks2) {
      results.push(normalizeValue(await callHookFnAsync(hook, context)));
    }
    return flatten1(results);
  };
  exports.callFirst = (hookName, context) => {
    if (context == null)
      context = {};
    const predicate = (val) => val.length;
    const hooks2 = pluginDefs.hooks[hookName] || [];
    for (const hook of hooks2) {
      const val = normalizeValue(callHookFnSync(hook, context));
      if (predicate(val))
        return val;
    }
    return [];
  };
  exports.aCallFirst = async (hookName, context, cb2 = null, predicate = null) => {
    if (cb2 != null) {
      return await attachCallback(exports.aCallFirst(hookName, context, null, predicate), cb2);
    }
    if (context == null)
      context = {};
    if (predicate == null)
      predicate = (val) => val.length;
    const hooks2 = pluginDefs.hooks[hookName] || [];
    for (const hook of hooks2) {
      const val = normalizeValue(await callHookFnAsync(hook, context));
      if (predicate(val))
        return val;
    }
    return [];
  };
  exports.exportedForTestingOnly = {
    callHookFnAsync,
    callHookFnSync,
    deprecationWarned
  };
})(hooks);
var pad$1 = {};
var farbtastic = {};
var hasRequiredFarbtastic;
function requireFarbtastic() {
  if (hasRequiredFarbtastic)
    return farbtastic;
  hasRequiredFarbtastic = 1;
  const jQuery2 = rjquery.jQuery;
  (function($2) {
    var __factor = 1;
    $2.fn.farbtastic = function(options) {
      $2.farbtastic(this, options);
      return this;
    };
    $2.farbtastic = function(container, options) {
      var container = $2(container)[0];
      return container.farbtastic || (container.farbtastic = new $2._farbtastic(container, options));
    };
    $2._farbtastic = function(container, options) {
      var fb = this;
      fb.linkTo = function(callback) {
        if (typeof fb.callback == "object") {
          $2(fb.callback).off("keyup").on("keyup", fb.updateValue);
        }
        fb.color = null;
        if (typeof callback == "function") {
          fb.callback = callback;
        } else if (typeof callback == "object" || typeof callback == "string") {
          fb.callback = $2(callback);
          fb.callback.on("keyup", fb.updateValue);
          if (fb.callback[0].value) {
            fb.setColor(fb.callback[0].value);
          }
        }
        return this;
      };
      fb.updateValue = function(event) {
        if (this.value && this.value != fb.color) {
          fb.setColor(this.value);
        }
      };
      fb.setColor = function(color) {
        var unpack = fb.unpack(color);
        if (fb.color != color && unpack) {
          fb.color = color;
          fb.rgb = unpack;
          fb.hsl = fb.RGBToHSL(fb.rgb);
          fb.updateDisplay();
        }
        return this;
      };
      fb.setHSL = function(hsl) {
        fb.hsl = hsl;
        var convertedHSL = [hsl[0]];
        convertedHSL[1] = hsl[1] * __factor + (1 - __factor) / 2;
        convertedHSL[2] = hsl[2] * __factor + (1 - __factor) / 2;
        fb.rgb = fb.HSLToRGB(convertedHSL);
        fb.color = fb.pack(fb.rgb);
        fb.updateDisplay();
        return this;
      };
      fb.initWidget = function() {
        var dim = {
          width: options.width,
          height: options.width
        };
        $2(container).html(
          '<div class="farbtastic" style="position: relative"><div class="farbtastic-solid"></div><canvas class="farbtastic-mask"></canvas><canvas class="farbtastic-overlay"></canvas></div>'
        ).find("*").attr(dim).css(dim).end().find("div>*").css("position", "absolute");
        browser.msie && $2("canvas", container).each(function() {
          var attr = { "class": $2(this).attr("class"), style: this.getAttribute("style") }, e = document.createElement("canvas");
          $2(this).before($2(e).attr(attr)).remove();
          G_vmlCanvasManager && G_vmlCanvasManager.initElement(e);
          $2(e).attr(dim).css(dim).css("position", "absolute").find("*").attr(dim).css(dim);
        });
        fb.radius = (options.width - options.wheelWidth) / 2 - 1;
        fb.square = Math.floor((fb.radius - options.wheelWidth / 2) * 0.7) - 1;
        fb.mid = Math.floor(options.width / 2);
        fb.markerSize = options.wheelWidth * 0.3;
        fb.solidFill = $2(".farbtastic-solid", container).css({
          width: fb.square * 2 - 1,
          height: fb.square * 2 - 1,
          left: fb.mid - fb.square,
          top: fb.mid - fb.square
        });
        fb.cnvMask = $2(".farbtastic-mask", container);
        fb.ctxMask = fb.cnvMask[0].getContext("2d");
        fb.cnvOverlay = $2(".farbtastic-overlay", container);
        fb.ctxOverlay = fb.cnvOverlay[0].getContext("2d");
        fb.ctxMask.translate(fb.mid, fb.mid);
        fb.ctxOverlay.translate(fb.mid, fb.mid);
        fb.drawCircle();
        fb.drawMask();
      };
      fb.drawCircle = function() {
        var n = 24, r = fb.radius, w = options.wheelWidth, nudge = 8 / r / n * Math.PI, m = fb.ctxMask, angle1 = 0, color1, d1;
        m.save();
        m.lineWidth = w / r;
        m.scale(r, r);
        for (var i = 0; i <= n; ++i) {
          var d2 = i / n, angle2 = d2 * Math.PI * 2, x1 = Math.sin(angle1), y1 = -Math.cos(angle1);
          let x2 = Math.sin(angle2), y2 = -Math.cos(angle2), am = (angle1 + angle2) / 2, tan = 1 / Math.cos((angle2 - angle1) / 2), xm = Math.sin(am) * tan, ym = -Math.cos(am) * tan, color2 = fb.pack(fb.HSLToRGB([d2, 1, 0.5]));
          if (i > 0) {
            if (browser.msie) {
              var corr = (1 + Math.min(Math.abs(Math.tan(angle1)), Math.abs(Math.tan(Math.PI / 2 - angle1)))) / n;
              color1 = fb.pack(fb.HSLToRGB([d1 - 0.15 * corr, 1, 0.5]));
              color2 = fb.pack(fb.HSLToRGB([d2 + 0.15 * corr, 1, 0.5]));
              var grad = m.createLinearGradient(x1, y1, x2, y2);
              grad.addColorStop(0, color1);
              grad.addColorStop(1, color2);
              m.fillStyle = grad;
              var r1 = (r + w / 2) / r, r2 = (r - w / 2) / r;
              m.beginPath();
              m.moveTo(x1 * r1, y1 * r1);
              m.quadraticCurveTo(xm * r1, ym * r1, x2 * r1, y2 * r1);
              m.lineTo(x2 * r2, y2 * r2);
              m.quadraticCurveTo(xm * r2, ym * r2, x1 * r2, y1 * r2);
              m.fill();
            } else {
              var grad = m.createLinearGradient(x1, y1, x2, y2);
              grad.addColorStop(0, color1);
              grad.addColorStop(1, color2);
              m.strokeStyle = grad;
              m.beginPath();
              m.moveTo(x1, y1);
              m.quadraticCurveTo(xm, ym, x2, y2);
              m.stroke();
            }
          }
          angle1 = angle2 - nudge;
          color1 = color2;
          d1 = d2;
        }
        m.restore();
      };
      fb.drawMask = function() {
        var size2 = fb.square * 2, sq = fb.square;
        function calculateMask(sizex2, sizey, outputPixel) {
          var isx = 1 / sizex2, isy = 1 / sizey;
          for (var y = 0; y <= sizey; ++y) {
            var l = 1 - y * isy;
            for (var x = 0; x <= sizex2; ++x) {
              var s = 1 - x * isx;
              var a = 1 - 2 * Math.min(l * s, (1 - l) * s);
              var c = a > 0 ? (2 * l - 1 + a) * 0.5 / a : 0;
              a = a * __factor + (1 - __factor) / 2;
              c = c * __factor + (1 - __factor) / 2;
              outputPixel(x, y, c, a);
            }
          }
        }
        if (fb.ctxMask.getImageData) {
          var sz = Math.floor(size2 / 2);
          var buffer = document.createElement("canvas");
          buffer.width = buffer.height = sz + 1;
          var ctx = buffer.getContext("2d");
          var frame = ctx.getImageData(0, 0, sz + 1, sz + 1);
          var i = 0;
          calculateMask(sz, sz, function(x, y, c, a) {
            frame.data[i++] = frame.data[i++] = frame.data[i++] = c * 255;
            frame.data[i++] = a * 255;
          });
          ctx.putImageData(frame, 0, 0);
          fb.ctxMask.drawImage(buffer, 0, 0, sz + 1, sz + 1, -sq, -sq, sq * 2, sq * 2);
        } else if (!browser.msie) {
          var sz = Math.floor(size2 / 2);
          calculateMask(sz, sz, function(x, y, c, a) {
            c = Math.round(c * 255);
            fb.ctxMask.fillStyle = "rgba(" + c + ", " + c + ", " + c + ", " + a + ")";
            fb.ctxMask.fillRect(x * 2 - sq - 1, y * 2 - sq - 1, 2, 2);
          });
        } else {
          var cache_last, cache, w = 6;
          var sizex = Math.floor(size2 / w);
          calculateMask(sizex, 6, function(x, y, c, a) {
            if (x == 0) {
              cache_last = cache;
              cache = [];
            }
            c = Math.round(c * 255);
            a = Math.round(a * 255);
            if (y > 0) {
              var c_last = cache_last[x][0], a_last = cache_last[x][1], color1 = fb.packDX(c_last, a_last), color2 = fb.packDX(c, a), y1 = Math.round(fb.mid + ((y - 1) * 0.333 - 1) * sq), y2 = Math.round(fb.mid + (y * 0.333 - 1) * sq);
              $2("<div>").css({
                position: "absolute",
                filter: "progid:DXImageTransform.Microsoft.Gradient(StartColorStr=" + color1 + ", EndColorStr=" + color2 + ", GradientType=0)",
                top: y1,
                height: y2 - y1,
                // Avoid right-edge sticking out.
                left: fb.mid + (x * w - sq - 1),
                width: w - (x == sizex ? Math.round(w / 2) : 0)
              }).appendTo(fb.cnvMask);
            }
            cache.push([c, a]);
          });
        }
      };
      fb.drawMarkers = function() {
        var sz = options.width;
        var angle = fb.hsl[0] * 6.28, x1 = Math.sin(angle) * fb.radius, y1 = -Math.cos(angle) * fb.radius, x2 = 2 * fb.square * (0.5 - fb.hsl[1]), y2 = 2 * fb.square * (0.5 - fb.hsl[2]);
        var circles = [
          { x: x1, y: y1, r: fb.markerSize + 1, c: "rgb(0,0,0,.4)", lw: 2 },
          { x: x1, y: y1, r: fb.markerSize, c: "#fff", lw: 2 },
          { x: x2, y: y2, r: fb.markerSize + 1, c: "rgb(0,0,0,.4)", lw: 2 },
          { x: x2, y: y2, r: fb.markerSize, c: "#fff", lw: 2 }
        ];
        fb.ctxOverlay.clearRect(-fb.mid, -fb.mid, sz, sz);
        for (let i in circles) {
          var c = circles[i];
          fb.ctxOverlay.lineWidth = c.lw;
          fb.ctxOverlay.strokeStyle = c.c;
          fb.ctxOverlay.beginPath();
          fb.ctxOverlay.arc(c.x, c.y, c.r, 0, Math.PI * 2, true);
          fb.ctxOverlay.stroke();
        }
      };
      fb.updateDisplay = function() {
        fb.invert = fb.rgb[0] * 0.3 + fb.rgb[1] * 0.59 + fb.rgb[2] * 0.11 <= 0.6;
        fb.solidFill.css("backgroundColor", fb.pack(fb.HSLToRGB([fb.hsl[0], 1, 0.5])));
        fb.drawMarkers();
        if (typeof fb.callback == "object") {
          $2(fb.callback).css({
            backgroundColor: fb.color,
            color: fb.invert ? "#fff" : "#000"
          });
          $2(fb.callback).each(function() {
            if (typeof this.value == "string" && this.value != fb.color) {
              this.value = fb.color;
            }
          });
        } else if (typeof fb.callback == "function") {
          fb.callback.call(fb, fb.color);
        }
      };
      fb.widgetCoords = function(event) {
        return {
          x: event.pageX - fb.offset.left - fb.mid,
          y: event.pageY - fb.offset.top - fb.mid
        };
      };
      fb.mousedown = function(event) {
        if (!$2._farbtastic.dragging) {
          $2(document).on("mousemove", fb.mousemove).on("mouseup", fb.mouseup);
          $2._farbtastic.dragging = true;
        }
        fb.offset = $2(container).offset();
        var pos = fb.widgetCoords(event);
        fb.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) > fb.square + 2;
        fb.mousemove(event);
        return false;
      };
      fb.mousemove = function(event) {
        var pos = fb.widgetCoords(event);
        if (fb.circleDrag) {
          var hue = Math.atan2(pos.x, -pos.y) / 6.28;
          fb.setHSL([(hue + 1) % 1, fb.hsl[1], fb.hsl[2]]);
        } else {
          var sat = Math.max(0, Math.min(1, -(pos.x / fb.square / 2) + 0.5));
          var lum = Math.max(0, Math.min(1, -(pos.y / fb.square / 2) + 0.5));
          fb.setHSL([fb.hsl[0], sat, lum]);
        }
        return false;
      };
      fb.mouseup = function() {
        $2(document).off("mousemove", fb.mousemove);
        $2(document).off("mouseup", fb.mouseup);
        $2._farbtastic.dragging = false;
      };
      fb.dec2hex = function(x) {
        return (x < 16 ? "0" : "") + x.toString(16);
      };
      fb.packDX = function(c, a) {
        return "#" + fb.dec2hex(a) + fb.dec2hex(c) + fb.dec2hex(c) + fb.dec2hex(c);
      };
      fb.pack = function(rgb) {
        var r = Math.round(rgb[0] * 255);
        var g = Math.round(rgb[1] * 255);
        var b = Math.round(rgb[2] * 255);
        return "#" + fb.dec2hex(r) + fb.dec2hex(g) + fb.dec2hex(b);
      };
      fb.unpack = function(color) {
        if (color.length == 7) {
          let x2 = function(i) {
            return parseInt(color.substring(i, i + 2), 16) / 255;
          };
          var x = x2;
          return [x2(1), x2(3), x2(5)];
        } else if (color.length == 4) {
          let x2 = function(i) {
            return parseInt(color.substring(i, i + 1), 16) / 15;
          };
          var x = x2;
          return [x2(1), x2(2), x2(3)];
        }
      };
      fb.HSLToRGB = function(hsl) {
        var m1, m2;
        var h = hsl[0], s = hsl[1], l = hsl[2];
        m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;
        return [
          this.hueToRGB(m1, m2, h + 0.33333),
          this.hueToRGB(m1, m2, h),
          this.hueToRGB(m1, m2, h - 0.33333)
        ];
      };
      fb.hueToRGB = function(m1, m2, h) {
        h = (h + 1) % 1;
        if (h * 6 < 1)
          return m1 + (m2 - m1) * h * 6;
        if (h * 2 < 1)
          return m2;
        if (h * 3 < 2)
          return m1 + (m2 - m1) * (0.66666 - h) * 6;
        return m1;
      };
      fb.RGBToHSL = function(rgb) {
        var r = rgb[0], g = rgb[1], b = rgb[2], min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), delta = max2 - min2, h = 0, s = 0, l = (min2 + max2) / 2;
        if (l > 0 && l < 1) {
          s = delta / (l < 0.5 ? 2 * l : 2 - 2 * l);
        }
        if (delta > 0) {
          if (max2 == r && max2 != g)
            h += (g - b) / delta;
          if (max2 == g && max2 != b)
            h += 2 + (b - r) / delta;
          if (max2 == b && max2 != r)
            h += 4 + (r - g) / delta;
          h /= 6;
        }
        return [h, s, l];
      };
      if (!options.callback) {
        options = { callback: options };
      }
      options = $2.extend({
        width: 300,
        wheelWidth: (options.width || 300) / 10,
        callback: null
      }, options);
      fb.initWidget();
      $2("canvas.farbtastic-overlay", container).on("mousedown", fb.mousedown);
      if (options.callback) {
        fb.linkTo(options.callback);
      }
      fb.setColor("#808080");
    };
  })(jQuery2);
  return farbtastic;
}
var gritter = {};
var hasRequiredGritter;
function requireGritter() {
  if (hasRequiredGritter)
    return gritter;
  hasRequiredGritter = 1;
  const jQuery2 = rjquery.jQuery;
  (function($2) {
    $2.gritter = {};
    $2.gritter.options = {
      position: "",
      class_name: "",
      // could be set to 'gritter-light' to use white notifications
      time: 3e3
      // hang on the screen for...
    };
    $2.gritter.add = function(params) {
      try {
        return Gritter.add(params || {});
      } catch (e) {
        var err = "Gritter Error: " + e;
        typeof console != "undefined" && console.error ? console.error(err, params) : alert(err);
      }
    };
    $2.gritter.remove = function(id, params) {
      Gritter.removeSpecific(id.split("gritter-item-")[1], params || {});
    };
    $2.gritter.removeAll = function(params) {
      Gritter.stop(params || {});
    };
    var Gritter = {
      // Public - options to over-ride with $.gritter.options in "add"
      time: "",
      // Private - no touchy the private parts
      _custom_timer: 0,
      _item_count: 0,
      _is_setup: 0,
      _tpl_wrap_top: '<div id="gritter-container" class="top"></div>',
      _tpl_wrap_bottom: '<div id="gritter-container" class="bottom"></div>',
      _tpl_close: "",
      _tpl_title: $2("<h3>").addClass("gritter-title"),
      _tpl_item: $2("<div>").addClass("popup gritter-item").append($2("<div>").addClass("popup-content").append($2("<div>").addClass("gritter-content")).append($2("<div>").addClass("gritter-close").append($2("<i>").addClass("buttonicon buttonicon-times")))),
      /**
      * Add a gritter notification to the screen
      * @param {Object} params The object that contains all the options for drawing the notification
      * @return {Integer} The specific numeric id to that gritter notification
      */
      add: function(params) {
        if (typeof params == "string") {
          params = { text: params };
        }
        if (!params.text) {
          throw 'You must supply "text" parameter.';
        }
        if (!this._is_setup) {
          this._runSetup();
        }
        var title = params.title, text = params.text;
        params.image || "";
        var position = params.position || "top", sticky = params.sticky || false, item_class = params.class_name || $2.gritter.options.class_name, time_alive = params.time || "";
        this._verifyWrapper();
        if (sticky) {
          item_class += " sticky";
        }
        this._item_count++;
        var number = this._item_count;
        $2(["before_open", "after_open", "before_close", "after_close"]).each(function(i, val) {
          Gritter["_" + val + "_" + number] = $2.isFunction(params[val]) ? params[val] : function() {
          };
        });
        this._custom_timer = 0;
        if (time_alive) {
          this._custom_timer = time_alive;
        }
        if (title) {
          title = this._tpl_title.clone().append(
            typeof title === "string" ? document.createTextNode(title) : title
          );
        } else {
          title = "";
        }
        const tmp = this._tpl_item.clone();
        tmp.attr("id", `gritter-item-${number}`);
        tmp.addClass(item_class);
        tmp.find(".gritter-content").append(title).append(typeof text === "string" ? $2("<p>").text(text) : text);
        if (this["_before_open_" + number]() === false) {
          return false;
        }
        if (["top", "bottom"].indexOf(position) == -1) {
          position = "top";
        }
        $2("#gritter-container." + position).append(tmp);
        var item = $2("#gritter-item-" + this._item_count);
        setTimeout(function() {
          item.addClass("popup-show");
        }, 0);
        Gritter["_after_open_" + number](item);
        if (!sticky) {
          this._setFadeTimer(item, number);
          $2(item).on("mouseenter", function(event) {
            Gritter._restoreItemIfFading($2(this), number);
          });
          $2(item).on("mouseleave", function(event) {
            Gritter._setFadeTimer($2(this), number);
          });
        }
        $2(item).find(".gritter-close").click(function() {
          Gritter.removeSpecific(number, {}, null, true);
        });
        return number;
      },
      /**
      * If we don't have any more gritter notifications, get rid of the wrapper using this check
      * @private
      * @param {Integer} unique_id The ID of the element that was just deleted, use it for a callback
      * @param {Object} e The jQuery element that we're going to perform the remove() action on
      * @param {Boolean} manual_close Did we close the gritter dialog with the (X) button
      */
      _countRemoveWrapper: function(unique_id, e, manual_close) {
        e.remove();
        this["_after_close_" + unique_id](e, manual_close);
        $2("#gritter-container").each(function() {
          if ($2(this).find(".gritter-item").length == 0) {
            $2(this).remove();
          }
        });
      },
      /**
      * Fade out an element after it's been on the screen for x amount of time
      * @private
      * @param {Object} e The jQuery element to get rid of
      * @param {Integer} unique_id The id of the element to remove
      * @param {Object} params An optional list of params.
      * @param {Boolean} unbind_events Unbind the mouseenter/mouseleave events if they click (X)
      */
      _fade: function(e, unique_id, params, unbind_events) {
        var params = params || {}, fade = typeof params.fade != "undefined" ? params.fade : true, manual_close = unbind_events;
        this["_before_close_" + unique_id](e, manual_close);
        if (unbind_events) {
          e.unbind("mouseenter mouseleave");
        }
        if (fade) {
          e.removeClass("popup-show");
          setTimeout(function() {
            Gritter._countRemoveWrapper(unique_id, e, manual_close);
          }, 300);
        } else {
          this._countRemoveWrapper(unique_id, e);
        }
      },
      /**
      * Remove a specific notification based on an ID
      * @param {Integer} unique_id The ID used to delete a specific notification
      * @param {Object} params A set of options passed in to determine how to get rid of it
      * @param {Object} e The jQuery element that we're "fading" then removing
      * @param {Boolean} unbind_events If we clicked on the (X) we set this to true to unbind mouseenter/mouseleave
      */
      removeSpecific: function(unique_id, params, e, unbind_events) {
        if (!e) {
          var e = $2("#gritter-item-" + unique_id);
        }
        this._fade(e, unique_id, params || {}, unbind_events);
      },
      /**
      * If the item is fading out and we hover over it, restore it!
      * @private
      * @param {Object} e The HTML element to remove
      * @param {Integer} unique_id The ID of the element
      */
      _restoreItemIfFading: function(e, unique_id) {
        clearTimeout(this["_int_id_" + unique_id]);
        e.stop().css({ opacity: "", height: "" });
      },
      /**
      * Setup the global options - only once
      * @private
      */
      _runSetup: function() {
        for (opt in $2.gritter.options) {
          this[opt] = $2.gritter.options[opt];
        }
        this._is_setup = 1;
      },
      /**
      * Set the notification to fade out after a certain amount of time
      * @private
      * @param {Object} item The HTML element we're dealing with
      * @param {Integer} unique_id The ID of the element
      */
      _setFadeTimer: function(item, unique_id) {
        var timer_str = this._custom_timer ? this._custom_timer : this.time;
        this["_int_id_" + unique_id] = setTimeout(function() {
          Gritter._fade(item, unique_id);
        }, timer_str);
      },
      /**
      * Bring everything to a halt
      * @param {Object} params A list of callback functions to pass when all notifications are removed
      */
      stop: function(params) {
        var before_close = $2.isFunction(params.before_close) ? params.before_close : function() {
        };
        var after_close = $2.isFunction(params.after_close) ? params.after_close : function() {
        };
        var wrap2 = $2("#gritter-container");
        before_close(wrap2);
        wrap2.fadeOut(function() {
          $2(this).remove();
          after_close();
        });
      },
      /**
      * A check to make sure we have something to wrap our notices with
      * @private
      */
      _verifyWrapper: function() {
        if ($2("#gritter-container.top").length === 0) {
          $2("#editorcontainerbox").append(this._tpl_wrap_top);
        }
        if ($2("#gritter-container.bottom").length === 0) {
          $2("#editorcontainerbox").append(this._tpl_wrap_bottom);
        }
      }
    };
  })(jQuery2);
  return gritter;
}
var pad_utils = {};
var security$1 = {};
/*!

  Copyright (c) 2011 Chad Weider

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/
var hasRequiredSecurity$1;
function requireSecurity$1() {
  if (hasRequiredSecurity$1)
    return security$1;
  hasRequiredSecurity$1 = 1;
  var HTML_ENTITY_MAP = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "/": "&#x2F;"
  };
  var HTML_CHARACTERS_EXPRESSION = /[&"'<>\/]/gm;
  function escapeHTML(text) {
    return text && text.replace(HTML_CHARACTERS_EXPRESSION, function(c) {
      return HTML_ENTITY_MAP[c] || c;
    });
  }
  var HTML_ATTRIBUTE_CHARACTERS_EXPRESSION = /[\x00-\x2F\x3A-\x40\x5B-\x60\x7B-\xFF]/gm;
  function escapeHTMLAttribute(text) {
    return text && text.replace(HTML_ATTRIBUTE_CHARACTERS_EXPRESSION, function(c) {
      return HTML_ENTITY_MAP[c] || "&#x" + ("00" + c.charCodeAt(0).toString(16)).slice(-2) + ";";
    });
  }
  var JAVASCRIPT_CHARACTERS_EXPRESSION = /[\x00-\x2F\x3A-\x40\x5B-\x60\x7B-\xFF\u2028\u2029]/gm;
  function encodeJavaScriptIdentifier(text) {
    return text && text.replace(JAVASCRIPT_CHARACTERS_EXPRESSION, function(c) {
      return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    });
  }
  function encodeJavaScriptString(text) {
    return text && '"' + encodeJavaScriptIdentifier(text) + '"';
  }
  var JSON_STRING_LITERAL_EXPRESSION = /"(?:\\.|[^"])*"/gm;
  function encodeJavaScriptData(object2) {
    return JSON.stringify(object2).replace(JSON_STRING_LITERAL_EXPRESSION, function(string) {
      return encodeJavaScriptString(JSON.parse(string));
    });
  }
  var CSS_CHARACTERS_EXPRESSION = /[\x00-\x2F\x3A-\x40\x5B-\x60\x7B-\xFF]/gm;
  function encodeCSSIdentifier(text) {
    return text && text.replace(CSS_CHARACTERS_EXPRESSION, function(c) {
      return "\\" + ("000000" + c.charCodeAt(0).toString(16)).slice(-6);
    });
  }
  function encodeCSSString(text) {
    return text && '"' + encodeCSSIdentifier(text) + '"';
  }
  security$1.escapeHTML = escapeHTML;
  security$1.escapeHTMLAttribute = escapeHTMLAttribute;
  security$1.encodeJavaScriptIdentifier = encodeJavaScriptIdentifier;
  security$1.encodeJavaScriptString = encodeJavaScriptString;
  security$1.encodeJavaScriptData = encodeJavaScriptData;
  security$1.encodeCSSIdentifier = encodeCSSIdentifier;
  security$1.encodeCSSString = encodeCSSString;
  return security$1;
}
var security;
var hasRequiredSecurity;
function requireSecurity() {
  if (hasRequiredSecurity)
    return security;
  hasRequiredSecurity = 1;
  security = requireSecurity$1();
  return security;
}
var ace2_common = {};
var hasRequiredAce2_common;
function requireAce2_common() {
  if (hasRequiredAce2_common)
    return ace2_common;
  hasRequiredAce2_common = 1;
  const isNodeText = (node) => node.nodeType === 3;
  const getAssoc = (obj, name) => obj[`_magicdom_${name}`];
  const setAssoc = (obj, name, value) => {
    obj[`_magicdom_${name}`] = value;
  };
  const binarySearch = (numItems, func) => {
    if (numItems < 1)
      return 0;
    if (func(0))
      return 0;
    if (!func(numItems - 1))
      return numItems;
    let low = 0;
    let high = numItems - 1;
    while (high - low > 1) {
      const x = Math.floor((low + high) / 2);
      if (func(x))
        high = x;
      else
        low = x;
    }
    return high;
  };
  const binarySearchInfinite = (expectedLength, func) => {
    let i = 0;
    while (!func(i))
      i += expectedLength;
    return binarySearch(i, func);
  };
  const noop2 = () => {
  };
  ace2_common.isNodeText = isNodeText;
  ace2_common.getAssoc = getAssoc;
  ace2_common.setAssoc = setAssoc;
  ace2_common.binarySearch = binarySearch;
  ace2_common.binarySearchInfinite = binarySearchInfinite;
  ace2_common.noop = noop2;
  return ace2_common;
}
var js_cookie = { exports: {} };
/*! js-cookie v3.0.5 | MIT */
var hasRequiredJs_cookie;
function requireJs_cookie() {
  if (hasRequiredJs_cookie)
    return js_cookie.exports;
  hasRequiredJs_cookie = 1;
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            target[key] = source[key];
          }
        }
        return target;
      }
      var defaultConverter = {
        read: function(value) {
          if (value[0] === '"') {
            value = value.slice(1, -1);
          }
          return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        },
        write: function(value) {
          return encodeURIComponent(value).replace(
            /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
            decodeURIComponent
          );
        }
      };
      function init(converter, defaultAttributes) {
        function set(name, value, attributes2) {
          if (typeof document === "undefined") {
            return;
          }
          attributes2 = assign({}, defaultAttributes, attributes2);
          if (typeof attributes2.expires === "number") {
            attributes2.expires = new Date(Date.now() + attributes2.expires * 864e5);
          }
          if (attributes2.expires) {
            attributes2.expires = attributes2.expires.toUTCString();
          }
          name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes2) {
            if (!attributes2[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes2[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes2[attributeName].split(";")[0];
          }
          return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
        }
        function get2(name) {
          if (typeof document === "undefined" || arguments.length && !name) {
            return;
          }
          var cookies = document.cookie ? document.cookie.split("; ") : [];
          var jar = {};
          for (var i = 0; i < cookies.length; i++) {
            var parts = cookies[i].split("=");
            var value = parts.slice(1).join("=");
            try {
              var found = decodeURIComponent(parts[0]);
              jar[found] = converter.read(value, found);
              if (name === found) {
                break;
              }
            } catch (e) {
            }
          }
          return name ? jar[name] : jar;
        }
        return Object.create(
          {
            set,
            get: get2,
            remove: function(name, attributes2) {
              set(
                name,
                "",
                assign({}, attributes2, {
                  expires: -1
                })
              );
            },
            withAttributes: function(attributes2) {
              return init(this.converter, assign({}, this.attributes, attributes2));
            },
            withConverter: function(converter2) {
              return init(assign({}, this.converter, converter2), this.attributes);
            }
          },
          {
            attributes: { value: Object.freeze(defaultAttributes) },
            converter: { value: Object.freeze(converter) }
          }
        );
      }
      var api = init(defaultConverter, { path: "/" });
      return api;
    });
  })(js_cookie);
  return js_cookie.exports;
}
var hasRequiredPad_utils;
function requirePad_utils() {
  if (hasRequiredPad_utils)
    return pad_utils;
  hasRequiredPad_utils = 1;
  const Security = requireSecurity();
  const randomString = (len) => {
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    let randomstring = "";
    len = len || 20;
    for (let i = 0; i < len; i++) {
      const rnum = Math.floor(Math.random() * chars.length);
      randomstring += chars.substring(rnum, rnum + 1);
    }
    return randomstring;
  };
  const wordCharRegex = new RegExp(`[${[
    "0-9",
    "A-Z",
    "a-z",
    "Ã-Ã",
    "Ã-Ã¶",
    "Ã¸-Ã¿",
    "Ä-á¿¿",
    "ã-é¿¿",
    "ï¤-ï·¿",
    "ï¹°-ï»¾",
    "ï¼-ï¼",
    "ï¼¡-ï¼º",
    "ï½-ï½",
    "ï½¦-ï¿"
  ].join("")}]`);
  const urlRegex = (() => {
    const urlChar = `[-:@_.,~%+/?=&#!;()\\[\\]$'*${wordCharRegex.source.slice(1, -1)}]`;
    const postUrlPunct = "[:.,;?!)\\]'*]";
    const withAuth = `(?:${[
      "(?:x-)?man",
      "afp",
      "file",
      "ftps?",
      "gopher",
      "https?",
      "nfs",
      "sftp",
      "smb",
      "txmt"
    ].join("|")})://`;
    const withoutAuth = `(?:${[
      "about",
      "geo",
      "mailto",
      "tel"
    ].join("|")}):`;
    return new RegExp(
      `(?:${withAuth}|${withoutAuth}|www\\.)${urlChar}*(?!${postUrlPunct})${urlChar}`,
      "g"
    );
  })();
  const base64url = /^(?=(?:.{4})*$)[A-Za-z0-9_-]*(?:[AQgw]==|[AEIMQUYcgkosw048]=)?$/;
  const padutils = {
    /**
     * Prints a warning message followed by a stack trace (to make it easier to figure out what code
     * is using the deprecated function).
     *
     * Identical deprecation warnings (as determined by the stack trace, if available) are rate
     * limited to avoid log spam.
     *
     * Most browsers include UI widget to examine the stack at the time of the warning, but this
     * includes the stack in the log message for a couple of reasons:
     *   - This makes it possible to see the stack if the code runs in Node.js.
     *   - Users are more likely to paste the stack in bug reports they might file.
     *
     * @param {...*} args - Passed to `padutils.warnDeprecated.logger.warn` (or `console.warn` if no
     *     logger is set), with a stack trace appended if available.
     */
    warnDeprecated: (...args) => {
      if (padutils.warnDeprecated.disabledForTestingOnly)
        return;
      const err = new Error();
      if (Error.captureStackTrace)
        Error.captureStackTrace(err, padutils.warnDeprecated);
      err.name = "";
      if (typeof err.stack === "string") {
        if (padutils.warnDeprecated._rl == null) {
          padutils.warnDeprecated._rl = { prevs: /* @__PURE__ */ new Map(), now: () => Date.now(), period: 10 * 60 * 1e3 };
        }
        const rl = padutils.warnDeprecated._rl;
        const now2 = rl.now();
        const prev = rl.prevs.get(err.stack);
        if (prev != null && now2 - prev < rl.period)
          return;
        rl.prevs.set(err.stack, now2);
      }
      if (err.stack)
        args.push(err.stack);
      (padutils.warnDeprecated.logger || console).warn(...args);
    },
    escapeHtml: (x) => Security.escapeHTML(String(x)),
    uniqueId: () => {
      const pad2 = requirePad().pad;
      const encodeNum = (n, width) => (Array(width + 1).join("0") + Number(n).toString(35)).slice(-width);
      return [
        pad2.getClientIp(),
        encodeNum(+/* @__PURE__ */ new Date(), 7),
        encodeNum(Math.floor(Math.random() * 1e9), 4)
      ].join(".");
    },
    // e.g. "Thu Jun 18 2009 13:09"
    simpleDateTime: (date) => {
      const d = /* @__PURE__ */ new Date(+date);
      const dayOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][d.getDay()];
      const month = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ][d.getMonth()];
      const dayOfMonth = d.getDate();
      const year = d.getFullYear();
      const hourmin = `${d.getHours()}:${`0${d.getMinutes()}`.slice(-2)}`;
      return `${dayOfWeek} ${month} ${dayOfMonth} ${year} ${hourmin}`;
    },
    wordCharRegex,
    urlRegex,
    // returns null if no URLs, or [[startIndex1, url1], [startIndex2, url2], ...]
    findURLs: (text) => {
      const urlRegex2 = new RegExp(padutils.urlRegex, "g");
      urlRegex2.lastIndex = 0;
      let urls = null;
      let execResult;
      while (execResult = urlRegex2.exec(text)) {
        urls = urls || [];
        const startIndex = execResult.index;
        const url2 = execResult[0];
        urls.push([startIndex, url2]);
      }
      return urls;
    },
    escapeHtmlWithClickableLinks: (text, target) => {
      let idx = 0;
      const pieces = [];
      const urls = padutils.findURLs(text);
      const advanceTo = (i) => {
        if (i > idx) {
          pieces.push(Security.escapeHTML(text.substring(idx, i)));
          idx = i;
        }
      };
      if (urls) {
        for (let j = 0; j < urls.length; j++) {
          const startIndex = urls[j][0];
          const href = urls[j][1];
          advanceTo(startIndex);
          pieces.push(
            "<a ",
            target ? `target="${Security.escapeHTMLAttribute(target)}" ` : "",
            'href="',
            Security.escapeHTMLAttribute(href),
            '" rel="noreferrer noopener">'
          );
          advanceTo(startIndex + href.length);
          pieces.push("</a>");
        }
      }
      advanceTo(text.length);
      return pieces.join("");
    },
    bindEnterAndEscape: (node, onEnter, onEscape) => {
      if (onEnter) {
        node.on("keypress", (evt) => {
          if (evt.which === 13) {
            onEnter(evt);
          }
        });
      }
      if (onEscape) {
        node.on("keydown", (evt) => {
          if (evt.which === 27) {
            onEscape(evt);
          }
        });
      }
    },
    timediff: (d) => {
      const pad2 = requirePad().pad;
      const format = (n, word) => {
        n = Math.round(n);
        return `${n} ${word}${n !== 1 ? "s" : ""} ago`;
      };
      d = Math.max(0, (+/* @__PURE__ */ new Date() - +d - pad2.clientTimeOffset) / 1e3);
      if (d < 60) {
        return format(d, "second");
      }
      d /= 60;
      if (d < 60) {
        return format(d, "minute");
      }
      d /= 60;
      if (d < 24) {
        return format(d, "hour");
      }
      d /= 24;
      return format(d, "day");
    },
    makeAnimationScheduler: (funcToAnimateOneStep, stepTime, stepsAtOnce) => {
      if (stepsAtOnce === void 0) {
        stepsAtOnce = 1;
      }
      let animationTimer = null;
      const scheduleAnimation = () => {
        if (!animationTimer) {
          animationTimer = window.setTimeout(() => {
            animationTimer = null;
            let n = stepsAtOnce;
            let moreToDo = true;
            while (moreToDo && n > 0) {
              moreToDo = funcToAnimateOneStep();
              n--;
            }
            if (moreToDo) {
              scheduleAnimation();
            }
          }, stepTime * stepsAtOnce);
        }
      };
      return { scheduleAnimation };
    },
    makeFieldLabeledWhenEmpty: (field, labelText) => {
      field = $(field);
      const clear = () => {
        field.addClass("editempty");
        field.val(labelText);
      };
      field.focus(() => {
        if (field.hasClass("editempty")) {
          field.val("");
        }
        field.removeClass("editempty");
      });
      field.on("blur", () => {
        if (!field.val()) {
          clear();
        }
      });
      return {
        clear
      };
    },
    getCheckbox: (node) => $(node).is(":checked"),
    setCheckbox: (node, value) => {
      if (value) {
        $(node).attr("checked", "checked");
      } else {
        $(node).prop("checked", false);
      }
    },
    bindCheckboxChange: (node, func) => {
      $(node).on("change", func);
    },
    encodeUserId: (userId) => userId.replace(/[^a-y0-9]/g, (c) => {
      if (c === ".")
        return "-";
      return `z${c.charCodeAt(0)}z`;
    }),
    decodeUserId: (encodedUserId) => encodedUserId.replace(/[a-y0-9]+|-|z.+?z/g, (cc) => {
      if (cc === "-") {
        return ".";
      } else if (cc.charAt(0) === "z") {
        return String.fromCharCode(Number(cc.slice(1, -1)));
      } else {
        return cc;
      }
    }),
    /**
     * Returns whether a string has the expected format to be used as a secret token identifying an
     * author. The format is defined as: 't.' followed by a non-empty base64url string (RFC 4648
     * section 5 with padding).
     *
     * Being strict about what constitutes a valid token enables unambiguous extensibility (e.g.,
     * conditional transformation of a token to a database key in a way that does not allow a
     * malicious user to impersonate another user).
     */
    isValidAuthorToken: (t) => {
      if (typeof t !== "string" || !t.startsWith("t."))
        return false;
      const v = t.slice(2);
      return v.length > 0 && base64url.test(v);
    },
    /**
     * Returns a string that can be used in the `token` cookie as a secret that authenticates a
     * particular author.
     */
    generateAuthorToken: () => `t.${randomString()}`
  };
  let globalExceptionHandler = null;
  padutils.setupGlobalExceptionHandler = () => {
    if (globalExceptionHandler == null) {
      requireGritter();
      globalExceptionHandler = (e) => {
        let type;
        let err;
        let msg, url2, linenumber;
        if (e instanceof ErrorEvent) {
          type = "Uncaught exception";
          err = e.error || {};
          ({ message: msg, filename: url2, lineno: linenumber } = e);
        } else if (e instanceof PromiseRejectionEvent) {
          type = "Unhandled Promise rejection";
          err = e.reason || {};
          ({ message: msg = "unknown", fileName: url2 = "unknown", lineNumber: linenumber = -1 } = err);
        } else {
          throw new Error(`unknown event: ${e.toString()}`);
        }
        if (err.name != null && msg !== err.name && !msg.startsWith(`${err.name}: `)) {
          msg = `${err.name}: ${msg}`;
        }
        const errorId = randomString(20);
        let msgAlreadyVisible = false;
        $(".gritter-item .error-msg").each(function() {
          if ($(this).text() === msg) {
            msgAlreadyVisible = true;
          }
        });
        if (!msgAlreadyVisible) {
          const txt = document.createTextNode.bind(document);
          const errorMsg = [
            $("<p>").append($("<b>").text("Please press and hold Ctrl and press F5 to reload this page")),
            $("<p>").text("If the problem persists, please send this error message to your webmaster:"),
            $("<div>").css("text-align", "left").css("font-size", ".8em").css("margin-top", "1em").append($("<b>").addClass("error-msg").text(msg)).append($("<br>")).append(txt(`at ${url2} at line ${linenumber}`)).append($("<br>")).append(txt(`ErrorId: ${errorId}`)).append($("<br>")).append(txt(type)).append($("<br>")).append(txt(`URL: ${window.location.href}`)).append($("<br>")).append(txt(`UserAgent: ${navigator.userAgent}`)).append($("<br>"))
          ];
          $.gritter.add({
            title: "An error occurred",
            text: errorMsg,
            class_name: "error",
            position: "bottom",
            sticky: true
          });
        }
        $.post("../jserror", {
          errorInfo: JSON.stringify({
            errorId,
            type,
            msg,
            url: window.location.href,
            source: url2,
            linenumber,
            userAgent: navigator.userAgent,
            stack: err.stack
          })
        });
      };
      window.onerror = null;
      window.addEventListener("error", globalExceptionHandler);
      window.addEventListener("unhandledrejection", globalExceptionHandler);
    }
  };
  padutils.binarySearch = requireAce2_common().binarySearch;
  const inThirdPartyIframe = () => {
    try {
      return !window.top.location.hostname;
    } catch (e) {
      return true;
    }
  };
  if (typeof window !== "undefined") {
    pad_utils.Cookies = requireJs_cookie().withAttributes({
      // Use `SameSite=Lax`, unless Etherpad is embedded in an iframe from another site in which case
      // use `SameSite=None`. For iframes from another site, only `None` has a chance of working
      // because the cookies are third-party (not same-site). Many browsers/users block third-party
      // cookies, but maybe blocked is better than definitely blocked (which would happen with `Lax`
      // or `Strict`). Note: `None` will not work unless secure is true.
      //
      // `Strict` is not used because it has few security benefits but significant usability drawbacks
      // vs. `Lax`. See https://stackoverflow.com/q/41841880 for discussion.
      sameSite: inThirdPartyIframe() ? "None" : "Lax",
      secure: window.location.protocol === "https:"
    });
  }
  pad_utils.randomString = randomString;
  pad_utils.padutils = padutils;
  return pad_utils;
}
var chat = {};
var ChatMessage_1;
var hasRequiredChatMessage;
function requireChatMessage() {
  if (hasRequiredChatMessage)
    return ChatMessage_1;
  hasRequiredChatMessage = 1;
  const { padutils: { warnDeprecated } } = requirePad_utils();
  class ChatMessage {
    static fromObject(obj) {
      obj = Object.assign({}, obj);
      if ("userId" in obj && !("authorId" in obj))
        obj.authorId = obj.userId;
      delete obj.userId;
      if ("userName" in obj && !("displayName" in obj))
        obj.displayName = obj.userName;
      delete obj.userName;
      return Object.assign(new ChatMessage(), obj);
    }
    /**
     * @param {?string} [text] - Initial value of the `text` property.
     * @param {?string} [authorId] - Initial value of the `authorId` property.
     * @param {?number} [time] - Initial value of the `time` property.
     */
    constructor(text = null, authorId = null, time = null) {
      this.text = text;
      this.authorId = authorId;
      this.time = time;
      this.displayName = null;
    }
    /**
     * Alias of `authorId`, for compatibility with old plugins.
     *
     * @deprecated Use `authorId` instead.
     * @type {string}
     */
    get userId() {
      warnDeprecated("ChatMessage.userId property is deprecated; use .authorId instead");
      return this.authorId;
    }
    set userId(val) {
      warnDeprecated("ChatMessage.userId property is deprecated; use .authorId instead");
      this.authorId = val;
    }
    /**
     * Alias of `displayName`, for compatibility with old plugins.
     *
     * @deprecated Use `displayName` instead.
     * @type {string}
     */
    get userName() {
      warnDeprecated("ChatMessage.userName property is deprecated; use .displayName instead");
      return this.displayName;
    }
    set userName(val) {
      warnDeprecated("ChatMessage.userName property is deprecated; use .displayName instead");
      this.displayName = val;
    }
    // TODO: Delete this method once users are unlikely to roll back to a version of Etherpad that
    // doesn't support authorId and displayName.
    toJSON() {
      const { authorId, displayName, ...obj } = this;
      obj.userId = authorId;
      obj.userName = displayName;
      return obj;
    }
  }
  ChatMessage_1 = ChatMessage;
  return ChatMessage_1;
}
var pad_cookie = {};
var hasRequiredPad_cookie;
function requirePad_cookie() {
  if (hasRequiredPad_cookie)
    return pad_cookie;
  hasRequiredPad_cookie = 1;
  const Cookies = requirePad_utils().Cookies;
  pad_cookie.padcookie = new class {
    constructor() {
      this.cookieName_ = window.location.protocol === "https:" ? "prefs" : "prefsHttp";
    }
    init() {
      const prefs = this.readPrefs_() || {};
      delete prefs.userId;
      delete prefs.name;
      delete prefs.colorId;
      this.writePrefs_(prefs);
      if (this.readPrefs_() == null) {
        $.gritter.add({
          title: "Error",
          text: html10n.get("pad.noCookie"),
          sticky: true,
          class_name: "error"
        });
      }
    }
    readPrefs_() {
      try {
        const json = Cookies.get(this.cookieName_);
        if (json == null)
          return null;
        return JSON.parse(json);
      } catch (e) {
        return null;
      }
    }
    writePrefs_(prefs) {
      Cookies.set(this.cookieName_, JSON.stringify(prefs), { expires: 365 * 100 });
    }
    getPref(prefName) {
      return this.readPrefs_()[prefName];
    }
    setPref(prefName, value) {
      const prefs = this.readPrefs_();
      prefs[prefName] = value;
      this.writePrefs_(prefs);
    }
    clear() {
      this.writePrefs_({});
    }
  }();
  return pad_cookie;
}
var tinycon = { exports: {} };
/*!
 * Tinycon - A small library for manipulating the Favicon
 * Tom Moor, http://tommoor.com
 * Copyright (c) 2015 Tom Moor
 * @license MIT Licensed
 */
var hasRequiredTinycon;
function requireTinycon() {
  if (hasRequiredTinycon)
    return tinycon.exports;
  hasRequiredTinycon = 1;
  (function(module) {
    (function() {
      var Tinycon = {};
      var currentFavicon = null;
      var originalFavicon = null;
      var faviconImage = null;
      var canvas = null;
      var options = {};
      var r = Math.ceil(window.devicePixelRatio) || 1;
      var size2 = 16 * r;
      var defaults2 = {
        width: 7,
        height: 9,
        font: 10 * r + "px arial",
        color: "#ffffff",
        background: "#F03D25",
        fallback: true,
        crossOrigin: true,
        abbreviate: true
      };
      var ua = function() {
        var agent = navigator.userAgent.toLowerCase();
        return function(browser3) {
          return agent.indexOf(browser3) !== -1;
        };
      }();
      var browser2 = {
        ie: ua("trident"),
        chrome: ua("chrome"),
        webkit: ua("chrome") || ua("safari"),
        safari: ua("safari") && !ua("chrome"),
        mozilla: ua("mozilla") && !ua("chrome") && !ua("safari")
      };
      var getFaviconTag = function() {
        var links = document.getElementsByTagName("link");
        for (var i = 0, len = links.length; i < len; i++) {
          if ((links[i].getAttribute("rel") || "").match(/\bicon\b/i)) {
            return links[i];
          }
        }
        return false;
      };
      var removeFaviconTag = function() {
        var links = document.getElementsByTagName("link");
        for (var i = 0, len = links.length; i < len; i++) {
          var exists = typeof links[i] !== "undefined";
          if (exists && (links[i].getAttribute("rel") || "").match(/\bicon\b/i)) {
            links[i].parentNode.removeChild(links[i]);
          }
        }
      };
      var getCurrentFavicon = function() {
        if (!originalFavicon || !currentFavicon) {
          var tag = getFaviconTag();
          currentFavicon = tag ? tag.getAttribute("href") : "/favicon.ico";
          if (!originalFavicon) {
            originalFavicon = currentFavicon;
          }
        }
        return currentFavicon;
      };
      var getCanvas = function() {
        if (!canvas) {
          canvas = document.createElement("canvas");
          canvas.width = size2;
          canvas.height = size2;
        }
        return canvas;
      };
      var setFaviconTag = function(url2) {
        if (url2) {
          removeFaviconTag();
          var link = document.createElement("link");
          link.type = "image/x-icon";
          link.rel = "icon";
          link.href = url2;
          document.getElementsByTagName("head")[0].appendChild(link);
        }
      };
      var drawFavicon = function(label, color) {
        if (!getCanvas().getContext || browser2.ie || browser2.safari || options.fallback === "force") {
          return updateTitle(label);
        }
        var context = getCanvas().getContext("2d");
        var src = getCurrentFavicon();
        faviconImage = document.createElement("img");
        faviconImage.onload = function() {
          context.clearRect(0, 0, size2, size2);
          context.drawImage(faviconImage, 0, 0, faviconImage.width, faviconImage.height, 0, 0, size2, size2);
          if ((label + "").length > 0)
            drawBubble(context, label);
          refreshFavicon();
        };
        if (!src.match(/^data/) && options.crossOrigin) {
          faviconImage.crossOrigin = "anonymous";
        }
        faviconImage.src = src;
      };
      var updateTitle = function(label) {
        if (options.fallback) {
          var originalTitle = document.title;
          if (originalTitle[0] === "(") {
            originalTitle = originalTitle.slice(originalTitle.indexOf(" "));
          }
          if ((label + "").length > 0) {
            document.title = "(" + label + ") " + originalTitle;
          } else {
            document.title = originalTitle;
          }
        }
      };
      var drawBubble = function(context, label, color) {
        if (typeof label == "number" && label > 99 && options.abbreviate) {
          label = abbreviateNumber(label);
        }
        var len = (label + "").length - 1;
        var width = options.width * r + 6 * r * len, height = options.height * r;
        var top = size2 - height, left = size2 - width - r, bottom = 16 * r, right = 16 * r, radius = 2 * r;
        context.font = (browser2.webkit ? "bold " : "") + options.font;
        context.fillStyle = options.background;
        context.strokeStyle = options.background;
        context.lineWidth = r;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.quadraticCurveTo(left, top, left, top + radius);
        context.lineTo(left, bottom - radius);
        context.quadraticCurveTo(left, bottom, left + radius, bottom);
        context.lineTo(right - radius, bottom);
        context.quadraticCurveTo(right, bottom, right, bottom - radius);
        context.lineTo(right, top + radius);
        context.quadraticCurveTo(right, top, right - radius, top);
        context.closePath();
        context.fill();
        context.beginPath();
        context.strokeStyle = "rgba(0,0,0,0.3)";
        context.moveTo(left + radius / 2, bottom);
        context.lineTo(right - radius / 2, bottom);
        context.stroke();
        context.fillStyle = options.color;
        context.textAlign = "right";
        context.textBaseline = "top";
        context.fillText(label, r === 2 ? 29 : 15, browser2.mozilla ? 7 * r : 6 * r);
      };
      var refreshFavicon = function() {
        if (!getCanvas().getContext)
          return;
        setFaviconTag(getCanvas().toDataURL());
      };
      var abbreviateNumber = function(label) {
        var metricPrefixes = [
          ["G", 1e9],
          ["M", 1e6],
          ["k", 1e3]
        ];
        for (var i = 0; i < metricPrefixes.length; ++i) {
          if (label >= metricPrefixes[i][1]) {
            label = round(label / metricPrefixes[i][1]) + metricPrefixes[i][0];
            break;
          }
        }
        return label;
      };
      var round = function(value, precision) {
        var number = new Number(value);
        return number.toFixed(precision);
      };
      Tinycon.setOptions = function(custom) {
        options = {};
        if (custom.colour) {
          custom.color = custom.colour;
        }
        for (var key in defaults2) {
          options[key] = custom.hasOwnProperty(key) ? custom[key] : defaults2[key];
        }
        return this;
      };
      Tinycon.setImage = function(url2) {
        currentFavicon = url2;
        refreshFavicon();
        return this;
      };
      Tinycon.setBubble = function(label, color) {
        label = label || "";
        drawFavicon(label);
        return this;
      };
      Tinycon.reset = function() {
        currentFavicon = originalFavicon;
        setFaviconTag(originalFavicon);
      };
      Tinycon.setOptions(defaults2);
      {
        module.exports = Tinycon;
      }
    })();
  })(tinycon);
  return tinycon.exports;
}
var pad_editor = {};
var ace = {};
var cssmanager = {};
var hasRequiredCssmanager;
function requireCssmanager() {
  if (hasRequiredCssmanager)
    return cssmanager;
  hasRequiredCssmanager = 1;
  cssmanager.makeCSSManager = (browserSheet) => {
    const browserRules = () => browserSheet.cssRules || browserSheet.rules;
    const browserDeleteRule = (i) => {
      if (browserSheet.deleteRule)
        browserSheet.deleteRule(i);
      else
        browserSheet.removeRule(i);
    };
    const browserInsertRule = (i, selector) => {
      if (browserSheet.insertRule)
        browserSheet.insertRule(`${selector} {}`, i);
      else
        browserSheet.addRule(selector, null, i);
    };
    const selectorList = [];
    const indexOfSelector = (selector) => {
      for (let i = 0; i < selectorList.length; i++) {
        if (selectorList[i] === selector) {
          return i;
        }
      }
      return -1;
    };
    const selectorStyle = (selector) => {
      let i = indexOfSelector(selector);
      if (i < 0) {
        browserInsertRule(0, selector);
        selectorList.splice(0, 0, selector);
        i = 0;
      }
      return browserRules().item(i).style;
    };
    const removeSelectorStyle = (selector) => {
      const i = indexOfSelector(selector);
      if (i >= 0) {
        browserDeleteRule(i);
        selectorList.splice(i, 1);
      }
    };
    return {
      selectorStyle,
      removeSelectorStyle,
      info: () => `${selectorList.length}:${browserRules().length}`
    };
  };
  return cssmanager;
}
var ace2_inner = {};
var attributes = {};
var hasRequiredAttributes;
function requireAttributes() {
  if (hasRequiredAttributes)
    return attributes;
  hasRequiredAttributes = 1;
  (function(exports) {
    exports.decodeAttribString = function* (str) {
      const re = /\*([0-9a-z]+)|./gy;
      let match;
      while ((match = re.exec(str)) != null) {
        const [m, n] = match;
        if (n == null)
          throw new Error(`invalid character in attribute string: ${m}`);
        yield Number.parseInt(n, 36);
      }
    };
    const checkAttribNum = (n) => {
      if (typeof n !== "number")
        throw new TypeError(`not a number: ${n}`);
      if (n < 0)
        throw new Error(`attribute number is negative: ${n}`);
      if (n !== Math.trunc(n))
        throw new Error(`attribute number is not an integer: ${n}`);
    };
    exports.encodeAttribString = (attribNums) => {
      let str = "";
      for (const n of attribNums) {
        checkAttribNum(n);
        str += `*${n.toString(36).toLowerCase()}`;
      }
      return str;
    };
    exports.attribsFromNums = function* (attribNums, pool) {
      for (const n of attribNums) {
        checkAttribNum(n);
        const attrib = pool.getAttrib(n);
        if (attrib == null)
          throw new Error(`attribute ${n} does not exist in pool`);
        yield attrib;
      }
    };
    exports.attribsToNums = function* (attribs, pool) {
      for (const attrib of attribs)
        yield pool.putAttrib(attrib);
    };
    exports.attribsFromString = function* (str, pool) {
      yield* exports.attribsFromNums(exports.decodeAttribString(str), pool);
    };
    exports.attribsToString = (attribs, pool) => exports.encodeAttribString(exports.attribsToNums(attribs, pool));
    exports.sort = (attribs) => attribs.sort(([keyA], [keyB]) => (keyA > keyB ? 1 : 0) - (keyA < keyB ? 1 : 0));
  })(attributes);
  return attributes;
}
var AttributeMap_1;
var hasRequiredAttributeMap;
function requireAttributeMap() {
  if (hasRequiredAttributeMap)
    return AttributeMap_1;
  hasRequiredAttributeMap = 1;
  const attributes2 = requireAttributes();
  class AttributeMap extends Map {
    /**
     * Converts an attribute string into an AttributeMap.
     *
     * @param {AttributeString} str - The attribute string to convert into an AttributeMap.
     * @param {AttributePool} pool - Attribute pool.
     * @returns {AttributeMap}
     */
    static fromString(str, pool) {
      return new AttributeMap(pool).updateFromString(str);
    }
    /**
     * @param {AttributePool} pool - Attribute pool.
     */
    constructor(pool) {
      super();
      this.pool = pool;
    }
    /**
     * @param {string} k - Attribute name.
     * @param {string} v - Attribute value.
     * @returns {AttributeMap} `this` (for chaining).
     */
    set(k, v) {
      k = k == null ? "" : String(k);
      v = v == null ? "" : String(v);
      this.pool.putAttrib([k, v]);
      return super.set(k, v);
    }
    toString() {
      return attributes2.attribsToString(attributes2.sort([...this]), this.pool);
    }
    /**
     * @param {Iterable<Attribute>} entries - [key, value] pairs to insert into this map.
     * @param {boolean} [emptyValueIsDelete] - If true and an entry's value is the empty string, the
     *     key is removed from this map (if present).
     * @returns {AttributeMap} `this` (for chaining).
     */
    update(entries, emptyValueIsDelete = false) {
      for (let [k, v] of entries) {
        k = k == null ? "" : String(k);
        v = v == null ? "" : String(v);
        if (!v && emptyValueIsDelete) {
          this.delete(k);
        } else {
          this.set(k, v);
        }
      }
      return this;
    }
    /**
     * @param {AttributeString} str - The attribute string identifying the attributes to insert into
     *     this map.
     * @param {boolean} [emptyValueIsDelete] - If true and an entry's value is the empty string, the
     *     key is removed from this map (if present).
     * @returns {AttributeMap} `this` (for chaining).
     */
    updateFromString(str, emptyValueIsDelete = false) {
      return this.update(attributes2.attribsFromString(str, this.pool), emptyValueIsDelete);
    }
  }
  AttributeMap_1 = AttributeMap;
  return AttributeMap_1;
}
var changesettracker = {};
var AttributePool_1;
var hasRequiredAttributePool;
function requireAttributePool() {
  if (hasRequiredAttributePool)
    return AttributePool_1;
  hasRequiredAttributePool = 1;
  class AttributePool {
    constructor() {
      this.numToAttrib = {};
      this.attribToNum = {};
      this.nextNum = 0;
    }
    /**
     * @returns {AttributePool} A deep copy of this attribute pool.
     */
    clone() {
      const c = new AttributePool();
      for (const [n, a] of Object.entries(this.numToAttrib))
        c.numToAttrib[n] = [a[0], a[1]];
      Object.assign(c.attribToNum, this.attribToNum);
      c.nextNum = this.nextNum;
      return c;
    }
    /**
     * Add an attribute to the attribute set, or query for an existing attribute identifier.
     *
     * @param {Attribute} attrib - The attribute's `[key, value]` pair of strings.
     * @param {boolean} [dontAddIfAbsent=false] - If true, do not insert the attribute into the pool
     *     if the attribute does not already exist in the pool. This can be used to test for
     *     membership in the pool without mutating the pool.
     * @returns {number} The attribute's identifier, or -1 if the attribute is not in the pool.
     */
    putAttrib(attrib, dontAddIfAbsent = false) {
      const str = String(attrib);
      if (str in this.attribToNum) {
        return this.attribToNum[str];
      }
      if (dontAddIfAbsent) {
        return -1;
      }
      const num = this.nextNum++;
      this.attribToNum[str] = num;
      this.numToAttrib[num] = [String(attrib[0] || ""), String(attrib[1] || "")];
      return num;
    }
    /**
     * @param {number} num - The identifier of the attribute to fetch.
     * @returns {Attribute} The attribute with the given identifier, or nullish if there is no such
     *     attribute.
     */
    getAttrib(num) {
      const pair = this.numToAttrib[num];
      if (!pair) {
        return pair;
      }
      return [pair[0], pair[1]];
    }
    /**
     * @param {number} num - The identifier of the attribute to fetch.
     * @returns {string} Eqivalent to `getAttrib(num)[0]` if the attribute exists, otherwise the empty
     *     string.
     */
    getAttribKey(num) {
      const pair = this.numToAttrib[num];
      if (!pair)
        return "";
      return pair[0];
    }
    /**
     * @param {number} num - The identifier of the attribute to fetch.
     * @returns {string} Eqivalent to `getAttrib(num)[1]` if the attribute exists, otherwise the empty
     *     string.
     */
    getAttribValue(num) {
      const pair = this.numToAttrib[num];
      if (!pair)
        return "";
      return pair[1];
    }
    /**
     * Executes a callback for each attribute in the pool.
     *
     * @param {Function} func - Callback to call with two arguments: key and value. Its return value
     *     is ignored.
     */
    eachAttrib(func) {
      for (const n of Object.keys(this.numToAttrib)) {
        const pair = this.numToAttrib[n];
        func(pair[0], pair[1]);
      }
    }
    /**
     * @returns {Jsonable} An object that can be passed to `fromJsonable` to reconstruct this
     *     attribute pool. The returned object can be converted to JSON. WARNING: The returned object
     *     has references to internal state (it is not a deep copy). Use the `clone()` method to copy
     *     a pool -- do NOT do `new AttributePool().fromJsonable(pool.toJsonable())` to copy because
     *     the resulting shared state will lead to pool corruption.
     */
    toJsonable() {
      return {
        numToAttrib: this.numToAttrib,
        nextNum: this.nextNum
      };
    }
    /**
     * Replace the contents of this attribute pool with values from a previous call to `toJsonable`.
     *
     * @param {Jsonable} obj - Object returned by `toJsonable` containing the attributes and their
     *     identifiers. WARNING: This function takes ownership of the object (it does not make a deep
     *     copy). Use the `clone()` method to copy a pool -- do NOT do
     *     `new AttributePool().fromJsonable(pool.toJsonable())` to copy because the resulting shared
     *     state will lead to pool corruption.
     */
    fromJsonable(obj) {
      this.numToAttrib = obj.numToAttrib;
      this.nextNum = obj.nextNum;
      this.attribToNum = {};
      for (const n of Object.keys(this.numToAttrib)) {
        this.attribToNum[String(this.numToAttrib[n])] = Number(n);
      }
      return this;
    }
    /**
     * Asserts that the data in the pool is consistent. Throws if inconsistent.
     */
    check() {
      if (!Number.isInteger(this.nextNum))
        throw new Error("nextNum property is not an integer");
      if (this.nextNum < 0)
        throw new Error("nextNum property is negative");
      for (const prop of ["numToAttrib", "attribToNum"]) {
        const obj = this[prop];
        if (obj == null)
          throw new Error(`${prop} property is null`);
        if (typeof obj !== "object")
          throw new TypeError(`${prop} property is not an object`);
        const keys2 = Object.keys(obj);
        if (keys2.length !== this.nextNum) {
          throw new Error(`${prop} size mismatch (want ${this.nextNum}, got ${keys2.length})`);
        }
      }
      for (let i = 0; i < this.nextNum; ++i) {
        const attr = this.numToAttrib[`${i}`];
        if (!Array.isArray(attr))
          throw new TypeError(`attrib ${i} is not an array`);
        if (attr.length !== 2)
          throw new Error(`attrib ${i} is not an array of length 2`);
        const [k, v] = attr;
        if (k == null)
          throw new TypeError(`attrib ${i} key is null`);
        if (typeof k !== "string")
          throw new TypeError(`attrib ${i} key is not a string`);
        if (v == null)
          throw new TypeError(`attrib ${i} value is null`);
        if (typeof v !== "string")
          throw new TypeError(`attrib ${i} value is not a string`);
        const attrStr = String(attr);
        if (this.attribToNum[attrStr] !== i)
          throw new Error(`attribToNum for ${attrStr} !== ${i}`);
      }
    }
  }
  AttributePool_1 = AttributePool;
  return AttributePool_1;
}
var Changeset = {};
var hasRequiredChangeset;
function requireChangeset() {
  if (hasRequiredChangeset)
    return Changeset;
  hasRequiredChangeset = 1;
  (function(exports) {
    const AttributeMap = requireAttributeMap();
    const AttributePool = requireAttributePool();
    const attributes2 = requireAttributes();
    const { padutils } = requirePad_utils();
    const error = (msg) => {
      const e = new Error(msg);
      e.easysync = true;
      throw e;
    };
    const assert = (b, msg) => {
      if (!b)
        error(`Failed assertion: ${msg}`);
    };
    exports.parseNum = (str) => parseInt(str, 36);
    exports.numToString = (num) => num.toString(36).toLowerCase();
    class Op {
      /**
       * @param {(''|'='|'+'|'-')} [opcode=''] - Initial value of the `opcode` property.
       */
      constructor(opcode = "") {
        this.opcode = opcode;
        this.chars = 0;
        this.lines = 0;
        this.attribs = "";
      }
      toString() {
        if (!this.opcode)
          throw new TypeError("null op");
        if (typeof this.attribs !== "string")
          throw new TypeError("attribs must be a string");
        const l = this.lines ? `|${exports.numToString(this.lines)}` : "";
        return this.attribs + l + this.opcode + exports.numToString(this.chars);
      }
    }
    exports.Op = Op;
    exports.oldLen = (cs) => exports.unpack(cs).oldLen;
    exports.newLen = (cs) => exports.unpack(cs).newLen;
    exports.deserializeOps = function* (ops) {
      const regex = /((?:\*[0-9a-z]+)*)(?:\|([0-9a-z]+))?([-+=])([0-9a-z]+)|(.)/g;
      let match;
      while ((match = regex.exec(ops)) != null) {
        if (match[5] === "$")
          return;
        if (match[5] != null)
          error(`invalid operation: ${ops.slice(regex.lastIndex - 1)}`);
        const op = new Op(match[3]);
        op.lines = exports.parseNum(match[2] || "0");
        op.chars = exports.parseNum(match[4]);
        op.attribs = match[1];
        yield op;
      }
    };
    class OpIter {
      /**
       * @param {string} ops - String encoding the change operations to iterate over.
       */
      constructor(ops) {
        this._gen = exports.deserializeOps(ops);
        this._next = this._gen.next();
      }
      /**
       * @returns {boolean} Whether there are any remaining operations.
       */
      hasNext() {
        return !this._next.done;
      }
      /**
       * Returns the next operation object and advances the iterator.
       *
       * Note: This does NOT implement the ECMAScript iterator protocol.
       *
       * @param {Op} [opOut] - Deprecated. Operation object to recycle for the return value.
       * @returns {Op} The next operation, or an operation with a falsy `opcode` property if there are
       *     no more operations.
       */
      next(opOut = new Op()) {
        if (this.hasNext()) {
          copyOp(this._next.value, opOut);
          this._next = this._gen.next();
        } else {
          clearOp(opOut);
        }
        return opOut;
      }
    }
    exports.opIterator = (opsStr) => {
      padutils.warnDeprecated(
        "Changeset.opIterator() is deprecated; use Changeset.deserializeOps() instead"
      );
      return new OpIter(opsStr);
    };
    const clearOp = (op) => {
      op.opcode = "";
      op.chars = 0;
      op.lines = 0;
      op.attribs = "";
    };
    exports.newOp = (optOpcode) => {
      padutils.warnDeprecated("Changeset.newOp() is deprecated; use the Changeset.Op class instead");
      return new Op(optOpcode);
    };
    const copyOp = (op1, op2 = new Op()) => Object.assign(op2, op1);
    const opsFromText = function* (opcode, text, attribs = "", pool = null) {
      const op = new Op(opcode);
      op.attribs = typeof attribs === "string" ? attribs : new AttributeMap(pool).update(attribs || [], opcode === "+").toString();
      const lastNewlinePos = text.lastIndexOf("\n");
      if (lastNewlinePos < 0) {
        op.chars = text.length;
        op.lines = 0;
        yield op;
      } else {
        op.chars = lastNewlinePos + 1;
        op.lines = text.match(/\n/g).length;
        yield op;
        const op2 = copyOp(op);
        op2.chars = text.length - (lastNewlinePos + 1);
        op2.lines = 0;
        yield op2;
      }
    };
    exports.checkRep = (cs) => {
      const unpacked = exports.unpack(cs);
      const oldLen = unpacked.oldLen;
      const newLen = unpacked.newLen;
      const ops = unpacked.ops;
      let charBank = unpacked.charBank;
      const assem = exports.smartOpAssembler();
      let oldPos = 0;
      let calcNewLen = 0;
      for (const o of exports.deserializeOps(ops)) {
        switch (o.opcode) {
          case "=":
            oldPos += o.chars;
            calcNewLen += o.chars;
            break;
          case "-":
            oldPos += o.chars;
            assert(oldPos <= oldLen, `${oldPos} > ${oldLen} in ${cs}`);
            break;
          case "+": {
            assert(charBank.length >= o.chars, "Invalid changeset: not enough chars in charBank");
            const chars = charBank.slice(0, o.chars);
            const nlines = (chars.match(/\n/g) || []).length;
            assert(
              nlines === o.lines,
              "Invalid changeset: number of newlines in insert op does not match the charBank"
            );
            assert(
              o.lines === 0 || chars.endsWith("\n"),
              "Invalid changeset: multiline insert op does not end with a newline"
            );
            charBank = charBank.slice(o.chars);
            calcNewLen += o.chars;
            assert(calcNewLen <= newLen, `${calcNewLen} > ${newLen} in ${cs}`);
            break;
          }
          default:
            assert(false, `Invalid changeset: Unknown opcode: ${JSON.stringify(o.opcode)}`);
        }
        assem.append(o);
      }
      calcNewLen += oldLen - oldPos;
      assert(calcNewLen === newLen, "Invalid changeset: claimed length does not match actual length");
      assert(charBank === "", "Invalid changeset: excess characters in the charBank");
      assem.endDocument();
      const normalized = exports.pack(oldLen, calcNewLen, assem.toString(), unpacked.charBank);
      assert(normalized === cs, "Invalid changeset: not in canonical form");
      return cs;
    };
    exports.smartOpAssembler = () => {
      const minusAssem = exports.mergingOpAssembler();
      const plusAssem = exports.mergingOpAssembler();
      const keepAssem = exports.mergingOpAssembler();
      const assem = exports.stringAssembler();
      let lastOpcode = "";
      let lengthChange = 0;
      const flushKeeps = () => {
        assem.append(keepAssem.toString());
        keepAssem.clear();
      };
      const flushPlusMinus = () => {
        assem.append(minusAssem.toString());
        minusAssem.clear();
        assem.append(plusAssem.toString());
        plusAssem.clear();
      };
      const append = (op) => {
        if (!op.opcode)
          return;
        if (!op.chars)
          return;
        if (op.opcode === "-") {
          if (lastOpcode === "=") {
            flushKeeps();
          }
          minusAssem.append(op);
          lengthChange -= op.chars;
        } else if (op.opcode === "+") {
          if (lastOpcode === "=") {
            flushKeeps();
          }
          plusAssem.append(op);
          lengthChange += op.chars;
        } else if (op.opcode === "=") {
          if (lastOpcode !== "=") {
            flushPlusMinus();
          }
          keepAssem.append(op);
        }
        lastOpcode = op.opcode;
      };
      const appendOpWithText = (opcode, text, attribs, pool) => {
        padutils.warnDeprecated("Changeset.smartOpAssembler().appendOpWithText() is deprecated; use opsFromText() instead.");
        for (const op of opsFromText(opcode, text, attribs, pool))
          append(op);
      };
      const toString2 = () => {
        flushPlusMinus();
        flushKeeps();
        return assem.toString();
      };
      const clear = () => {
        minusAssem.clear();
        plusAssem.clear();
        keepAssem.clear();
        assem.clear();
        lengthChange = 0;
      };
      const endDocument = () => {
        keepAssem.endDocument();
      };
      const getLengthChange = () => lengthChange;
      return {
        append,
        toString: toString2,
        clear,
        endDocument,
        appendOpWithText,
        getLengthChange
      };
    };
    exports.mergingOpAssembler = () => {
      const assem = exports.opAssembler();
      const bufOp = new Op();
      let bufOpAdditionalCharsAfterNewline = 0;
      const flush = (isEndDocument) => {
        if (!bufOp.opcode)
          return;
        if (isEndDocument && bufOp.opcode === "=" && !bufOp.attribs)
          ;
        else {
          assem.append(bufOp);
          if (bufOpAdditionalCharsAfterNewline) {
            bufOp.chars = bufOpAdditionalCharsAfterNewline;
            bufOp.lines = 0;
            assem.append(bufOp);
            bufOpAdditionalCharsAfterNewline = 0;
          }
        }
        bufOp.opcode = "";
      };
      const append = (op) => {
        if (op.chars <= 0)
          return;
        if (bufOp.opcode === op.opcode && bufOp.attribs === op.attribs) {
          if (op.lines > 0) {
            bufOp.chars += bufOpAdditionalCharsAfterNewline + op.chars;
            bufOp.lines += op.lines;
            bufOpAdditionalCharsAfterNewline = 0;
          } else if (bufOp.lines === 0) {
            bufOp.chars += op.chars;
          } else {
            bufOpAdditionalCharsAfterNewline += op.chars;
          }
        } else {
          flush();
          copyOp(op, bufOp);
        }
      };
      const endDocument = () => {
        flush(true);
      };
      const toString2 = () => {
        flush();
        return assem.toString();
      };
      const clear = () => {
        assem.clear();
        clearOp(bufOp);
      };
      return {
        append,
        toString: toString2,
        clear,
        endDocument
      };
    };
    exports.opAssembler = () => {
      let serialized = "";
      const append = (op) => {
        assert(op instanceof Op, "argument must be an instance of Op");
        serialized += op.toString();
      };
      const toString2 = () => serialized;
      const clear = () => {
        serialized = "";
      };
      return {
        append,
        toString: toString2,
        clear
      };
    };
    exports.stringIterator = (str) => {
      let curIndex = 0;
      let newLines = str.split("\n").length - 1;
      const getnewLines = () => newLines;
      const assertRemaining = (n) => {
        assert(n <= remaining(), `!(${n} <= ${remaining()})`);
      };
      const take = (n) => {
        assertRemaining(n);
        const s = str.substr(curIndex, n);
        newLines -= s.split("\n").length - 1;
        curIndex += n;
        return s;
      };
      const peek = (n) => {
        assertRemaining(n);
        const s = str.substr(curIndex, n);
        return s;
      };
      const skip = (n) => {
        assertRemaining(n);
        curIndex += n;
      };
      const remaining = () => str.length - curIndex;
      return {
        take,
        skip,
        remaining,
        peek,
        newlines: getnewLines
      };
    };
    exports.stringAssembler = () => ({
      _str: "",
      clear() {
        this._str = "";
      },
      /**
       * @param {string} x -
       */
      append(x) {
        this._str += String(x);
      },
      toString() {
        return this._str;
      }
    });
    class TextLinesMutator {
      /**
       * @param {(string[]|StringArrayLike)} lines - Lines to mutate (in place).
       */
      constructor(lines) {
        this._lines = lines;
        this._curSplice = [0, 0];
        this._inSplice = false;
        this._curLine = 0;
        this._curCol = 0;
      }
      /**
       * Get a line from `lines` at given index.
       *
       * @param {number} idx - an index
       * @returns {string}
       */
      _linesGet(idx) {
        if ("get" in this._lines) {
          return this._lines.get(idx);
        } else {
          return this._lines[idx];
        }
      }
      /**
       * Return a slice from `lines`.
       *
       * @param {number} start - the start index
       * @param {number} end - the end index
       * @returns {string[]}
       */
      _linesSlice(start, end) {
        if (this._lines.slice) {
          return this._lines.slice(start, end);
        } else {
          return [];
        }
      }
      /**
       * Return the length of `lines`.
       *
       * @returns {number}
       */
      _linesLength() {
        if (typeof this._lines.length === "number") {
          return this._lines.length;
        } else {
          return this._lines.length();
        }
      }
      /**
       * Starts a new splice.
       */
      _enterSplice() {
        this._curSplice[0] = this._curLine;
        this._curSplice[1] = 0;
        if (this._curCol > 0)
          this._putCurLineInSplice();
        this._inSplice = true;
      }
      /**
       * Changes the lines array according to the values in curSplice and resets curSplice. Called via
       * close or TODO(doc).
       */
      _leaveSplice() {
        this._lines.splice(...this._curSplice);
        this._curSplice.length = 2;
        this._curSplice[0] = this._curSplice[1] = 0;
        this._inSplice = false;
      }
      /**
       * Indicates if curLine is already in the splice. This is necessary because the last element in
       * curSplice is curLine when this line is currently worked on (e.g. when skipping or inserting).
       *
       * @returns {boolean} true if curLine is in splice
       */
      _isCurLineInSplice() {
        return this._curLine - this._curSplice[0] < this._curSplice.length - 2;
      }
      /**
       * Incorporates current line into the splice and marks its old position to be deleted.
       *
       * @returns {number} the index of the added line in curSplice
       */
      _putCurLineInSplice() {
        if (!this._isCurLineInSplice()) {
          this._curSplice.push(this._linesGet(this._curSplice[0] + this._curSplice[1]));
          this._curSplice[1]++;
        }
        return 2 + this._curLine - this._curSplice[0];
      }
      /**
       * It will skip some newlines by putting them into the splice.
       *
       * @param {number} L -
       * @param {boolean} includeInSplice - Indicates that attributes are present.
       */
      skipLines(L, includeInSplice) {
        if (!L)
          return;
        if (includeInSplice) {
          if (!this._inSplice)
            this._enterSplice();
          for (let i = 0; i < L; i++) {
            this._curCol = 0;
            this._putCurLineInSplice();
            this._curLine++;
          }
        } else {
          if (this._inSplice) {
            if (L > 1) {
              this._leaveSplice();
            } else {
              this._putCurLineInSplice();
            }
          }
          this._curLine += L;
          this._curCol = 0;
        }
      }
      /**
       * Skip some characters. Can contain newlines.
       *
       * @param {number} N - number of characters to skip
       * @param {number} L - number of newlines to skip
       * @param {boolean} includeInSplice - indicates if attributes are present
       */
      skip(N, L, includeInSplice) {
        if (!N)
          return;
        if (L) {
          this.skipLines(L, includeInSplice);
        } else {
          if (includeInSplice && !this._inSplice)
            this._enterSplice();
          if (this._inSplice) {
            this._putCurLineInSplice();
          }
          this._curCol += N;
        }
      }
      /**
       * Remove whole lines from lines array.
       *
       * @param {number} L - number of lines to remove
       * @returns {string}
       */
      removeLines(L) {
        if (!L)
          return "";
        if (!this._inSplice)
          this._enterSplice();
        const nextKLinesText = (k) => {
          const m = this._curSplice[0] + this._curSplice[1];
          return this._linesSlice(m, m + k).join("");
        };
        let removed = "";
        if (this._isCurLineInSplice()) {
          if (this._curCol === 0) {
            removed = this._curSplice[this._curSplice.length - 1];
            this._curSplice.length--;
            removed += nextKLinesText(L - 1);
            this._curSplice[1] += L - 1;
          } else {
            removed = nextKLinesText(L - 1);
            this._curSplice[1] += L - 1;
            const sline = this._curSplice.length - 1;
            removed = this._curSplice[sline].substring(this._curCol) + removed;
            this._curSplice[sline] = this._curSplice[sline].substring(0, this._curCol) + this._linesGet(this._curSplice[0] + this._curSplice[1]);
            this._curSplice[1] += 1;
          }
        } else {
          removed = nextKLinesText(L);
          this._curSplice[1] += L;
        }
        return removed;
      }
      /**
       * Remove text from lines array.
       *
       * @param {number} N - characters to delete
       * @param {number} L - lines to delete
       * @returns {string}
       */
      remove(N, L) {
        if (!N)
          return "";
        if (L)
          return this.removeLines(L);
        if (!this._inSplice)
          this._enterSplice();
        const sline = this._putCurLineInSplice();
        const removed = this._curSplice[sline].substring(this._curCol, this._curCol + N);
        this._curSplice[sline] = this._curSplice[sline].substring(0, this._curCol) + this._curSplice[sline].substring(this._curCol + N);
        return removed;
      }
      /**
       * Inserts text into lines array.
       *
       * @param {string} text - the text to insert
       * @param {number} L - number of newlines in text
       */
      insert(text, L) {
        if (!text)
          return;
        if (!this._inSplice)
          this._enterSplice();
        if (L) {
          const newLines = exports.splitTextLines(text);
          if (this._isCurLineInSplice()) {
            const sline = this._curSplice.length - 1;
            const theLine = this._curSplice[sline];
            const lineCol = this._curCol;
            this._curSplice[sline] = theLine.substring(0, lineCol) + newLines[0];
            this._curLine++;
            newLines.splice(0, 1);
            this._curSplice.push(...newLines);
            this._curLine += newLines.length;
            this._curSplice.push(theLine.substring(lineCol));
            this._curCol = 0;
          } else {
            this._curSplice.push(...newLines);
            this._curLine += newLines.length;
          }
        } else {
          const sline = this._putCurLineInSplice();
          if (!this._curSplice[sline]) {
            const err = new Error(
              `curSplice[sline] not populated, actual curSplice contents is ${JSON.stringify(this._curSplice)}. Possibly related to https://github.com/ether/etherpad-lite/issues/2802`
            );
            console.error(err.stack || err.toString());
          }
          this._curSplice[sline] = this._curSplice[sline].substring(0, this._curCol) + text + this._curSplice[sline].substring(this._curCol);
          this._curCol += text.length;
        }
      }
      /**
       * Checks if curLine (the line we are in when curSplice is applied) is the last line in `lines`.
       *
       * @returns {boolean} indicates if there are lines left
       */
      hasMore() {
        let docLines = this._linesLength();
        if (this._inSplice) {
          docLines += this._curSplice.length - 2 - this._curSplice[1];
        }
        return this._curLine < docLines;
      }
      /**
       * Closes the splice
       */
      close() {
        if (this._inSplice)
          this._leaveSplice();
      }
    }
    const applyZip = (in1, in2, func) => {
      const ops1 = exports.deserializeOps(in1);
      const ops2 = exports.deserializeOps(in2);
      let next1 = ops1.next();
      let next2 = ops2.next();
      const assem = exports.smartOpAssembler();
      while (!next1.done || !next2.done) {
        if (!next1.done && !next1.value.opcode)
          next1 = ops1.next();
        if (!next2.done && !next2.value.opcode)
          next2 = ops2.next();
        if (next1.value == null)
          next1.value = new Op();
        if (next2.value == null)
          next2.value = new Op();
        if (!next1.value.opcode && !next2.value.opcode)
          break;
        const opOut = func(next1.value, next2.value);
        if (opOut && opOut.opcode)
          assem.append(opOut);
      }
      assem.endDocument();
      return assem.toString();
    };
    exports.unpack = (cs) => {
      const headerRegex = /Z:([0-9a-z]+)([><])([0-9a-z]+)|/;
      const headerMatch = headerRegex.exec(cs);
      if (!headerMatch || !headerMatch[0])
        error(`Not a changeset: ${cs}`);
      const oldLen = exports.parseNum(headerMatch[1]);
      const changeSign = headerMatch[2] === ">" ? 1 : -1;
      const changeMag = exports.parseNum(headerMatch[3]);
      const newLen = oldLen + changeSign * changeMag;
      const opsStart = headerMatch[0].length;
      let opsEnd = cs.indexOf("$");
      if (opsEnd < 0)
        opsEnd = cs.length;
      return {
        oldLen,
        newLen,
        ops: cs.substring(opsStart, opsEnd),
        charBank: cs.substring(opsEnd + 1)
      };
    };
    exports.pack = (oldLen, newLen, opsStr, bank) => {
      const lenDiff = newLen - oldLen;
      const lenDiffStr = lenDiff >= 0 ? `>${exports.numToString(lenDiff)}` : `<${exports.numToString(-lenDiff)}`;
      const a = [];
      a.push("Z:", exports.numToString(oldLen), lenDiffStr, opsStr, "$", bank);
      return a.join("");
    };
    exports.applyToText = (cs, str) => {
      const unpacked = exports.unpack(cs);
      assert(str.length === unpacked.oldLen, `mismatched apply: ${str.length} / ${unpacked.oldLen}`);
      const bankIter = exports.stringIterator(unpacked.charBank);
      const strIter = exports.stringIterator(str);
      const assem = exports.stringAssembler();
      for (const op of exports.deserializeOps(unpacked.ops)) {
        switch (op.opcode) {
          case "+":
            if (op.lines !== bankIter.peek(op.chars).split("\n").length - 1) {
              throw new Error(`newline count is wrong in op +; cs:${cs} and text:${str}`);
            }
            assem.append(bankIter.take(op.chars));
            break;
          case "-":
            if (op.lines !== strIter.peek(op.chars).split("\n").length - 1) {
              throw new Error(`newline count is wrong in op -; cs:${cs} and text:${str}`);
            }
            strIter.skip(op.chars);
            break;
          case "=":
            if (op.lines !== strIter.peek(op.chars).split("\n").length - 1) {
              throw new Error(`newline count is wrong in op =; cs:${cs} and text:${str}`);
            }
            assem.append(strIter.take(op.chars));
            break;
        }
      }
      assem.append(strIter.take(strIter.remaining()));
      return assem.toString();
    };
    exports.mutateTextLines = (cs, lines) => {
      const unpacked = exports.unpack(cs);
      const bankIter = exports.stringIterator(unpacked.charBank);
      const mut = new TextLinesMutator(lines);
      for (const op of exports.deserializeOps(unpacked.ops)) {
        switch (op.opcode) {
          case "+":
            mut.insert(bankIter.take(op.chars), op.lines);
            break;
          case "-":
            mut.remove(op.chars, op.lines);
            break;
          case "=":
            mut.skip(op.chars, op.lines, !!op.attribs);
            break;
        }
      }
      mut.close();
    };
    exports.composeAttributes = (att1, att2, resultIsMutation, pool) => {
      if (!att1 && resultIsMutation) {
        return att2;
      }
      if (!att2)
        return att1;
      return AttributeMap.fromString(att1, pool).updateFromString(att2, !resultIsMutation).toString();
    };
    const slicerZipperFunc = (attOp, csOp, pool) => {
      const opOut = new Op();
      if (!attOp.opcode) {
        copyOp(csOp, opOut);
        csOp.opcode = "";
      } else if (!csOp.opcode) {
        copyOp(attOp, opOut);
        attOp.opcode = "";
      } else if (attOp.opcode === "-") {
        copyOp(attOp, opOut);
        attOp.opcode = "";
      } else if (csOp.opcode === "+") {
        copyOp(csOp, opOut);
        csOp.opcode = "";
      } else {
        for (const op of [attOp, csOp]) {
          assert(op.chars >= op.lines, `op has more newlines than chars: ${op.toString()}`);
        }
        assert(
          attOp.chars < csOp.chars ? attOp.lines <= csOp.lines : attOp.chars > csOp.chars ? attOp.lines >= csOp.lines : attOp.lines === csOp.lines,
          `line count mismatch when composing changesets A*B; opA: ${attOp.toString()} opB: ${csOp.toString()}`
        );
        assert(["+", "="].includes(attOp.opcode), `unexpected opcode in op: ${attOp.toString()}`);
        assert(["-", "="].includes(csOp.opcode), `unexpected opcode in op: ${csOp.toString()}`);
        opOut.opcode = {
          "+": {
            "-": "",
            // The '-' cancels out (some of) the '+', leaving any remainder for the next call.
            "=": "+"
          },
          "=": {
            "-": "-",
            "=": "="
          }
        }[attOp.opcode][csOp.opcode];
        const [fullyConsumedOp, partiallyConsumedOp] = [attOp, csOp].sort((a, b) => a.chars - b.chars);
        opOut.chars = fullyConsumedOp.chars;
        opOut.lines = fullyConsumedOp.lines;
        opOut.attribs = csOp.opcode === "-" ? csOp.attribs : exports.composeAttributes(attOp.attribs, csOp.attribs, attOp.opcode === "=", pool);
        partiallyConsumedOp.chars -= fullyConsumedOp.chars;
        partiallyConsumedOp.lines -= fullyConsumedOp.lines;
        if (!partiallyConsumedOp.chars)
          partiallyConsumedOp.opcode = "";
        fullyConsumedOp.opcode = "";
      }
      return opOut;
    };
    exports.applyToAttribution = (cs, astr, pool) => {
      const unpacked = exports.unpack(cs);
      return applyZip(astr, unpacked.ops, (op1, op2) => slicerZipperFunc(op1, op2, pool));
    };
    exports.mutateAttributionLines = (cs, lines, pool) => {
      const unpacked = exports.unpack(cs);
      const csOps = exports.deserializeOps(unpacked.ops);
      let csOpsNext = csOps.next();
      const csBank = unpacked.charBank;
      let csBankIndex = 0;
      const mut = new TextLinesMutator(lines);
      let lineOps = null;
      let lineOpsNext = null;
      const lineOpsHasNext = () => lineOpsNext && !lineOpsNext.done;
      const isNextMutOp = () => lineOpsHasNext() || mut.hasMore();
      const nextMutOp = () => {
        if (!lineOpsHasNext() && mut.hasMore()) {
          const line = mut.removeLines(1);
          lineOps = exports.deserializeOps(line);
          lineOpsNext = lineOps.next();
        }
        if (!lineOpsHasNext())
          return new Op();
        const op = lineOpsNext.value;
        lineOpsNext = lineOps.next();
        return op;
      };
      let lineAssem = null;
      const outputMutOp = (op) => {
        if (!lineAssem) {
          lineAssem = exports.mergingOpAssembler();
        }
        lineAssem.append(op);
        if (op.lines <= 0)
          return;
        assert(op.lines === 1, `Can't have op.lines of ${op.lines} in attribution lines`);
        mut.insert(lineAssem.toString(), 1);
        lineAssem = null;
      };
      let csOp = new Op();
      let attOp = new Op();
      while (csOp.opcode || !csOpsNext.done || attOp.opcode || isNextMutOp()) {
        if (!csOp.opcode && !csOpsNext.done) {
          csOp = csOpsNext.value;
          csOpsNext = csOps.next();
        }
        if (!csOp.opcode && !attOp.opcode && !lineAssem && !lineOpsHasNext()) {
          break;
        } else if (csOp.opcode === "=" && csOp.lines > 0 && !csOp.attribs && !attOp.opcode && !lineAssem && !lineOpsHasNext()) {
          mut.skipLines(csOp.lines);
          csOp.opcode = "";
        } else if (csOp.opcode === "+") {
          const opOut = copyOp(csOp);
          if (csOp.lines > 1) {
            const firstLineLen = csBank.indexOf("\n", csBankIndex) + 1 - csBankIndex;
            csOp.chars -= firstLineLen;
            csOp.lines--;
            opOut.lines = 1;
            opOut.chars = firstLineLen;
          } else {
            csOp.opcode = "";
          }
          outputMutOp(opOut);
          csBankIndex += opOut.chars;
        } else {
          if (!attOp.opcode && isNextMutOp())
            attOp = nextMutOp();
          const opOut = slicerZipperFunc(attOp, csOp, pool);
          if (opOut.opcode)
            outputMutOp(opOut);
        }
      }
      assert(!lineAssem, `line assembler not finished:${cs}`);
      mut.close();
    };
    exports.joinAttributionLines = (theAlines) => {
      const assem = exports.mergingOpAssembler();
      for (const aline of theAlines) {
        for (const op of exports.deserializeOps(aline))
          assem.append(op);
      }
      return assem.toString();
    };
    exports.splitAttributionLines = (attrOps, text) => {
      const assem = exports.mergingOpAssembler();
      const lines = [];
      let pos = 0;
      const appendOp = (op) => {
        assem.append(op);
        if (op.lines > 0) {
          lines.push(assem.toString());
          assem.clear();
        }
        pos += op.chars;
      };
      for (const op of exports.deserializeOps(attrOps)) {
        let numChars = op.chars;
        let numLines = op.lines;
        while (numLines > 1) {
          const newlineEnd = text.indexOf("\n", pos) + 1;
          assert(newlineEnd > 0, "newlineEnd <= 0 in splitAttributionLines");
          op.chars = newlineEnd - pos;
          op.lines = 1;
          appendOp(op);
          numChars -= op.chars;
          numLines -= op.lines;
        }
        if (numLines === 1) {
          op.chars = numChars;
          op.lines = 1;
        }
        appendOp(op);
      }
      return lines;
    };
    exports.splitTextLines = (text) => text.match(/[^\n]*(?:\n|[^\n]$)/g);
    exports.compose = (cs1, cs2, pool) => {
      const unpacked1 = exports.unpack(cs1);
      const unpacked2 = exports.unpack(cs2);
      const len1 = unpacked1.oldLen;
      const len2 = unpacked1.newLen;
      assert(len2 === unpacked2.oldLen, "mismatched composition of two changesets");
      const len3 = unpacked2.newLen;
      const bankIter1 = exports.stringIterator(unpacked1.charBank);
      const bankIter2 = exports.stringIterator(unpacked2.charBank);
      const bankAssem = exports.stringAssembler();
      const newOps = applyZip(unpacked1.ops, unpacked2.ops, (op1, op2) => {
        const op1code = op1.opcode;
        const op2code = op2.opcode;
        if (op1code === "+" && op2code === "-") {
          bankIter1.skip(Math.min(op1.chars, op2.chars));
        }
        const opOut = slicerZipperFunc(op1, op2, pool);
        if (opOut.opcode === "+") {
          if (op2code === "+") {
            bankAssem.append(bankIter2.take(opOut.chars));
          } else {
            bankAssem.append(bankIter1.take(opOut.chars));
          }
        }
        return opOut;
      });
      return exports.pack(len1, len3, newOps, bankAssem.toString());
    };
    exports.attributeTester = (attribPair, pool) => {
      const never = (attribs) => false;
      if (!pool)
        return never;
      const attribNum = pool.putAttrib(attribPair, true);
      if (attribNum < 0)
        return never;
      const re = new RegExp(`\\*${exports.numToString(attribNum)}(?!\\w)`);
      return (attribs) => re.test(attribs);
    };
    exports.identity = (N) => exports.pack(N, N, "", "");
    exports.makeSplice = (orig, start, ndel, ins, attribs, pool) => {
      if (start < 0)
        throw new RangeError(`start index must be non-negative (is ${start})`);
      if (ndel < 0)
        throw new RangeError(`characters to delete must be non-negative (is ${ndel})`);
      if (start > orig.length)
        start = orig.length;
      if (ndel > orig.length - start)
        ndel = orig.length - start;
      const deleted = orig.substring(start, start + ndel);
      const assem = exports.smartOpAssembler();
      const ops = function* () {
        yield* opsFromText("=", orig.substring(0, start));
        yield* opsFromText("-", deleted);
        yield* opsFromText("+", ins, attribs, pool);
      }();
      for (const op of ops)
        assem.append(op);
      assem.endDocument();
      return exports.pack(orig.length, orig.length + ins.length - ndel, assem.toString(), ins);
    };
    const toSplices = (cs) => {
      const unpacked = exports.unpack(cs);
      const splices = [];
      let oldPos = 0;
      const charIter = exports.stringIterator(unpacked.charBank);
      let inSplice = false;
      for (const op of exports.deserializeOps(unpacked.ops)) {
        if (op.opcode === "=") {
          oldPos += op.chars;
          inSplice = false;
        } else {
          if (!inSplice) {
            splices.push([oldPos, oldPos, ""]);
            inSplice = true;
          }
          if (op.opcode === "-") {
            oldPos += op.chars;
            splices[splices.length - 1][1] += op.chars;
          } else if (op.opcode === "+") {
            splices[splices.length - 1][2] += charIter.take(op.chars);
          }
        }
      }
      return splices;
    };
    exports.characterRangeFollow = (cs, startChar, endChar, insertionsAfter) => {
      let newStartChar = startChar;
      let newEndChar = endChar;
      let lengthChangeSoFar = 0;
      for (const splice of toSplices(cs)) {
        const spliceStart = splice[0] + lengthChangeSoFar;
        const spliceEnd = splice[1] + lengthChangeSoFar;
        const newTextLength = splice[2].length;
        const thisLengthChange = newTextLength - (spliceEnd - spliceStart);
        if (spliceStart <= newStartChar && spliceEnd >= newEndChar) {
          if (insertionsAfter) {
            newStartChar = newEndChar = spliceStart;
          } else {
            newStartChar = newEndChar = spliceStart + newTextLength;
          }
        } else if (spliceEnd <= newStartChar) {
          newStartChar += thisLengthChange;
          newEndChar += thisLengthChange;
        } else if (spliceStart >= newEndChar)
          ;
        else if (spliceStart >= newStartChar && spliceEnd <= newEndChar) {
          newEndChar += thisLengthChange;
        } else if (spliceEnd < newEndChar) {
          newStartChar = spliceStart + newTextLength;
          newEndChar += thisLengthChange;
        } else {
          newEndChar = spliceStart;
        }
        lengthChangeSoFar += thisLengthChange;
      }
      return [newStartChar, newEndChar];
    };
    exports.moveOpsToNewPool = (cs, oldPool, newPool) => {
      let dollarPos = cs.indexOf("$");
      if (dollarPos < 0) {
        dollarPos = cs.length;
      }
      const upToDollar = cs.substring(0, dollarPos);
      const fromDollar = cs.substring(dollarPos);
      return upToDollar.replace(/\*([0-9a-z]+)/g, (_2, a) => {
        const oldNum = exports.parseNum(a);
        const pair = oldPool.getAttrib(oldNum);
        if (!pair)
          return "";
        const newNum = newPool.putAttrib(pair);
        return `*${exports.numToString(newNum)}`;
      }) + fromDollar;
    };
    exports.makeAttribution = (text) => {
      const assem = exports.smartOpAssembler();
      for (const op of opsFromText("+", text))
        assem.append(op);
      return assem.toString();
    };
    exports.eachAttribNumber = (cs, func) => {
      padutils.warnDeprecated(
        "Changeset.eachAttribNumber() is deprecated; use attributes.decodeAttribString() instead"
      );
      let dollarPos = cs.indexOf("$");
      if (dollarPos < 0) {
        dollarPos = cs.length;
      }
      const upToDollar = cs.substring(0, dollarPos);
      upToDollar.replace(/\*([0-9a-z]+)/g, (_2, a) => {
        func(exports.parseNum(a));
        return "";
      });
    };
    exports.filterAttribNumbers = (cs, filter2) => exports.mapAttribNumbers(cs, filter2);
    exports.mapAttribNumbers = (cs, func) => {
      let dollarPos = cs.indexOf("$");
      if (dollarPos < 0) {
        dollarPos = cs.length;
      }
      const upToDollar = cs.substring(0, dollarPos);
      const newUpToDollar = upToDollar.replace(/\*([0-9a-z]+)/g, (s, a) => {
        const n = func(exports.parseNum(a));
        if (n === true) {
          return s;
        } else if (typeof n === "number") {
          return `*${exports.numToString(n)}`;
        } else {
          return "";
        }
      });
      return newUpToDollar + cs.substring(dollarPos);
    };
    exports.makeAText = (text, attribs) => ({
      text,
      attribs: attribs || exports.makeAttribution(text)
    });
    exports.applyToAText = (cs, atext, pool) => ({
      text: exports.applyToText(cs, atext.text),
      attribs: exports.applyToAttribution(cs, atext.attribs, pool)
    });
    exports.cloneAText = (atext) => {
      if (!atext)
        error("atext is null");
      return {
        text: atext.text,
        attribs: atext.attribs
      };
    };
    exports.copyAText = (atext1, atext2) => {
      atext2.text = atext1.text;
      atext2.attribs = atext1.attribs;
    };
    exports.opsFromAText = function* (atext) {
      let lastOp = null;
      for (const op of exports.deserializeOps(atext.attribs)) {
        if (lastOp != null)
          yield lastOp;
        lastOp = op;
      }
      if (lastOp == null)
        return;
      if (lastOp.lines <= 1) {
        lastOp.lines = 0;
        lastOp.chars--;
      } else {
        const nextToLastNewlineEnd = atext.text.lastIndexOf("\n", atext.text.length - 2) + 1;
        const lastLineLength = atext.text.length - nextToLastNewlineEnd - 1;
        lastOp.lines--;
        lastOp.chars -= lastLineLength + 1;
        yield copyOp(lastOp);
        lastOp.lines = 0;
        lastOp.chars = lastLineLength;
      }
      if (lastOp.chars)
        yield lastOp;
    };
    exports.appendATextToAssembler = (atext, assem) => {
      padutils.warnDeprecated(
        "Changeset.appendATextToAssembler() is deprecated; use Changeset.opsFromAText() instead"
      );
      for (const op of exports.opsFromAText(atext))
        assem.append(op);
    };
    exports.prepareForWire = (cs, pool) => {
      const newPool = new AttributePool();
      const newCs = exports.moveOpsToNewPool(cs, pool, newPool);
      return {
        translated: newCs,
        pool: newPool
      };
    };
    exports.isIdentity = (cs) => {
      const unpacked = exports.unpack(cs);
      return unpacked.ops === "" && unpacked.oldLen === unpacked.newLen;
    };
    const attribsAttributeValue = (attribs, key, pool) => {
      if (!attribs)
        return "";
      for (const [k, v] of attributes2.attribsFromString(attribs, pool)) {
        if (k === key)
          return v;
      }
      return "";
    };
    exports.opAttributeValue = (op, key, pool) => {
      padutils.warnDeprecated(
        "Changeset.opAttributeValue() is deprecated; use an AttributeMap instead"
      );
      return attribsAttributeValue(op.attribs, key, pool);
    };
    exports.attribsAttributeValue = (attribs, key, pool) => {
      padutils.warnDeprecated(
        "Changeset.attribsAttributeValue() is deprecated; use an AttributeMap instead"
      );
      return attribsAttributeValue(attribs, key, pool);
    };
    exports.builder = (oldLen) => {
      const assem = exports.smartOpAssembler();
      const o = new Op();
      const charBank = exports.stringAssembler();
      const self2 = {
        /**
         * @param {number} N - Number of characters to keep.
         * @param {number} L - Number of newlines among the `N` characters. If positive, the last
         *     character must be a newline.
         * @param {(string|Attribute[])} attribs - Either [[key1,value1],[key2,value2],...] or '*0*1...'
         *     (no pool needed in latter case).
         * @param {?AttributePool} pool - Attribute pool, only required if `attribs` is a list of
         *     attribute key, value pairs.
         * @returns {Builder} this
         */
        keep: (N, L, attribs, pool) => {
          o.opcode = "=";
          o.attribs = typeof attribs === "string" ? attribs : new AttributeMap(pool).update(attribs || []).toString();
          o.chars = N;
          o.lines = L || 0;
          assem.append(o);
          return self2;
        },
        /**
         * @param {string} text - Text to keep.
         * @param {(string|Attribute[])} attribs - Either [[key1,value1],[key2,value2],...] or '*0*1...'
         *     (no pool needed in latter case).
         * @param {?AttributePool} pool - Attribute pool, only required if `attribs` is a list of
         *     attribute key, value pairs.
         * @returns {Builder} this
         */
        keepText: (text, attribs, pool) => {
          for (const op of opsFromText("=", text, attribs, pool))
            assem.append(op);
          return self2;
        },
        /**
         * @param {string} text - Text to insert.
         * @param {(string|Attribute[])} attribs - Either [[key1,value1],[key2,value2],...] or '*0*1...'
         *     (no pool needed in latter case).
         * @param {?AttributePool} pool - Attribute pool, only required if `attribs` is a list of
         *     attribute key, value pairs.
         * @returns {Builder} this
         */
        insert: (text, attribs, pool) => {
          for (const op of opsFromText("+", text, attribs, pool))
            assem.append(op);
          charBank.append(text);
          return self2;
        },
        /**
         * @param {number} N - Number of characters to remove.
         * @param {number} L - Number of newlines among the `N` characters. If positive, the last
         *     character must be a newline.
         * @returns {Builder} this
         */
        remove: (N, L) => {
          o.opcode = "-";
          o.attribs = "";
          o.chars = N;
          o.lines = L || 0;
          assem.append(o);
          return self2;
        },
        toString: () => {
          assem.endDocument();
          const newLen = oldLen + assem.getLengthChange();
          return exports.pack(oldLen, newLen, assem.toString(), charBank.toString());
        }
      };
      return self2;
    };
    exports.makeAttribsString = (opcode, attribs, pool) => {
      padutils.warnDeprecated(
        "Changeset.makeAttribsString() is deprecated; use AttributeMap.prototype.toString() or attributes.attribsToString() instead"
      );
      if (!attribs || !["=", "+"].includes(opcode))
        return "";
      if (typeof attribs === "string")
        return attribs;
      return new AttributeMap(pool).update(attribs, opcode === "+").toString();
    };
    exports.subattribution = (astr, start, optEnd) => {
      const attOps = exports.deserializeOps(astr);
      let attOpsNext = attOps.next();
      const assem = exports.smartOpAssembler();
      let attOp = new Op();
      const csOp = new Op();
      const doCsOp = () => {
        if (!csOp.chars)
          return;
        while (csOp.opcode && (attOp.opcode || !attOpsNext.done)) {
          if (!attOp.opcode) {
            attOp = attOpsNext.value;
            attOpsNext = attOps.next();
          }
          if (csOp.opcode && attOp.opcode && csOp.chars >= attOp.chars && attOp.lines > 0 && csOp.lines <= 0) {
            csOp.lines++;
          }
          const opOut = slicerZipperFunc(attOp, csOp, null);
          if (opOut.opcode)
            assem.append(opOut);
        }
      };
      csOp.opcode = "-";
      csOp.chars = start;
      doCsOp();
      if (optEnd === void 0) {
        if (attOp.opcode) {
          assem.append(attOp);
        }
        while (!attOpsNext.done) {
          assem.append(attOpsNext.value);
          attOpsNext = attOps.next();
        }
      } else {
        csOp.opcode = "=";
        csOp.chars = optEnd - start;
        doCsOp();
      }
      return assem.toString();
    };
    exports.inverse = (cs, lines, alines, pool) => {
      const linesGet = (idx) => {
        if (lines.get) {
          return lines.get(idx);
        } else {
          return lines[idx];
        }
      };
      const alinesGet = (idx) => {
        if (alines.get) {
          return alines.get(idx);
        } else {
          return alines[idx];
        }
      };
      let curLine = 0;
      let curChar = 0;
      let curLineOps = null;
      let curLineOpsNext = null;
      let curLineOpsLine;
      let curLineNextOp = new Op("+");
      const unpacked = exports.unpack(cs);
      const builder = exports.builder(unpacked.newLen);
      const consumeAttribRuns = (numChars, func) => {
        if (!curLineOps || curLineOpsLine !== curLine) {
          curLineOps = exports.deserializeOps(alinesGet(curLine));
          curLineOpsNext = curLineOps.next();
          curLineOpsLine = curLine;
          let indexIntoLine = 0;
          while (!curLineOpsNext.done) {
            curLineNextOp = curLineOpsNext.value;
            curLineOpsNext = curLineOps.next();
            if (indexIntoLine + curLineNextOp.chars >= curChar) {
              curLineNextOp.chars -= curChar - indexIntoLine;
              break;
            }
            indexIntoLine += curLineNextOp.chars;
          }
        }
        while (numChars > 0) {
          if (!curLineNextOp.chars && curLineOpsNext.done) {
            curLine++;
            curChar = 0;
            curLineOpsLine = curLine;
            curLineNextOp.chars = 0;
            curLineOps = exports.deserializeOps(alinesGet(curLine));
            curLineOpsNext = curLineOps.next();
          }
          if (!curLineNextOp.chars) {
            if (curLineOpsNext.done) {
              curLineNextOp = new Op();
            } else {
              curLineNextOp = curLineOpsNext.value;
              curLineOpsNext = curLineOps.next();
            }
          }
          const charsToUse = Math.min(numChars, curLineNextOp.chars);
          func(charsToUse, curLineNextOp.attribs, charsToUse === curLineNextOp.chars && curLineNextOp.lines > 0);
          numChars -= charsToUse;
          curLineNextOp.chars -= charsToUse;
          curChar += charsToUse;
        }
        if (!curLineNextOp.chars && curLineOpsNext.done) {
          curLine++;
          curChar = 0;
        }
      };
      const skip = (N, L) => {
        if (L) {
          curLine += L;
          curChar = 0;
        } else if (curLineOps && curLineOpsLine === curLine) {
          consumeAttribRuns(N, () => {
          });
        } else {
          curChar += N;
        }
      };
      const nextText = (numChars) => {
        let len = 0;
        const assem = exports.stringAssembler();
        const firstString = linesGet(curLine).substring(curChar);
        len += firstString.length;
        assem.append(firstString);
        let lineNum = curLine + 1;
        while (len < numChars) {
          const nextString = linesGet(lineNum);
          len += nextString.length;
          assem.append(nextString);
          lineNum++;
        }
        return assem.toString().substring(0, numChars);
      };
      const cachedStrFunc = (func) => {
        const cache = {};
        return (s) => {
          if (!cache[s]) {
            cache[s] = func(s);
          }
          return cache[s];
        };
      };
      for (const csOp of exports.deserializeOps(unpacked.ops)) {
        if (csOp.opcode === "=") {
          if (csOp.attribs) {
            const attribs = AttributeMap.fromString(csOp.attribs, pool);
            const undoBackToAttribs = cachedStrFunc((oldAttribsStr) => {
              const oldAttribs = AttributeMap.fromString(oldAttribsStr, pool);
              const backAttribs = new AttributeMap(pool);
              for (const [key, value] of attribs) {
                const oldValue = oldAttribs.get(key) || "";
                if (oldValue !== value)
                  backAttribs.set(key, oldValue);
              }
              return backAttribs.toString();
            });
            consumeAttribRuns(csOp.chars, (len, attribs2, endsLine) => {
              builder.keep(len, endsLine ? 1 : 0, undoBackToAttribs(attribs2));
            });
          } else {
            skip(csOp.chars, csOp.lines);
            builder.keep(csOp.chars, csOp.lines);
          }
        } else if (csOp.opcode === "+") {
          builder.remove(csOp.chars, csOp.lines);
        } else if (csOp.opcode === "-") {
          const textBank = nextText(csOp.chars);
          let textBankIndex = 0;
          consumeAttribRuns(csOp.chars, (len, attribs, endsLine) => {
            builder.insert(textBank.substr(textBankIndex, len), attribs);
            textBankIndex += len;
          });
        }
      }
      return exports.checkRep(builder.toString());
    };
    exports.follow = (cs1, cs2, reverseInsertOrder, pool) => {
      const unpacked1 = exports.unpack(cs1);
      const unpacked2 = exports.unpack(cs2);
      const len1 = unpacked1.oldLen;
      const len2 = unpacked2.oldLen;
      assert(len1 === len2, "mismatched follow - cannot transform cs1 on top of cs2");
      const chars1 = exports.stringIterator(unpacked1.charBank);
      const chars2 = exports.stringIterator(unpacked2.charBank);
      const oldLen = unpacked1.newLen;
      let oldPos = 0;
      let newLen = 0;
      const hasInsertFirst = exports.attributeTester(["insertorder", "first"], pool);
      const newOps = applyZip(unpacked1.ops, unpacked2.ops, (op1, op2) => {
        const opOut = new Op();
        if (op1.opcode === "+" || op2.opcode === "+") {
          let whichToDo;
          if (op2.opcode !== "+") {
            whichToDo = 1;
          } else if (op1.opcode !== "+") {
            whichToDo = 2;
          } else {
            const firstChar1 = chars1.peek(1);
            const firstChar2 = chars2.peek(1);
            const insertFirst1 = hasInsertFirst(op1.attribs);
            const insertFirst2 = hasInsertFirst(op2.attribs);
            if (insertFirst1 && !insertFirst2) {
              whichToDo = 1;
            } else if (insertFirst2 && !insertFirst1) {
              whichToDo = 2;
            } else if (firstChar1 === "\n" && firstChar2 !== "\n") {
              whichToDo = 2;
            } else if (firstChar1 !== "\n" && firstChar2 === "\n") {
              whichToDo = 1;
            } else if (reverseInsertOrder) {
              whichToDo = 2;
            } else {
              whichToDo = 1;
            }
          }
          if (whichToDo === 1) {
            chars1.skip(op1.chars);
            opOut.opcode = "=";
            opOut.lines = op1.lines;
            opOut.chars = op1.chars;
            opOut.attribs = "";
            op1.opcode = "";
          } else {
            chars2.skip(op2.chars);
            copyOp(op2, opOut);
            op2.opcode = "";
          }
        } else if (op1.opcode === "-") {
          if (!op2.opcode) {
            op1.opcode = "";
          } else if (op1.chars <= op2.chars) {
            op2.chars -= op1.chars;
            op2.lines -= op1.lines;
            op1.opcode = "";
            if (!op2.chars) {
              op2.opcode = "";
            }
          } else {
            op1.chars -= op2.chars;
            op1.lines -= op2.lines;
            op2.opcode = "";
          }
        } else if (op2.opcode === "-") {
          copyOp(op2, opOut);
          if (!op1.opcode) {
            op2.opcode = "";
          } else if (op2.chars <= op1.chars) {
            op1.chars -= op2.chars;
            op1.lines -= op2.lines;
            op2.opcode = "";
            if (!op1.chars) {
              op1.opcode = "";
            }
          } else {
            opOut.lines = op1.lines;
            opOut.chars = op1.chars;
            op2.lines -= op1.lines;
            op2.chars -= op1.chars;
            op1.opcode = "";
          }
        } else if (!op1.opcode) {
          copyOp(op2, opOut);
          op2.opcode = "";
        } else if (!op2.opcode) {
          op1.opcode = "";
        } else {
          opOut.opcode = "=";
          opOut.attribs = followAttributes(op1.attribs, op2.attribs, pool);
          if (op1.chars <= op2.chars) {
            opOut.chars = op1.chars;
            opOut.lines = op1.lines;
            op2.chars -= op1.chars;
            op2.lines -= op1.lines;
            op1.opcode = "";
            if (!op2.chars) {
              op2.opcode = "";
            }
          } else {
            opOut.chars = op2.chars;
            opOut.lines = op2.lines;
            op1.chars -= op2.chars;
            op1.lines -= op2.lines;
            op2.opcode = "";
          }
        }
        switch (opOut.opcode) {
          case "=":
            oldPos += opOut.chars;
            newLen += opOut.chars;
            break;
          case "-":
            oldPos += opOut.chars;
            break;
          case "+":
            newLen += opOut.chars;
            break;
        }
        return opOut;
      });
      newLen += oldLen - oldPos;
      return exports.pack(oldLen, newLen, newOps, unpacked2.charBank);
    };
    const followAttributes = (att1, att2, pool) => {
      if (!att2 || !pool)
        return "";
      if (!att1)
        return att2;
      const atts = /* @__PURE__ */ new Map();
      att2.replace(/\*([0-9a-z]+)/g, (_2, a) => {
        const [key, val] = pool.getAttrib(exports.parseNum(a));
        atts.set(key, val);
        return "";
      });
      att1.replace(/\*([0-9a-z]+)/g, (_2, a) => {
        const [key, val] = pool.getAttrib(exports.parseNum(a));
        if (atts.has(key) && val <= atts.get(key))
          atts.delete(key);
        return "";
      });
      const buf = exports.stringAssembler();
      for (const att of atts) {
        buf.append("*");
        buf.append(exports.numToString(pool.putAttrib(att)));
      }
      return buf.toString();
    };
    exports.exportedForTestingOnly = {
      TextLinesMutator,
      followAttributes,
      toSplices
    };
  })(Changeset);
  return Changeset;
}
var hasRequiredChangesettracker;
function requireChangesettracker() {
  if (hasRequiredChangesettracker)
    return changesettracker;
  hasRequiredChangesettracker = 1;
  const AttributeMap = requireAttributeMap();
  const AttributePool = requireAttributePool();
  const Changeset2 = requireChangeset();
  const makeChangesetTracker = (scheduler, apool, aceCallbacksProvider) => {
    let baseAText = Changeset2.makeAText("\n");
    let submittedChangeset = null;
    let userChangeset = Changeset2.identity(1);
    let tracking = false;
    let applyingNonUserChanges = false;
    let changeCallback = null;
    let changeCallbackTimeout = null;
    const setChangeCallbackTimeout = () => {
      if (changeCallback && changeCallbackTimeout == null) {
        changeCallbackTimeout = scheduler.setTimeout(() => {
          try {
            changeCallback();
          } catch (pseudoError) {
          } finally {
            changeCallbackTimeout = null;
          }
        }, 0);
      }
    };
    let self2;
    return self2 = {
      isTracking: () => tracking,
      setBaseText: (text) => {
        self2.setBaseAttributedText(Changeset2.makeAText(text), null);
      },
      setBaseAttributedText: (atext, apoolJsonObj) => {
        aceCallbacksProvider.withCallbacks("setBaseText", (callbacks) => {
          tracking = true;
          baseAText = Changeset2.cloneAText(atext);
          if (apoolJsonObj) {
            const wireApool = new AttributePool().fromJsonable(apoolJsonObj);
            baseAText.attribs = Changeset2.moveOpsToNewPool(baseAText.attribs, wireApool, apool);
          }
          submittedChangeset = null;
          userChangeset = Changeset2.identity(atext.text.length);
          applyingNonUserChanges = true;
          try {
            callbacks.setDocumentAttributedText(atext);
          } finally {
            applyingNonUserChanges = false;
          }
        });
      },
      composeUserChangeset: (c) => {
        if (!tracking)
          return;
        if (applyingNonUserChanges)
          return;
        if (Changeset2.isIdentity(c))
          return;
        userChangeset = Changeset2.compose(userChangeset, c, apool);
        setChangeCallbackTimeout();
      },
      applyChangesToBase: (c, optAuthor, apoolJsonObj) => {
        if (!tracking)
          return;
        aceCallbacksProvider.withCallbacks("applyChangesToBase", (callbacks) => {
          if (apoolJsonObj) {
            const wireApool = new AttributePool().fromJsonable(apoolJsonObj);
            c = Changeset2.moveOpsToNewPool(c, wireApool, apool);
          }
          baseAText = Changeset2.applyToAText(c, baseAText, apool);
          let c2 = c;
          if (submittedChangeset) {
            const oldSubmittedChangeset = submittedChangeset;
            submittedChangeset = Changeset2.follow(c, oldSubmittedChangeset, false, apool);
            c2 = Changeset2.follow(oldSubmittedChangeset, c, true, apool);
          }
          const preferInsertingAfterUserChanges = true;
          const oldUserChangeset = userChangeset;
          userChangeset = Changeset2.follow(
            c2,
            oldUserChangeset,
            preferInsertingAfterUserChanges,
            apool
          );
          const postChange = Changeset2.follow(
            oldUserChangeset,
            c2,
            !preferInsertingAfterUserChanges,
            apool
          );
          const preferInsertionAfterCaret = true;
          applyingNonUserChanges = true;
          try {
            callbacks.applyChangesetToDocument(postChange, preferInsertionAfterCaret);
          } finally {
            applyingNonUserChanges = false;
          }
        });
      },
      prepareUserChangeset: () => {
        let toSubmit;
        if (submittedChangeset) {
          toSubmit = Changeset2.compose(submittedChangeset, userChangeset, apool);
        } else {
          const authorId = parent.parent.pad.myUserInfo.userId;
          const cs2 = Changeset2.unpack(userChangeset);
          const assem = Changeset2.mergingOpAssembler();
          for (const op of Changeset2.deserializeOps(cs2.ops)) {
            if (op.opcode === "+") {
              const attribs = AttributeMap.fromString(op.attribs, apool);
              const oldAuthorId = attribs.get("author");
              if (oldAuthorId != null && oldAuthorId !== authorId) {
                attribs.set("author", authorId);
                op.attribs = attribs.toString();
              }
            }
            assem.append(op);
          }
          assem.endDocument();
          userChangeset = Changeset2.pack(cs2.oldLen, cs2.newLen, assem.toString(), cs2.charBank);
          Changeset2.checkRep(userChangeset);
          if (Changeset2.isIdentity(userChangeset))
            toSubmit = null;
          else
            toSubmit = userChangeset;
        }
        let cs = null;
        if (toSubmit) {
          submittedChangeset = toSubmit;
          userChangeset = Changeset2.identity(Changeset2.newLen(toSubmit));
          cs = toSubmit;
        }
        let wireApool = null;
        if (cs) {
          const forWire = Changeset2.prepareForWire(cs, apool);
          wireApool = forWire.pool.toJsonable();
          cs = forWire.translated;
        }
        const data = {
          changeset: cs,
          apool: wireApool
        };
        return data;
      },
      applyPreparedChangesetToBase: () => {
        if (!submittedChangeset) {
          throw new Error("applySubmittedChangesToBase: no submitted changes to apply");
        }
        baseAText = Changeset2.applyToAText(submittedChangeset, baseAText, apool);
        submittedChangeset = null;
      },
      setUserChangeNotificationCallback: (callback) => {
        changeCallback = callback;
      },
      hasUncommittedChanges: () => !!(submittedChangeset || !Changeset2.isIdentity(userChangeset))
    };
  };
  changesettracker.makeChangesetTracker = makeChangesetTracker;
  return changesettracker;
}
var colorutils = {};
var hasRequiredColorutils;
function requireColorutils() {
  if (hasRequiredColorutils)
    return colorutils;
  hasRequiredColorutils = 1;
  const colorutils$1 = {};
  colorutils$1.isCssHex = (cssColor) => /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(cssColor);
  colorutils$1.css2triple = (cssColor) => {
    const sixHex = colorutils$1.css2sixhex(cssColor);
    const hexToFloat = (hh) => Number(`0x${hh}`) / 255;
    return [
      hexToFloat(sixHex.substr(0, 2)),
      hexToFloat(sixHex.substr(2, 2)),
      hexToFloat(sixHex.substr(4, 2))
    ];
  };
  colorutils$1.css2sixhex = (cssColor) => {
    let h = /[0-9a-fA-F]+/.exec(cssColor)[0];
    if (h.length !== 6) {
      const a = h.charAt(0);
      const b = h.charAt(1);
      const c = h.charAt(2);
      h = a + a + b + b + c + c;
    }
    return h;
  };
  colorutils$1.triple2css = (triple) => {
    const floatToHex = (n) => {
      const n2 = colorutils$1.clamp(Math.round(n * 255), 0, 255);
      return `0${n2.toString(16)}`.slice(-2);
    };
    return `#${floatToHex(triple[0])}${floatToHex(triple[1])}${floatToHex(triple[2])}`;
  };
  colorutils$1.clamp = (v, bot, top) => v < bot ? bot : v > top ? top : v;
  colorutils$1.min3 = (a, b, c) => a < b ? a < c ? a : c : b < c ? b : c;
  colorutils$1.max3 = (a, b, c) => a > b ? a > c ? a : c : b > c ? b : c;
  colorutils$1.colorMin = (c) => colorutils$1.min3(c[0], c[1], c[2]);
  colorutils$1.colorMax = (c) => colorutils$1.max3(c[0], c[1], c[2]);
  colorutils$1.scale = (v, bot, top) => colorutils$1.clamp(bot + v * (top - bot), 0, 1);
  colorutils$1.unscale = (v, bot, top) => colorutils$1.clamp((v - bot) / (top - bot), 0, 1);
  colorutils$1.scaleColor = (c, bot, top) => [
    colorutils$1.scale(c[0], bot, top),
    colorutils$1.scale(c[1], bot, top),
    colorutils$1.scale(c[2], bot, top)
  ];
  colorutils$1.unscaleColor = (c, bot, top) => [
    colorutils$1.unscale(c[0], bot, top),
    colorutils$1.unscale(c[1], bot, top),
    colorutils$1.unscale(c[2], bot, top)
  ];
  colorutils$1.luminosity = (c) => c[0] * 0.3 + c[1] * 0.59 + c[2] * 0.11;
  colorutils$1.saturate = (c) => {
    const min2 = colorutils$1.colorMin(c);
    const max2 = colorutils$1.colorMax(c);
    if (max2 - min2 <= 0)
      return [1, 1, 1];
    return colorutils$1.unscaleColor(c, min2, max2);
  };
  colorutils$1.blend = (c1, c2, t) => [
    colorutils$1.scale(t, c1[0], c2[0]),
    colorutils$1.scale(t, c1[1], c2[1]),
    colorutils$1.scale(t, c1[2], c2[2])
  ];
  colorutils$1.invert = (c) => [1 - c[0], 1 - c[1], 1 - c[2]];
  colorutils$1.complementary = (c) => {
    const inv = colorutils$1.invert(c);
    return [
      inv[0] >= c[0] ? Math.min(inv[0] * 1.3, 1) : c[0] * 0.3,
      inv[1] >= c[1] ? Math.min(inv[1] * 1.59, 1) : c[1] * 0.59,
      inv[2] >= c[2] ? Math.min(inv[2] * 1.11, 1) : c[2] * 0.11
    ];
  };
  colorutils$1.textColorFromBackgroundColor = (bgcolor, skinName) => {
    const white = skinName === "colibris" ? "var(--super-light-color)" : "#fff";
    const black = skinName === "colibris" ? "var(--super-dark-color)" : "#222";
    return colorutils$1.luminosity(colorutils$1.css2triple(bgcolor)) < 0.5 ? white : black;
  };
  colorutils.colorutils = colorutils$1;
  return colorutils;
}
var contentcollector = {};
var unorm = { exports: {} };
var hasRequiredUnorm;
function requireUnorm() {
  if (hasRequiredUnorm)
    return unorm.exports;
  hasRequiredUnorm = 1;
  (function(module) {
    (function(root2) {
      var DEFAULT_FEATURE = [null, 0, {}];
      var CACHE_THRESHOLD = 10;
      var SBase = 44032, LBase = 4352, VBase = 4449, TBase = 4519, LCount = 19, VCount = 21, TCount = 28;
      var NCount = VCount * TCount;
      var SCount = LCount * NCount;
      var UChar = function(cp, feature) {
        this.codepoint = cp;
        this.feature = feature;
      };
      var cache = {};
      var cacheCounter = [];
      for (var i = 0; i <= 255; ++i) {
        cacheCounter[i] = 0;
      }
      function fromCache(next, cp, needFeature) {
        var ret = cache[cp];
        if (!ret) {
          ret = next(cp, needFeature);
          if (!!ret.feature && ++cacheCounter[cp >> 8 & 255] > CACHE_THRESHOLD) {
            cache[cp] = ret;
          }
        }
        return ret;
      }
      function fromData(next, cp, needFeature) {
        var hash = cp & 65280;
        var dunit = UChar.udata[hash] || {};
        var f = dunit[cp];
        return f ? new UChar(cp, f) : new UChar(cp, DEFAULT_FEATURE);
      }
      function fromCpOnly(next, cp, needFeature) {
        return !!needFeature ? next(cp, needFeature) : new UChar(cp, null);
      }
      function fromRuleBasedJamo(next, cp, needFeature) {
        var j;
        if (cp < LBase || LBase + LCount <= cp && cp < SBase || SBase + SCount < cp) {
          return next(cp, needFeature);
        }
        if (LBase <= cp && cp < LBase + LCount) {
          var c = {};
          var base = (cp - LBase) * VCount;
          for (j = 0; j < VCount; ++j) {
            c[VBase + j] = SBase + TCount * (j + base);
          }
          return new UChar(cp, [, , c]);
        }
        var SIndex = cp - SBase;
        var TIndex = SIndex % TCount;
        var feature = [];
        if (TIndex !== 0) {
          feature[0] = [SBase + SIndex - TIndex, TBase + TIndex];
        } else {
          feature[0] = [LBase + Math.floor(SIndex / NCount), VBase + Math.floor(SIndex % NCount / TCount)];
          feature[2] = {};
          for (j = 1; j < TCount; ++j) {
            feature[2][TBase + j] = cp + j;
          }
        }
        return new UChar(cp, feature);
      }
      function fromCpFilter(next, cp, needFeature) {
        return cp < 60 || 13311 < cp && cp < 42607 ? new UChar(cp, DEFAULT_FEATURE) : next(cp, needFeature);
      }
      var strategies = [fromCpFilter, fromCache, fromCpOnly, fromRuleBasedJamo, fromData];
      UChar.fromCharCode = strategies.reduceRight(function(next, strategy) {
        return function(cp, needFeature) {
          return strategy(next, cp, needFeature);
        };
      }, null);
      UChar.isHighSurrogate = function(cp) {
        return cp >= 55296 && cp <= 56319;
      };
      UChar.isLowSurrogate = function(cp) {
        return cp >= 56320 && cp <= 57343;
      };
      UChar.prototype.prepFeature = function() {
        if (!this.feature) {
          this.feature = UChar.fromCharCode(this.codepoint, true).feature;
        }
      };
      UChar.prototype.toString = function() {
        if (this.codepoint < 65536) {
          return String.fromCharCode(this.codepoint);
        } else {
          var x = this.codepoint - 65536;
          return String.fromCharCode(Math.floor(x / 1024) + 55296, x % 1024 + 56320);
        }
      };
      UChar.prototype.getDecomp = function() {
        this.prepFeature();
        return this.feature[0] || null;
      };
      UChar.prototype.isCompatibility = function() {
        this.prepFeature();
        return !!this.feature[1] && this.feature[1] & 1 << 8;
      };
      UChar.prototype.isExclude = function() {
        this.prepFeature();
        return !!this.feature[1] && this.feature[1] & 1 << 9;
      };
      UChar.prototype.getCanonicalClass = function() {
        this.prepFeature();
        return !!this.feature[1] ? this.feature[1] & 255 : 0;
      };
      UChar.prototype.getComposite = function(following) {
        this.prepFeature();
        if (!this.feature[2]) {
          return null;
        }
        var cp = this.feature[2][following.codepoint];
        return cp ? UChar.fromCharCode(cp) : null;
      };
      var UCharIterator = function(str) {
        this.str = str;
        this.cursor = 0;
      };
      UCharIterator.prototype.next = function() {
        if (!!this.str && this.cursor < this.str.length) {
          var cp = this.str.charCodeAt(this.cursor++);
          var d;
          if (UChar.isHighSurrogate(cp) && this.cursor < this.str.length && UChar.isLowSurrogate(d = this.str.charCodeAt(this.cursor))) {
            cp = (cp - 55296) * 1024 + (d - 56320) + 65536;
            ++this.cursor;
          }
          return UChar.fromCharCode(cp);
        } else {
          this.str = null;
          return null;
        }
      };
      var RecursDecompIterator = function(it, cano) {
        this.it = it;
        this.canonical = cano;
        this.resBuf = [];
      };
      RecursDecompIterator.prototype.next = function() {
        function recursiveDecomp(cano, uchar2) {
          var decomp = uchar2.getDecomp();
          if (!!decomp && !(cano && uchar2.isCompatibility())) {
            var ret = [];
            for (var i2 = 0; i2 < decomp.length; ++i2) {
              var a = recursiveDecomp(cano, UChar.fromCharCode(decomp[i2]));
              ret = ret.concat(a);
            }
            return ret;
          } else {
            return [uchar2];
          }
        }
        if (this.resBuf.length === 0) {
          var uchar = this.it.next();
          if (!uchar) {
            return null;
          }
          this.resBuf = recursiveDecomp(this.canonical, uchar);
        }
        return this.resBuf.shift();
      };
      var DecompIterator = function(it) {
        this.it = it;
        this.resBuf = [];
      };
      DecompIterator.prototype.next = function() {
        var cc;
        if (this.resBuf.length === 0) {
          do {
            var uchar = this.it.next();
            if (!uchar) {
              break;
            }
            cc = uchar.getCanonicalClass();
            var inspt = this.resBuf.length;
            if (cc !== 0) {
              for (; inspt > 0; --inspt) {
                var uchar2 = this.resBuf[inspt - 1];
                var cc2 = uchar2.getCanonicalClass();
                if (cc2 <= cc) {
                  break;
                }
              }
            }
            this.resBuf.splice(inspt, 0, uchar);
          } while (cc !== 0);
        }
        return this.resBuf.shift();
      };
      var CompIterator = function(it) {
        this.it = it;
        this.procBuf = [];
        this.resBuf = [];
        this.lastClass = null;
      };
      CompIterator.prototype.next = function() {
        while (this.resBuf.length === 0) {
          var uchar = this.it.next();
          if (!uchar) {
            this.resBuf = this.procBuf;
            this.procBuf = [];
            break;
          }
          if (this.procBuf.length === 0) {
            this.lastClass = uchar.getCanonicalClass();
            this.procBuf.push(uchar);
          } else {
            var starter = this.procBuf[0];
            var composite = starter.getComposite(uchar);
            var cc = uchar.getCanonicalClass();
            if (!!composite && (this.lastClass < cc || this.lastClass === 0)) {
              this.procBuf[0] = composite;
            } else {
              if (cc === 0) {
                this.resBuf = this.procBuf;
                this.procBuf = [];
              }
              this.lastClass = cc;
              this.procBuf.push(uchar);
            }
          }
        }
        return this.resBuf.shift();
      };
      var createIterator = function(mode, str) {
        switch (mode) {
          case "NFD":
            return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true));
          case "NFKD":
            return new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false));
          case "NFC":
            return new CompIterator(new DecompIterator(new RecursDecompIterator(new UCharIterator(str), true)));
          case "NFKC":
            return new CompIterator(new DecompIterator(new RecursDecompIterator(new UCharIterator(str), false)));
        }
        throw mode + " is invalid";
      };
      var normalize = function(mode, str) {
        var it = createIterator(mode, str);
        var ret = "";
        var uchar;
        while (!!(uchar = it.next())) {
          ret += uchar.toString();
        }
        return ret;
      };
      function nfd(str) {
        return normalize("NFD", str);
      }
      function nfkd(str) {
        return normalize("NFKD", str);
      }
      function nfc(str) {
        return normalize("NFC", str);
      }
      function nfkc(str) {
        return normalize("NFKC", str);
      }
      UChar.udata = {
        0: { 60: [, , { 824: 8814 }], 61: [, , { 824: 8800 }], 62: [, , { 824: 8815 }], 65: [, , { 768: 192, 769: 193, 770: 194, 771: 195, 772: 256, 774: 258, 775: 550, 776: 196, 777: 7842, 778: 197, 780: 461, 783: 512, 785: 514, 803: 7840, 805: 7680, 808: 260 }], 66: [, , { 775: 7682, 803: 7684, 817: 7686 }], 67: [, , { 769: 262, 770: 264, 775: 266, 780: 268, 807: 199 }], 68: [, , { 775: 7690, 780: 270, 803: 7692, 807: 7696, 813: 7698, 817: 7694 }], 69: [, , { 768: 200, 769: 201, 770: 202, 771: 7868, 772: 274, 774: 276, 775: 278, 776: 203, 777: 7866, 780: 282, 783: 516, 785: 518, 803: 7864, 807: 552, 808: 280, 813: 7704, 816: 7706 }], 70: [, , { 775: 7710 }], 71: [, , { 769: 500, 770: 284, 772: 7712, 774: 286, 775: 288, 780: 486, 807: 290 }], 72: [, , { 770: 292, 775: 7714, 776: 7718, 780: 542, 803: 7716, 807: 7720, 814: 7722 }], 73: [, , { 768: 204, 769: 205, 770: 206, 771: 296, 772: 298, 774: 300, 775: 304, 776: 207, 777: 7880, 780: 463, 783: 520, 785: 522, 803: 7882, 808: 302, 816: 7724 }], 74: [, , { 770: 308 }], 75: [, , { 769: 7728, 780: 488, 803: 7730, 807: 310, 817: 7732 }], 76: [, , { 769: 313, 780: 317, 803: 7734, 807: 315, 813: 7740, 817: 7738 }], 77: [, , { 769: 7742, 775: 7744, 803: 7746 }], 78: [, , { 768: 504, 769: 323, 771: 209, 775: 7748, 780: 327, 803: 7750, 807: 325, 813: 7754, 817: 7752 }], 79: [, , { 768: 210, 769: 211, 770: 212, 771: 213, 772: 332, 774: 334, 775: 558, 776: 214, 777: 7886, 779: 336, 780: 465, 783: 524, 785: 526, 795: 416, 803: 7884, 808: 490 }], 80: [, , { 769: 7764, 775: 7766 }], 82: [, , { 769: 340, 775: 7768, 780: 344, 783: 528, 785: 530, 803: 7770, 807: 342, 817: 7774 }], 83: [, , { 769: 346, 770: 348, 775: 7776, 780: 352, 803: 7778, 806: 536, 807: 350 }], 84: [, , { 775: 7786, 780: 356, 803: 7788, 806: 538, 807: 354, 813: 7792, 817: 7790 }], 85: [, , { 768: 217, 769: 218, 770: 219, 771: 360, 772: 362, 774: 364, 776: 220, 777: 7910, 778: 366, 779: 368, 780: 467, 783: 532, 785: 534, 795: 431, 803: 7908, 804: 7794, 808: 370, 813: 7798, 816: 7796 }], 86: [, , { 771: 7804, 803: 7806 }], 87: [, , { 768: 7808, 769: 7810, 770: 372, 775: 7814, 776: 7812, 803: 7816 }], 88: [, , { 775: 7818, 776: 7820 }], 89: [, , { 768: 7922, 769: 221, 770: 374, 771: 7928, 772: 562, 775: 7822, 776: 376, 777: 7926, 803: 7924 }], 90: [, , { 769: 377, 770: 7824, 775: 379, 780: 381, 803: 7826, 817: 7828 }], 97: [, , { 768: 224, 769: 225, 770: 226, 771: 227, 772: 257, 774: 259, 775: 551, 776: 228, 777: 7843, 778: 229, 780: 462, 783: 513, 785: 515, 803: 7841, 805: 7681, 808: 261 }], 98: [, , { 775: 7683, 803: 7685, 817: 7687 }], 99: [, , { 769: 263, 770: 265, 775: 267, 780: 269, 807: 231 }], 100: [, , { 775: 7691, 780: 271, 803: 7693, 807: 7697, 813: 7699, 817: 7695 }], 101: [, , { 768: 232, 769: 233, 770: 234, 771: 7869, 772: 275, 774: 277, 775: 279, 776: 235, 777: 7867, 780: 283, 783: 517, 785: 519, 803: 7865, 807: 553, 808: 281, 813: 7705, 816: 7707 }], 102: [, , { 775: 7711 }], 103: [, , { 769: 501, 770: 285, 772: 7713, 774: 287, 775: 289, 780: 487, 807: 291 }], 104: [, , { 770: 293, 775: 7715, 776: 7719, 780: 543, 803: 7717, 807: 7721, 814: 7723, 817: 7830 }], 105: [, , { 768: 236, 769: 237, 770: 238, 771: 297, 772: 299, 774: 301, 776: 239, 777: 7881, 780: 464, 783: 521, 785: 523, 803: 7883, 808: 303, 816: 7725 }], 106: [, , { 770: 309, 780: 496 }], 107: [, , { 769: 7729, 780: 489, 803: 7731, 807: 311, 817: 7733 }], 108: [, , { 769: 314, 780: 318, 803: 7735, 807: 316, 813: 7741, 817: 7739 }], 109: [, , { 769: 7743, 775: 7745, 803: 7747 }], 110: [, , { 768: 505, 769: 324, 771: 241, 775: 7749, 780: 328, 803: 7751, 807: 326, 813: 7755, 817: 7753 }], 111: [, , { 768: 242, 769: 243, 770: 244, 771: 245, 772: 333, 774: 335, 775: 559, 776: 246, 777: 7887, 779: 337, 780: 466, 783: 525, 785: 527, 795: 417, 803: 7885, 808: 491 }], 112: [, , { 769: 7765, 775: 7767 }], 114: [, , { 769: 341, 775: 7769, 780: 345, 783: 529, 785: 531, 803: 7771, 807: 343, 817: 7775 }], 115: [, , { 769: 347, 770: 349, 775: 7777, 780: 353, 803: 7779, 806: 537, 807: 351 }], 116: [, , { 775: 7787, 776: 7831, 780: 357, 803: 7789, 806: 539, 807: 355, 813: 7793, 817: 7791 }], 117: [, , { 768: 249, 769: 250, 770: 251, 771: 361, 772: 363, 774: 365, 776: 252, 777: 7911, 778: 367, 779: 369, 780: 468, 783: 533, 785: 535, 795: 432, 803: 7909, 804: 7795, 808: 371, 813: 7799, 816: 7797 }], 118: [, , { 771: 7805, 803: 7807 }], 119: [, , { 768: 7809, 769: 7811, 770: 373, 775: 7815, 776: 7813, 778: 7832, 803: 7817 }], 120: [, , { 775: 7819, 776: 7821 }], 121: [, , { 768: 7923, 769: 253, 770: 375, 771: 7929, 772: 563, 775: 7823, 776: 255, 777: 7927, 778: 7833, 803: 7925 }], 122: [, , { 769: 378, 770: 7825, 775: 380, 780: 382, 803: 7827, 817: 7829 }], 160: [[32], 256], 168: [[32, 776], 256, { 768: 8173, 769: 901, 834: 8129 }], 170: [[97], 256], 175: [[32, 772], 256], 178: [[50], 256], 179: [[51], 256], 180: [[32, 769], 256], 181: [[956], 256], 184: [[32, 807], 256], 185: [[49], 256], 186: [[111], 256], 188: [[49, 8260, 52], 256], 189: [[49, 8260, 50], 256], 190: [[51, 8260, 52], 256], 192: [[65, 768]], 193: [[65, 769]], 194: [[65, 770], , { 768: 7846, 769: 7844, 771: 7850, 777: 7848 }], 195: [[65, 771]], 196: [[65, 776], , { 772: 478 }], 197: [[65, 778], , { 769: 506 }], 198: [, , { 769: 508, 772: 482 }], 199: [[67, 807], , { 769: 7688 }], 200: [[69, 768]], 201: [[69, 769]], 202: [[69, 770], , { 768: 7872, 769: 7870, 771: 7876, 777: 7874 }], 203: [[69, 776]], 204: [[73, 768]], 205: [[73, 769]], 206: [[73, 770]], 207: [[73, 776], , { 769: 7726 }], 209: [[78, 771]], 210: [[79, 768]], 211: [[79, 769]], 212: [[79, 770], , { 768: 7890, 769: 7888, 771: 7894, 777: 7892 }], 213: [[79, 771], , { 769: 7756, 772: 556, 776: 7758 }], 214: [[79, 776], , { 772: 554 }], 216: [, , { 769: 510 }], 217: [[85, 768]], 218: [[85, 769]], 219: [[85, 770]], 220: [[85, 776], , { 768: 475, 769: 471, 772: 469, 780: 473 }], 221: [[89, 769]], 224: [[97, 768]], 225: [[97, 769]], 226: [[97, 770], , { 768: 7847, 769: 7845, 771: 7851, 777: 7849 }], 227: [[97, 771]], 228: [[97, 776], , { 772: 479 }], 229: [[97, 778], , { 769: 507 }], 230: [, , { 769: 509, 772: 483 }], 231: [[99, 807], , { 769: 7689 }], 232: [[101, 768]], 233: [[101, 769]], 234: [[101, 770], , { 768: 7873, 769: 7871, 771: 7877, 777: 7875 }], 235: [[101, 776]], 236: [[105, 768]], 237: [[105, 769]], 238: [[105, 770]], 239: [[105, 776], , { 769: 7727 }], 241: [[110, 771]], 242: [[111, 768]], 243: [[111, 769]], 244: [[111, 770], , { 768: 7891, 769: 7889, 771: 7895, 777: 7893 }], 245: [[111, 771], , { 769: 7757, 772: 557, 776: 7759 }], 246: [[111, 776], , { 772: 555 }], 248: [, , { 769: 511 }], 249: [[117, 768]], 250: [[117, 769]], 251: [[117, 770]], 252: [[117, 776], , { 768: 476, 769: 472, 772: 470, 780: 474 }], 253: [[121, 769]], 255: [[121, 776]] },
        256: { 256: [[65, 772]], 257: [[97, 772]], 258: [[65, 774], , { 768: 7856, 769: 7854, 771: 7860, 777: 7858 }], 259: [[97, 774], , { 768: 7857, 769: 7855, 771: 7861, 777: 7859 }], 260: [[65, 808]], 261: [[97, 808]], 262: [[67, 769]], 263: [[99, 769]], 264: [[67, 770]], 265: [[99, 770]], 266: [[67, 775]], 267: [[99, 775]], 268: [[67, 780]], 269: [[99, 780]], 270: [[68, 780]], 271: [[100, 780]], 274: [[69, 772], , { 768: 7700, 769: 7702 }], 275: [[101, 772], , { 768: 7701, 769: 7703 }], 276: [[69, 774]], 277: [[101, 774]], 278: [[69, 775]], 279: [[101, 775]], 280: [[69, 808]], 281: [[101, 808]], 282: [[69, 780]], 283: [[101, 780]], 284: [[71, 770]], 285: [[103, 770]], 286: [[71, 774]], 287: [[103, 774]], 288: [[71, 775]], 289: [[103, 775]], 290: [[71, 807]], 291: [[103, 807]], 292: [[72, 770]], 293: [[104, 770]], 296: [[73, 771]], 297: [[105, 771]], 298: [[73, 772]], 299: [[105, 772]], 300: [[73, 774]], 301: [[105, 774]], 302: [[73, 808]], 303: [[105, 808]], 304: [[73, 775]], 306: [[73, 74], 256], 307: [[105, 106], 256], 308: [[74, 770]], 309: [[106, 770]], 310: [[75, 807]], 311: [[107, 807]], 313: [[76, 769]], 314: [[108, 769]], 315: [[76, 807]], 316: [[108, 807]], 317: [[76, 780]], 318: [[108, 780]], 319: [[76, 183], 256], 320: [[108, 183], 256], 323: [[78, 769]], 324: [[110, 769]], 325: [[78, 807]], 326: [[110, 807]], 327: [[78, 780]], 328: [[110, 780]], 329: [[700, 110], 256], 332: [[79, 772], , { 768: 7760, 769: 7762 }], 333: [[111, 772], , { 768: 7761, 769: 7763 }], 334: [[79, 774]], 335: [[111, 774]], 336: [[79, 779]], 337: [[111, 779]], 340: [[82, 769]], 341: [[114, 769]], 342: [[82, 807]], 343: [[114, 807]], 344: [[82, 780]], 345: [[114, 780]], 346: [[83, 769], , { 775: 7780 }], 347: [[115, 769], , { 775: 7781 }], 348: [[83, 770]], 349: [[115, 770]], 350: [[83, 807]], 351: [[115, 807]], 352: [[83, 780], , { 775: 7782 }], 353: [[115, 780], , { 775: 7783 }], 354: [[84, 807]], 355: [[116, 807]], 356: [[84, 780]], 357: [[116, 780]], 360: [[85, 771], , { 769: 7800 }], 361: [[117, 771], , { 769: 7801 }], 362: [[85, 772], , { 776: 7802 }], 363: [[117, 772], , { 776: 7803 }], 364: [[85, 774]], 365: [[117, 774]], 366: [[85, 778]], 367: [[117, 778]], 368: [[85, 779]], 369: [[117, 779]], 370: [[85, 808]], 371: [[117, 808]], 372: [[87, 770]], 373: [[119, 770]], 374: [[89, 770]], 375: [[121, 770]], 376: [[89, 776]], 377: [[90, 769]], 378: [[122, 769]], 379: [[90, 775]], 380: [[122, 775]], 381: [[90, 780]], 382: [[122, 780]], 383: [[115], 256, { 775: 7835 }], 416: [[79, 795], , { 768: 7900, 769: 7898, 771: 7904, 777: 7902, 803: 7906 }], 417: [[111, 795], , { 768: 7901, 769: 7899, 771: 7905, 777: 7903, 803: 7907 }], 431: [[85, 795], , { 768: 7914, 769: 7912, 771: 7918, 777: 7916, 803: 7920 }], 432: [[117, 795], , { 768: 7915, 769: 7913, 771: 7919, 777: 7917, 803: 7921 }], 439: [, , { 780: 494 }], 452: [[68, 381], 256], 453: [[68, 382], 256], 454: [[100, 382], 256], 455: [[76, 74], 256], 456: [[76, 106], 256], 457: [[108, 106], 256], 458: [[78, 74], 256], 459: [[78, 106], 256], 460: [[110, 106], 256], 461: [[65, 780]], 462: [[97, 780]], 463: [[73, 780]], 464: [[105, 780]], 465: [[79, 780]], 466: [[111, 780]], 467: [[85, 780]], 468: [[117, 780]], 469: [[220, 772]], 470: [[252, 772]], 471: [[220, 769]], 472: [[252, 769]], 473: [[220, 780]], 474: [[252, 780]], 475: [[220, 768]], 476: [[252, 768]], 478: [[196, 772]], 479: [[228, 772]], 480: [[550, 772]], 481: [[551, 772]], 482: [[198, 772]], 483: [[230, 772]], 486: [[71, 780]], 487: [[103, 780]], 488: [[75, 780]], 489: [[107, 780]], 490: [[79, 808], , { 772: 492 }], 491: [[111, 808], , { 772: 493 }], 492: [[490, 772]], 493: [[491, 772]], 494: [[439, 780]], 495: [[658, 780]], 496: [[106, 780]], 497: [[68, 90], 256], 498: [[68, 122], 256], 499: [[100, 122], 256], 500: [[71, 769]], 501: [[103, 769]], 504: [[78, 768]], 505: [[110, 768]], 506: [[197, 769]], 507: [[229, 769]], 508: [[198, 769]], 509: [[230, 769]], 510: [[216, 769]], 511: [[248, 769]], 66045: [, 220] },
        512: { 512: [[65, 783]], 513: [[97, 783]], 514: [[65, 785]], 515: [[97, 785]], 516: [[69, 783]], 517: [[101, 783]], 518: [[69, 785]], 519: [[101, 785]], 520: [[73, 783]], 521: [[105, 783]], 522: [[73, 785]], 523: [[105, 785]], 524: [[79, 783]], 525: [[111, 783]], 526: [[79, 785]], 527: [[111, 785]], 528: [[82, 783]], 529: [[114, 783]], 530: [[82, 785]], 531: [[114, 785]], 532: [[85, 783]], 533: [[117, 783]], 534: [[85, 785]], 535: [[117, 785]], 536: [[83, 806]], 537: [[115, 806]], 538: [[84, 806]], 539: [[116, 806]], 542: [[72, 780]], 543: [[104, 780]], 550: [[65, 775], , { 772: 480 }], 551: [[97, 775], , { 772: 481 }], 552: [[69, 807], , { 774: 7708 }], 553: [[101, 807], , { 774: 7709 }], 554: [[214, 772]], 555: [[246, 772]], 556: [[213, 772]], 557: [[245, 772]], 558: [[79, 775], , { 772: 560 }], 559: [[111, 775], , { 772: 561 }], 560: [[558, 772]], 561: [[559, 772]], 562: [[89, 772]], 563: [[121, 772]], 658: [, , { 780: 495 }], 688: [[104], 256], 689: [[614], 256], 690: [[106], 256], 691: [[114], 256], 692: [[633], 256], 693: [[635], 256], 694: [[641], 256], 695: [[119], 256], 696: [[121], 256], 728: [[32, 774], 256], 729: [[32, 775], 256], 730: [[32, 778], 256], 731: [[32, 808], 256], 732: [[32, 771], 256], 733: [[32, 779], 256], 736: [[611], 256], 737: [[108], 256], 738: [[115], 256], 739: [[120], 256], 740: [[661], 256], 66272: [, 220] },
        768: { 768: [, 230], 769: [, 230], 770: [, 230], 771: [, 230], 772: [, 230], 773: [, 230], 774: [, 230], 775: [, 230], 776: [, 230, { 769: 836 }], 777: [, 230], 778: [, 230], 779: [, 230], 780: [, 230], 781: [, 230], 782: [, 230], 783: [, 230], 784: [, 230], 785: [, 230], 786: [, 230], 787: [, 230], 788: [, 230], 789: [, 232], 790: [, 220], 791: [, 220], 792: [, 220], 793: [, 220], 794: [, 232], 795: [, 216], 796: [, 220], 797: [, 220], 798: [, 220], 799: [, 220], 800: [, 220], 801: [, 202], 802: [, 202], 803: [, 220], 804: [, 220], 805: [, 220], 806: [, 220], 807: [, 202], 808: [, 202], 809: [, 220], 810: [, 220], 811: [, 220], 812: [, 220], 813: [, 220], 814: [, 220], 815: [, 220], 816: [, 220], 817: [, 220], 818: [, 220], 819: [, 220], 820: [, 1], 821: [, 1], 822: [, 1], 823: [, 1], 824: [, 1], 825: [, 220], 826: [, 220], 827: [, 220], 828: [, 220], 829: [, 230], 830: [, 230], 831: [, 230], 832: [[768], 230], 833: [[769], 230], 834: [, 230], 835: [[787], 230], 836: [[776, 769], 230], 837: [, 240], 838: [, 230], 839: [, 220], 840: [, 220], 841: [, 220], 842: [, 230], 843: [, 230], 844: [, 230], 845: [, 220], 846: [, 220], 848: [, 230], 849: [, 230], 850: [, 230], 851: [, 220], 852: [, 220], 853: [, 220], 854: [, 220], 855: [, 230], 856: [, 232], 857: [, 220], 858: [, 220], 859: [, 230], 860: [, 233], 861: [, 234], 862: [, 234], 863: [, 233], 864: [, 234], 865: [, 234], 866: [, 233], 867: [, 230], 868: [, 230], 869: [, 230], 870: [, 230], 871: [, 230], 872: [, 230], 873: [, 230], 874: [, 230], 875: [, 230], 876: [, 230], 877: [, 230], 878: [, 230], 879: [, 230], 884: [[697]], 890: [[32, 837], 256], 894: [[59]], 900: [[32, 769], 256], 901: [[168, 769]], 902: [[913, 769]], 903: [[183]], 904: [[917, 769]], 905: [[919, 769]], 906: [[921, 769]], 908: [[927, 769]], 910: [[933, 769]], 911: [[937, 769]], 912: [[970, 769]], 913: [, , { 768: 8122, 769: 902, 772: 8121, 774: 8120, 787: 7944, 788: 7945, 837: 8124 }], 917: [, , { 768: 8136, 769: 904, 787: 7960, 788: 7961 }], 919: [, , { 768: 8138, 769: 905, 787: 7976, 788: 7977, 837: 8140 }], 921: [, , { 768: 8154, 769: 906, 772: 8153, 774: 8152, 776: 938, 787: 7992, 788: 7993 }], 927: [, , { 768: 8184, 769: 908, 787: 8008, 788: 8009 }], 929: [, , { 788: 8172 }], 933: [, , { 768: 8170, 769: 910, 772: 8169, 774: 8168, 776: 939, 788: 8025 }], 937: [, , { 768: 8186, 769: 911, 787: 8040, 788: 8041, 837: 8188 }], 938: [[921, 776]], 939: [[933, 776]], 940: [[945, 769], , { 837: 8116 }], 941: [[949, 769]], 942: [[951, 769], , { 837: 8132 }], 943: [[953, 769]], 944: [[971, 769]], 945: [, , { 768: 8048, 769: 940, 772: 8113, 774: 8112, 787: 7936, 788: 7937, 834: 8118, 837: 8115 }], 949: [, , { 768: 8050, 769: 941, 787: 7952, 788: 7953 }], 951: [, , { 768: 8052, 769: 942, 787: 7968, 788: 7969, 834: 8134, 837: 8131 }], 953: [, , { 768: 8054, 769: 943, 772: 8145, 774: 8144, 776: 970, 787: 7984, 788: 7985, 834: 8150 }], 959: [, , { 768: 8056, 769: 972, 787: 8e3, 788: 8001 }], 961: [, , { 787: 8164, 788: 8165 }], 965: [, , { 768: 8058, 769: 973, 772: 8161, 774: 8160, 776: 971, 787: 8016, 788: 8017, 834: 8166 }], 969: [, , { 768: 8060, 769: 974, 787: 8032, 788: 8033, 834: 8182, 837: 8179 }], 970: [[953, 776], , { 768: 8146, 769: 912, 834: 8151 }], 971: [[965, 776], , { 768: 8162, 769: 944, 834: 8167 }], 972: [[959, 769]], 973: [[965, 769]], 974: [[969, 769], , { 837: 8180 }], 976: [[946], 256], 977: [[952], 256], 978: [[933], 256, { 769: 979, 776: 980 }], 979: [[978, 769]], 980: [[978, 776]], 981: [[966], 256], 982: [[960], 256], 1008: [[954], 256], 1009: [[961], 256], 1010: [[962], 256], 1012: [[920], 256], 1013: [[949], 256], 1017: [[931], 256], 66422: [, 230], 66423: [, 230], 66424: [, 230], 66425: [, 230], 66426: [, 230] },
        1024: { 1024: [[1045, 768]], 1025: [[1045, 776]], 1027: [[1043, 769]], 1030: [, , { 776: 1031 }], 1031: [[1030, 776]], 1036: [[1050, 769]], 1037: [[1048, 768]], 1038: [[1059, 774]], 1040: [, , { 774: 1232, 776: 1234 }], 1043: [, , { 769: 1027 }], 1045: [, , { 768: 1024, 774: 1238, 776: 1025 }], 1046: [, , { 774: 1217, 776: 1244 }], 1047: [, , { 776: 1246 }], 1048: [, , { 768: 1037, 772: 1250, 774: 1049, 776: 1252 }], 1049: [[1048, 774]], 1050: [, , { 769: 1036 }], 1054: [, , { 776: 1254 }], 1059: [, , { 772: 1262, 774: 1038, 776: 1264, 779: 1266 }], 1063: [, , { 776: 1268 }], 1067: [, , { 776: 1272 }], 1069: [, , { 776: 1260 }], 1072: [, , { 774: 1233, 776: 1235 }], 1075: [, , { 769: 1107 }], 1077: [, , { 768: 1104, 774: 1239, 776: 1105 }], 1078: [, , { 774: 1218, 776: 1245 }], 1079: [, , { 776: 1247 }], 1080: [, , { 768: 1117, 772: 1251, 774: 1081, 776: 1253 }], 1081: [[1080, 774]], 1082: [, , { 769: 1116 }], 1086: [, , { 776: 1255 }], 1091: [, , { 772: 1263, 774: 1118, 776: 1265, 779: 1267 }], 1095: [, , { 776: 1269 }], 1099: [, , { 776: 1273 }], 1101: [, , { 776: 1261 }], 1104: [[1077, 768]], 1105: [[1077, 776]], 1107: [[1075, 769]], 1110: [, , { 776: 1111 }], 1111: [[1110, 776]], 1116: [[1082, 769]], 1117: [[1080, 768]], 1118: [[1091, 774]], 1140: [, , { 783: 1142 }], 1141: [, , { 783: 1143 }], 1142: [[1140, 783]], 1143: [[1141, 783]], 1155: [, 230], 1156: [, 230], 1157: [, 230], 1158: [, 230], 1159: [, 230], 1217: [[1046, 774]], 1218: [[1078, 774]], 1232: [[1040, 774]], 1233: [[1072, 774]], 1234: [[1040, 776]], 1235: [[1072, 776]], 1238: [[1045, 774]], 1239: [[1077, 774]], 1240: [, , { 776: 1242 }], 1241: [, , { 776: 1243 }], 1242: [[1240, 776]], 1243: [[1241, 776]], 1244: [[1046, 776]], 1245: [[1078, 776]], 1246: [[1047, 776]], 1247: [[1079, 776]], 1250: [[1048, 772]], 1251: [[1080, 772]], 1252: [[1048, 776]], 1253: [[1080, 776]], 1254: [[1054, 776]], 1255: [[1086, 776]], 1256: [, , { 776: 1258 }], 1257: [, , { 776: 1259 }], 1258: [[1256, 776]], 1259: [[1257, 776]], 1260: [[1069, 776]], 1261: [[1101, 776]], 1262: [[1059, 772]], 1263: [[1091, 772]], 1264: [[1059, 776]], 1265: [[1091, 776]], 1266: [[1059, 779]], 1267: [[1091, 779]], 1268: [[1063, 776]], 1269: [[1095, 776]], 1272: [[1067, 776]], 1273: [[1099, 776]] },
        1280: { 1415: [[1381, 1410], 256], 1425: [, 220], 1426: [, 230], 1427: [, 230], 1428: [, 230], 1429: [, 230], 1430: [, 220], 1431: [, 230], 1432: [, 230], 1433: [, 230], 1434: [, 222], 1435: [, 220], 1436: [, 230], 1437: [, 230], 1438: [, 230], 1439: [, 230], 1440: [, 230], 1441: [, 230], 1442: [, 220], 1443: [, 220], 1444: [, 220], 1445: [, 220], 1446: [, 220], 1447: [, 220], 1448: [, 230], 1449: [, 230], 1450: [, 220], 1451: [, 230], 1452: [, 230], 1453: [, 222], 1454: [, 228], 1455: [, 230], 1456: [, 10], 1457: [, 11], 1458: [, 12], 1459: [, 13], 1460: [, 14], 1461: [, 15], 1462: [, 16], 1463: [, 17], 1464: [, 18], 1465: [, 19], 1466: [, 19], 1467: [, 20], 1468: [, 21], 1469: [, 22], 1471: [, 23], 1473: [, 24], 1474: [, 25], 1476: [, 230], 1477: [, 220], 1479: [, 18] },
        1536: { 1552: [, 230], 1553: [, 230], 1554: [, 230], 1555: [, 230], 1556: [, 230], 1557: [, 230], 1558: [, 230], 1559: [, 230], 1560: [, 30], 1561: [, 31], 1562: [, 32], 1570: [[1575, 1619]], 1571: [[1575, 1620]], 1572: [[1608, 1620]], 1573: [[1575, 1621]], 1574: [[1610, 1620]], 1575: [, , { 1619: 1570, 1620: 1571, 1621: 1573 }], 1608: [, , { 1620: 1572 }], 1610: [, , { 1620: 1574 }], 1611: [, 27], 1612: [, 28], 1613: [, 29], 1614: [, 30], 1615: [, 31], 1616: [, 32], 1617: [, 33], 1618: [, 34], 1619: [, 230], 1620: [, 230], 1621: [, 220], 1622: [, 220], 1623: [, 230], 1624: [, 230], 1625: [, 230], 1626: [, 230], 1627: [, 230], 1628: [, 220], 1629: [, 230], 1630: [, 230], 1631: [, 220], 1648: [, 35], 1653: [[1575, 1652], 256], 1654: [[1608, 1652], 256], 1655: [[1735, 1652], 256], 1656: [[1610, 1652], 256], 1728: [[1749, 1620]], 1729: [, , { 1620: 1730 }], 1730: [[1729, 1620]], 1746: [, , { 1620: 1747 }], 1747: [[1746, 1620]], 1749: [, , { 1620: 1728 }], 1750: [, 230], 1751: [, 230], 1752: [, 230], 1753: [, 230], 1754: [, 230], 1755: [, 230], 1756: [, 230], 1759: [, 230], 1760: [, 230], 1761: [, 230], 1762: [, 230], 1763: [, 220], 1764: [, 230], 1767: [, 230], 1768: [, 230], 1770: [, 220], 1771: [, 230], 1772: [, 230], 1773: [, 220] },
        1792: { 1809: [, 36], 1840: [, 230], 1841: [, 220], 1842: [, 230], 1843: [, 230], 1844: [, 220], 1845: [, 230], 1846: [, 230], 1847: [, 220], 1848: [, 220], 1849: [, 220], 1850: [, 230], 1851: [, 220], 1852: [, 220], 1853: [, 230], 1854: [, 220], 1855: [, 230], 1856: [, 230], 1857: [, 230], 1858: [, 220], 1859: [, 230], 1860: [, 220], 1861: [, 230], 1862: [, 220], 1863: [, 230], 1864: [, 220], 1865: [, 230], 1866: [, 230], 2027: [, 230], 2028: [, 230], 2029: [, 230], 2030: [, 230], 2031: [, 230], 2032: [, 230], 2033: [, 230], 2034: [, 220], 2035: [, 230] },
        2048: { 2070: [, 230], 2071: [, 230], 2072: [, 230], 2073: [, 230], 2075: [, 230], 2076: [, 230], 2077: [, 230], 2078: [, 230], 2079: [, 230], 2080: [, 230], 2081: [, 230], 2082: [, 230], 2083: [, 230], 2085: [, 230], 2086: [, 230], 2087: [, 230], 2089: [, 230], 2090: [, 230], 2091: [, 230], 2092: [, 230], 2093: [, 230], 2137: [, 220], 2138: [, 220], 2139: [, 220], 2276: [, 230], 2277: [, 230], 2278: [, 220], 2279: [, 230], 2280: [, 230], 2281: [, 220], 2282: [, 230], 2283: [, 230], 2284: [, 230], 2285: [, 220], 2286: [, 220], 2287: [, 220], 2288: [, 27], 2289: [, 28], 2290: [, 29], 2291: [, 230], 2292: [, 230], 2293: [, 230], 2294: [, 220], 2295: [, 230], 2296: [, 230], 2297: [, 220], 2298: [, 220], 2299: [, 230], 2300: [, 230], 2301: [, 230], 2302: [, 230], 2303: [, 230] },
        2304: { 2344: [, , { 2364: 2345 }], 2345: [[2344, 2364]], 2352: [, , { 2364: 2353 }], 2353: [[2352, 2364]], 2355: [, , { 2364: 2356 }], 2356: [[2355, 2364]], 2364: [, 7], 2381: [, 9], 2385: [, 230], 2386: [, 220], 2387: [, 230], 2388: [, 230], 2392: [[2325, 2364], 512], 2393: [[2326, 2364], 512], 2394: [[2327, 2364], 512], 2395: [[2332, 2364], 512], 2396: [[2337, 2364], 512], 2397: [[2338, 2364], 512], 2398: [[2347, 2364], 512], 2399: [[2351, 2364], 512], 2492: [, 7], 2503: [, , { 2494: 2507, 2519: 2508 }], 2507: [[2503, 2494]], 2508: [[2503, 2519]], 2509: [, 9], 2524: [[2465, 2492], 512], 2525: [[2466, 2492], 512], 2527: [[2479, 2492], 512] },
        2560: { 2611: [[2610, 2620], 512], 2614: [[2616, 2620], 512], 2620: [, 7], 2637: [, 9], 2649: [[2582, 2620], 512], 2650: [[2583, 2620], 512], 2651: [[2588, 2620], 512], 2654: [[2603, 2620], 512], 2748: [, 7], 2765: [, 9], 68109: [, 220], 68111: [, 230], 68152: [, 230], 68153: [, 1], 68154: [, 220], 68159: [, 9], 68325: [, 230], 68326: [, 220] },
        2816: { 2876: [, 7], 2887: [, , { 2878: 2891, 2902: 2888, 2903: 2892 }], 2888: [[2887, 2902]], 2891: [[2887, 2878]], 2892: [[2887, 2903]], 2893: [, 9], 2908: [[2849, 2876], 512], 2909: [[2850, 2876], 512], 2962: [, , { 3031: 2964 }], 2964: [[2962, 3031]], 3014: [, , { 3006: 3018, 3031: 3020 }], 3015: [, , { 3006: 3019 }], 3018: [[3014, 3006]], 3019: [[3015, 3006]], 3020: [[3014, 3031]], 3021: [, 9] },
        3072: { 3142: [, , { 3158: 3144 }], 3144: [[3142, 3158]], 3149: [, 9], 3157: [, 84], 3158: [, 91], 3260: [, 7], 3263: [, , { 3285: 3264 }], 3264: [[3263, 3285]], 3270: [, , { 3266: 3274, 3285: 3271, 3286: 3272 }], 3271: [[3270, 3285]], 3272: [[3270, 3286]], 3274: [[3270, 3266], , { 3285: 3275 }], 3275: [[3274, 3285]], 3277: [, 9] },
        3328: { 3398: [, , { 3390: 3402, 3415: 3404 }], 3399: [, , { 3390: 3403 }], 3402: [[3398, 3390]], 3403: [[3399, 3390]], 3404: [[3398, 3415]], 3405: [, 9], 3530: [, 9], 3545: [, , { 3530: 3546, 3535: 3548, 3551: 3550 }], 3546: [[3545, 3530]], 3548: [[3545, 3535], , { 3530: 3549 }], 3549: [[3548, 3530]], 3550: [[3545, 3551]] },
        3584: { 3635: [[3661, 3634], 256], 3640: [, 103], 3641: [, 103], 3642: [, 9], 3656: [, 107], 3657: [, 107], 3658: [, 107], 3659: [, 107], 3763: [[3789, 3762], 256], 3768: [, 118], 3769: [, 118], 3784: [, 122], 3785: [, 122], 3786: [, 122], 3787: [, 122], 3804: [[3755, 3737], 256], 3805: [[3755, 3745], 256] },
        3840: { 3852: [[3851], 256], 3864: [, 220], 3865: [, 220], 3893: [, 220], 3895: [, 220], 3897: [, 216], 3907: [[3906, 4023], 512], 3917: [[3916, 4023], 512], 3922: [[3921, 4023], 512], 3927: [[3926, 4023], 512], 3932: [[3931, 4023], 512], 3945: [[3904, 4021], 512], 3953: [, 129], 3954: [, 130], 3955: [[3953, 3954], 512], 3956: [, 132], 3957: [[3953, 3956], 512], 3958: [[4018, 3968], 512], 3959: [[4018, 3969], 256], 3960: [[4019, 3968], 512], 3961: [[4019, 3969], 256], 3962: [, 130], 3963: [, 130], 3964: [, 130], 3965: [, 130], 3968: [, 130], 3969: [[3953, 3968], 512], 3970: [, 230], 3971: [, 230], 3972: [, 9], 3974: [, 230], 3975: [, 230], 3987: [[3986, 4023], 512], 3997: [[3996, 4023], 512], 4002: [[4001, 4023], 512], 4007: [[4006, 4023], 512], 4012: [[4011, 4023], 512], 4025: [[3984, 4021], 512], 4038: [, 220] },
        4096: { 4133: [, , { 4142: 4134 }], 4134: [[4133, 4142]], 4151: [, 7], 4153: [, 9], 4154: [, 9], 4237: [, 220], 4348: [[4316], 256], 69702: [, 9], 69759: [, 9], 69785: [, , { 69818: 69786 }], 69786: [[69785, 69818]], 69787: [, , { 69818: 69788 }], 69788: [[69787, 69818]], 69797: [, , { 69818: 69803 }], 69803: [[69797, 69818]], 69817: [, 9], 69818: [, 7] },
        4352: { 69888: [, 230], 69889: [, 230], 69890: [, 230], 69934: [[69937, 69927]], 69935: [[69938, 69927]], 69937: [, , { 69927: 69934 }], 69938: [, , { 69927: 69935 }], 69939: [, 9], 69940: [, 9], 70003: [, 7], 70080: [, 9] },
        4608: { 70197: [, 9], 70198: [, 7], 70377: [, 7], 70378: [, 9] },
        4864: { 4957: [, 230], 4958: [, 230], 4959: [, 230], 70460: [, 7], 70471: [, , { 70462: 70475, 70487: 70476 }], 70475: [[70471, 70462]], 70476: [[70471, 70487]], 70477: [, 9], 70502: [, 230], 70503: [, 230], 70504: [, 230], 70505: [, 230], 70506: [, 230], 70507: [, 230], 70508: [, 230], 70512: [, 230], 70513: [, 230], 70514: [, 230], 70515: [, 230], 70516: [, 230] },
        5120: { 70841: [, , { 70832: 70844, 70842: 70843, 70845: 70846 }], 70843: [[70841, 70842]], 70844: [[70841, 70832]], 70846: [[70841, 70845]], 70850: [, 9], 70851: [, 7] },
        5376: { 71096: [, , { 71087: 71098 }], 71097: [, , { 71087: 71099 }], 71098: [[71096, 71087]], 71099: [[71097, 71087]], 71103: [, 9], 71104: [, 7] },
        5632: { 71231: [, 9], 71350: [, 9], 71351: [, 7] },
        5888: { 5908: [, 9], 5940: [, 9], 6098: [, 9], 6109: [, 230] },
        6144: { 6313: [, 228] },
        6400: { 6457: [, 222], 6458: [, 230], 6459: [, 220] },
        6656: { 6679: [, 230], 6680: [, 220], 6752: [, 9], 6773: [, 230], 6774: [, 230], 6775: [, 230], 6776: [, 230], 6777: [, 230], 6778: [, 230], 6779: [, 230], 6780: [, 230], 6783: [, 220], 6832: [, 230], 6833: [, 230], 6834: [, 230], 6835: [, 230], 6836: [, 230], 6837: [, 220], 6838: [, 220], 6839: [, 220], 6840: [, 220], 6841: [, 220], 6842: [, 220], 6843: [, 230], 6844: [, 230], 6845: [, 220] },
        6912: { 6917: [, , { 6965: 6918 }], 6918: [[6917, 6965]], 6919: [, , { 6965: 6920 }], 6920: [[6919, 6965]], 6921: [, , { 6965: 6922 }], 6922: [[6921, 6965]], 6923: [, , { 6965: 6924 }], 6924: [[6923, 6965]], 6925: [, , { 6965: 6926 }], 6926: [[6925, 6965]], 6929: [, , { 6965: 6930 }], 6930: [[6929, 6965]], 6964: [, 7], 6970: [, , { 6965: 6971 }], 6971: [[6970, 6965]], 6972: [, , { 6965: 6973 }], 6973: [[6972, 6965]], 6974: [, , { 6965: 6976 }], 6975: [, , { 6965: 6977 }], 6976: [[6974, 6965]], 6977: [[6975, 6965]], 6978: [, , { 6965: 6979 }], 6979: [[6978, 6965]], 6980: [, 9], 7019: [, 230], 7020: [, 220], 7021: [, 230], 7022: [, 230], 7023: [, 230], 7024: [, 230], 7025: [, 230], 7026: [, 230], 7027: [, 230], 7082: [, 9], 7083: [, 9], 7142: [, 7], 7154: [, 9], 7155: [, 9] },
        7168: { 7223: [, 7], 7376: [, 230], 7377: [, 230], 7378: [, 230], 7380: [, 1], 7381: [, 220], 7382: [, 220], 7383: [, 220], 7384: [, 220], 7385: [, 220], 7386: [, 230], 7387: [, 230], 7388: [, 220], 7389: [, 220], 7390: [, 220], 7391: [, 220], 7392: [, 230], 7394: [, 1], 7395: [, 1], 7396: [, 1], 7397: [, 1], 7398: [, 1], 7399: [, 1], 7400: [, 1], 7405: [, 220], 7412: [, 230], 7416: [, 230], 7417: [, 230] },
        7424: { 7468: [[65], 256], 7469: [[198], 256], 7470: [[66], 256], 7472: [[68], 256], 7473: [[69], 256], 7474: [[398], 256], 7475: [[71], 256], 7476: [[72], 256], 7477: [[73], 256], 7478: [[74], 256], 7479: [[75], 256], 7480: [[76], 256], 7481: [[77], 256], 7482: [[78], 256], 7484: [[79], 256], 7485: [[546], 256], 7486: [[80], 256], 7487: [[82], 256], 7488: [[84], 256], 7489: [[85], 256], 7490: [[87], 256], 7491: [[97], 256], 7492: [[592], 256], 7493: [[593], 256], 7494: [[7426], 256], 7495: [[98], 256], 7496: [[100], 256], 7497: [[101], 256], 7498: [[601], 256], 7499: [[603], 256], 7500: [[604], 256], 7501: [[103], 256], 7503: [[107], 256], 7504: [[109], 256], 7505: [[331], 256], 7506: [[111], 256], 7507: [[596], 256], 7508: [[7446], 256], 7509: [[7447], 256], 7510: [[112], 256], 7511: [[116], 256], 7512: [[117], 256], 7513: [[7453], 256], 7514: [[623], 256], 7515: [[118], 256], 7516: [[7461], 256], 7517: [[946], 256], 7518: [[947], 256], 7519: [[948], 256], 7520: [[966], 256], 7521: [[967], 256], 7522: [[105], 256], 7523: [[114], 256], 7524: [[117], 256], 7525: [[118], 256], 7526: [[946], 256], 7527: [[947], 256], 7528: [[961], 256], 7529: [[966], 256], 7530: [[967], 256], 7544: [[1085], 256], 7579: [[594], 256], 7580: [[99], 256], 7581: [[597], 256], 7582: [[240], 256], 7583: [[604], 256], 7584: [[102], 256], 7585: [[607], 256], 7586: [[609], 256], 7587: [[613], 256], 7588: [[616], 256], 7589: [[617], 256], 7590: [[618], 256], 7591: [[7547], 256], 7592: [[669], 256], 7593: [[621], 256], 7594: [[7557], 256], 7595: [[671], 256], 7596: [[625], 256], 7597: [[624], 256], 7598: [[626], 256], 7599: [[627], 256], 7600: [[628], 256], 7601: [[629], 256], 7602: [[632], 256], 7603: [[642], 256], 7604: [[643], 256], 7605: [[427], 256], 7606: [[649], 256], 7607: [[650], 256], 7608: [[7452], 256], 7609: [[651], 256], 7610: [[652], 256], 7611: [[122], 256], 7612: [[656], 256], 7613: [[657], 256], 7614: [[658], 256], 7615: [[952], 256], 7616: [, 230], 7617: [, 230], 7618: [, 220], 7619: [, 230], 7620: [, 230], 7621: [, 230], 7622: [, 230], 7623: [, 230], 7624: [, 230], 7625: [, 230], 7626: [, 220], 7627: [, 230], 7628: [, 230], 7629: [, 234], 7630: [, 214], 7631: [, 220], 7632: [, 202], 7633: [, 230], 7634: [, 230], 7635: [, 230], 7636: [, 230], 7637: [, 230], 7638: [, 230], 7639: [, 230], 7640: [, 230], 7641: [, 230], 7642: [, 230], 7643: [, 230], 7644: [, 230], 7645: [, 230], 7646: [, 230], 7647: [, 230], 7648: [, 230], 7649: [, 230], 7650: [, 230], 7651: [, 230], 7652: [, 230], 7653: [, 230], 7654: [, 230], 7655: [, 230], 7656: [, 230], 7657: [, 230], 7658: [, 230], 7659: [, 230], 7660: [, 230], 7661: [, 230], 7662: [, 230], 7663: [, 230], 7664: [, 230], 7665: [, 230], 7666: [, 230], 7667: [, 230], 7668: [, 230], 7669: [, 230], 7676: [, 233], 7677: [, 220], 7678: [, 230], 7679: [, 220] },
        7680: { 7680: [[65, 805]], 7681: [[97, 805]], 7682: [[66, 775]], 7683: [[98, 775]], 7684: [[66, 803]], 7685: [[98, 803]], 7686: [[66, 817]], 7687: [[98, 817]], 7688: [[199, 769]], 7689: [[231, 769]], 7690: [[68, 775]], 7691: [[100, 775]], 7692: [[68, 803]], 7693: [[100, 803]], 7694: [[68, 817]], 7695: [[100, 817]], 7696: [[68, 807]], 7697: [[100, 807]], 7698: [[68, 813]], 7699: [[100, 813]], 7700: [[274, 768]], 7701: [[275, 768]], 7702: [[274, 769]], 7703: [[275, 769]], 7704: [[69, 813]], 7705: [[101, 813]], 7706: [[69, 816]], 7707: [[101, 816]], 7708: [[552, 774]], 7709: [[553, 774]], 7710: [[70, 775]], 7711: [[102, 775]], 7712: [[71, 772]], 7713: [[103, 772]], 7714: [[72, 775]], 7715: [[104, 775]], 7716: [[72, 803]], 7717: [[104, 803]], 7718: [[72, 776]], 7719: [[104, 776]], 7720: [[72, 807]], 7721: [[104, 807]], 7722: [[72, 814]], 7723: [[104, 814]], 7724: [[73, 816]], 7725: [[105, 816]], 7726: [[207, 769]], 7727: [[239, 769]], 7728: [[75, 769]], 7729: [[107, 769]], 7730: [[75, 803]], 7731: [[107, 803]], 7732: [[75, 817]], 7733: [[107, 817]], 7734: [[76, 803], , { 772: 7736 }], 7735: [[108, 803], , { 772: 7737 }], 7736: [[7734, 772]], 7737: [[7735, 772]], 7738: [[76, 817]], 7739: [[108, 817]], 7740: [[76, 813]], 7741: [[108, 813]], 7742: [[77, 769]], 7743: [[109, 769]], 7744: [[77, 775]], 7745: [[109, 775]], 7746: [[77, 803]], 7747: [[109, 803]], 7748: [[78, 775]], 7749: [[110, 775]], 7750: [[78, 803]], 7751: [[110, 803]], 7752: [[78, 817]], 7753: [[110, 817]], 7754: [[78, 813]], 7755: [[110, 813]], 7756: [[213, 769]], 7757: [[245, 769]], 7758: [[213, 776]], 7759: [[245, 776]], 7760: [[332, 768]], 7761: [[333, 768]], 7762: [[332, 769]], 7763: [[333, 769]], 7764: [[80, 769]], 7765: [[112, 769]], 7766: [[80, 775]], 7767: [[112, 775]], 7768: [[82, 775]], 7769: [[114, 775]], 7770: [[82, 803], , { 772: 7772 }], 7771: [[114, 803], , { 772: 7773 }], 7772: [[7770, 772]], 7773: [[7771, 772]], 7774: [[82, 817]], 7775: [[114, 817]], 7776: [[83, 775]], 7777: [[115, 775]], 7778: [[83, 803], , { 775: 7784 }], 7779: [[115, 803], , { 775: 7785 }], 7780: [[346, 775]], 7781: [[347, 775]], 7782: [[352, 775]], 7783: [[353, 775]], 7784: [[7778, 775]], 7785: [[7779, 775]], 7786: [[84, 775]], 7787: [[116, 775]], 7788: [[84, 803]], 7789: [[116, 803]], 7790: [[84, 817]], 7791: [[116, 817]], 7792: [[84, 813]], 7793: [[116, 813]], 7794: [[85, 804]], 7795: [[117, 804]], 7796: [[85, 816]], 7797: [[117, 816]], 7798: [[85, 813]], 7799: [[117, 813]], 7800: [[360, 769]], 7801: [[361, 769]], 7802: [[362, 776]], 7803: [[363, 776]], 7804: [[86, 771]], 7805: [[118, 771]], 7806: [[86, 803]], 7807: [[118, 803]], 7808: [[87, 768]], 7809: [[119, 768]], 7810: [[87, 769]], 7811: [[119, 769]], 7812: [[87, 776]], 7813: [[119, 776]], 7814: [[87, 775]], 7815: [[119, 775]], 7816: [[87, 803]], 7817: [[119, 803]], 7818: [[88, 775]], 7819: [[120, 775]], 7820: [[88, 776]], 7821: [[120, 776]], 7822: [[89, 775]], 7823: [[121, 775]], 7824: [[90, 770]], 7825: [[122, 770]], 7826: [[90, 803]], 7827: [[122, 803]], 7828: [[90, 817]], 7829: [[122, 817]], 7830: [[104, 817]], 7831: [[116, 776]], 7832: [[119, 778]], 7833: [[121, 778]], 7834: [[97, 702], 256], 7835: [[383, 775]], 7840: [[65, 803], , { 770: 7852, 774: 7862 }], 7841: [[97, 803], , { 770: 7853, 774: 7863 }], 7842: [[65, 777]], 7843: [[97, 777]], 7844: [[194, 769]], 7845: [[226, 769]], 7846: [[194, 768]], 7847: [[226, 768]], 7848: [[194, 777]], 7849: [[226, 777]], 7850: [[194, 771]], 7851: [[226, 771]], 7852: [[7840, 770]], 7853: [[7841, 770]], 7854: [[258, 769]], 7855: [[259, 769]], 7856: [[258, 768]], 7857: [[259, 768]], 7858: [[258, 777]], 7859: [[259, 777]], 7860: [[258, 771]], 7861: [[259, 771]], 7862: [[7840, 774]], 7863: [[7841, 774]], 7864: [[69, 803], , { 770: 7878 }], 7865: [[101, 803], , { 770: 7879 }], 7866: [[69, 777]], 7867: [[101, 777]], 7868: [[69, 771]], 7869: [[101, 771]], 7870: [[202, 769]], 7871: [[234, 769]], 7872: [[202, 768]], 7873: [[234, 768]], 7874: [[202, 777]], 7875: [[234, 777]], 7876: [[202, 771]], 7877: [[234, 771]], 7878: [[7864, 770]], 7879: [[7865, 770]], 7880: [[73, 777]], 7881: [[105, 777]], 7882: [[73, 803]], 7883: [[105, 803]], 7884: [[79, 803], , { 770: 7896 }], 7885: [[111, 803], , { 770: 7897 }], 7886: [[79, 777]], 7887: [[111, 777]], 7888: [[212, 769]], 7889: [[244, 769]], 7890: [[212, 768]], 7891: [[244, 768]], 7892: [[212, 777]], 7893: [[244, 777]], 7894: [[212, 771]], 7895: [[244, 771]], 7896: [[7884, 770]], 7897: [[7885, 770]], 7898: [[416, 769]], 7899: [[417, 769]], 7900: [[416, 768]], 7901: [[417, 768]], 7902: [[416, 777]], 7903: [[417, 777]], 7904: [[416, 771]], 7905: [[417, 771]], 7906: [[416, 803]], 7907: [[417, 803]], 7908: [[85, 803]], 7909: [[117, 803]], 7910: [[85, 777]], 7911: [[117, 777]], 7912: [[431, 769]], 7913: [[432, 769]], 7914: [[431, 768]], 7915: [[432, 768]], 7916: [[431, 777]], 7917: [[432, 777]], 7918: [[431, 771]], 7919: [[432, 771]], 7920: [[431, 803]], 7921: [[432, 803]], 7922: [[89, 768]], 7923: [[121, 768]], 7924: [[89, 803]], 7925: [[121, 803]], 7926: [[89, 777]], 7927: [[121, 777]], 7928: [[89, 771]], 7929: [[121, 771]] },
        7936: { 7936: [[945, 787], , { 768: 7938, 769: 7940, 834: 7942, 837: 8064 }], 7937: [[945, 788], , { 768: 7939, 769: 7941, 834: 7943, 837: 8065 }], 7938: [[7936, 768], , { 837: 8066 }], 7939: [[7937, 768], , { 837: 8067 }], 7940: [[7936, 769], , { 837: 8068 }], 7941: [[7937, 769], , { 837: 8069 }], 7942: [[7936, 834], , { 837: 8070 }], 7943: [[7937, 834], , { 837: 8071 }], 7944: [[913, 787], , { 768: 7946, 769: 7948, 834: 7950, 837: 8072 }], 7945: [[913, 788], , { 768: 7947, 769: 7949, 834: 7951, 837: 8073 }], 7946: [[7944, 768], , { 837: 8074 }], 7947: [[7945, 768], , { 837: 8075 }], 7948: [[7944, 769], , { 837: 8076 }], 7949: [[7945, 769], , { 837: 8077 }], 7950: [[7944, 834], , { 837: 8078 }], 7951: [[7945, 834], , { 837: 8079 }], 7952: [[949, 787], , { 768: 7954, 769: 7956 }], 7953: [[949, 788], , { 768: 7955, 769: 7957 }], 7954: [[7952, 768]], 7955: [[7953, 768]], 7956: [[7952, 769]], 7957: [[7953, 769]], 7960: [[917, 787], , { 768: 7962, 769: 7964 }], 7961: [[917, 788], , { 768: 7963, 769: 7965 }], 7962: [[7960, 768]], 7963: [[7961, 768]], 7964: [[7960, 769]], 7965: [[7961, 769]], 7968: [[951, 787], , { 768: 7970, 769: 7972, 834: 7974, 837: 8080 }], 7969: [[951, 788], , { 768: 7971, 769: 7973, 834: 7975, 837: 8081 }], 7970: [[7968, 768], , { 837: 8082 }], 7971: [[7969, 768], , { 837: 8083 }], 7972: [[7968, 769], , { 837: 8084 }], 7973: [[7969, 769], , { 837: 8085 }], 7974: [[7968, 834], , { 837: 8086 }], 7975: [[7969, 834], , { 837: 8087 }], 7976: [[919, 787], , { 768: 7978, 769: 7980, 834: 7982, 837: 8088 }], 7977: [[919, 788], , { 768: 7979, 769: 7981, 834: 7983, 837: 8089 }], 7978: [[7976, 768], , { 837: 8090 }], 7979: [[7977, 768], , { 837: 8091 }], 7980: [[7976, 769], , { 837: 8092 }], 7981: [[7977, 769], , { 837: 8093 }], 7982: [[7976, 834], , { 837: 8094 }], 7983: [[7977, 834], , { 837: 8095 }], 7984: [[953, 787], , { 768: 7986, 769: 7988, 834: 7990 }], 7985: [[953, 788], , { 768: 7987, 769: 7989, 834: 7991 }], 7986: [[7984, 768]], 7987: [[7985, 768]], 7988: [[7984, 769]], 7989: [[7985, 769]], 7990: [[7984, 834]], 7991: [[7985, 834]], 7992: [[921, 787], , { 768: 7994, 769: 7996, 834: 7998 }], 7993: [[921, 788], , { 768: 7995, 769: 7997, 834: 7999 }], 7994: [[7992, 768]], 7995: [[7993, 768]], 7996: [[7992, 769]], 7997: [[7993, 769]], 7998: [[7992, 834]], 7999: [[7993, 834]], 8e3: [[959, 787], , { 768: 8002, 769: 8004 }], 8001: [[959, 788], , { 768: 8003, 769: 8005 }], 8002: [[8e3, 768]], 8003: [[8001, 768]], 8004: [[8e3, 769]], 8005: [[8001, 769]], 8008: [[927, 787], , { 768: 8010, 769: 8012 }], 8009: [[927, 788], , { 768: 8011, 769: 8013 }], 8010: [[8008, 768]], 8011: [[8009, 768]], 8012: [[8008, 769]], 8013: [[8009, 769]], 8016: [[965, 787], , { 768: 8018, 769: 8020, 834: 8022 }], 8017: [[965, 788], , { 768: 8019, 769: 8021, 834: 8023 }], 8018: [[8016, 768]], 8019: [[8017, 768]], 8020: [[8016, 769]], 8021: [[8017, 769]], 8022: [[8016, 834]], 8023: [[8017, 834]], 8025: [[933, 788], , { 768: 8027, 769: 8029, 834: 8031 }], 8027: [[8025, 768]], 8029: [[8025, 769]], 8031: [[8025, 834]], 8032: [[969, 787], , { 768: 8034, 769: 8036, 834: 8038, 837: 8096 }], 8033: [[969, 788], , { 768: 8035, 769: 8037, 834: 8039, 837: 8097 }], 8034: [[8032, 768], , { 837: 8098 }], 8035: [[8033, 768], , { 837: 8099 }], 8036: [[8032, 769], , { 837: 8100 }], 8037: [[8033, 769], , { 837: 8101 }], 8038: [[8032, 834], , { 837: 8102 }], 8039: [[8033, 834], , { 837: 8103 }], 8040: [[937, 787], , { 768: 8042, 769: 8044, 834: 8046, 837: 8104 }], 8041: [[937, 788], , { 768: 8043, 769: 8045, 834: 8047, 837: 8105 }], 8042: [[8040, 768], , { 837: 8106 }], 8043: [[8041, 768], , { 837: 8107 }], 8044: [[8040, 769], , { 837: 8108 }], 8045: [[8041, 769], , { 837: 8109 }], 8046: [[8040, 834], , { 837: 8110 }], 8047: [[8041, 834], , { 837: 8111 }], 8048: [[945, 768], , { 837: 8114 }], 8049: [[940]], 8050: [[949, 768]], 8051: [[941]], 8052: [[951, 768], , { 837: 8130 }], 8053: [[942]], 8054: [[953, 768]], 8055: [[943]], 8056: [[959, 768]], 8057: [[972]], 8058: [[965, 768]], 8059: [[973]], 8060: [[969, 768], , { 837: 8178 }], 8061: [[974]], 8064: [[7936, 837]], 8065: [[7937, 837]], 8066: [[7938, 837]], 8067: [[7939, 837]], 8068: [[7940, 837]], 8069: [[7941, 837]], 8070: [[7942, 837]], 8071: [[7943, 837]], 8072: [[7944, 837]], 8073: [[7945, 837]], 8074: [[7946, 837]], 8075: [[7947, 837]], 8076: [[7948, 837]], 8077: [[7949, 837]], 8078: [[7950, 837]], 8079: [[7951, 837]], 8080: [[7968, 837]], 8081: [[7969, 837]], 8082: [[7970, 837]], 8083: [[7971, 837]], 8084: [[7972, 837]], 8085: [[7973, 837]], 8086: [[7974, 837]], 8087: [[7975, 837]], 8088: [[7976, 837]], 8089: [[7977, 837]], 8090: [[7978, 837]], 8091: [[7979, 837]], 8092: [[7980, 837]], 8093: [[7981, 837]], 8094: [[7982, 837]], 8095: [[7983, 837]], 8096: [[8032, 837]], 8097: [[8033, 837]], 8098: [[8034, 837]], 8099: [[8035, 837]], 8100: [[8036, 837]], 8101: [[8037, 837]], 8102: [[8038, 837]], 8103: [[8039, 837]], 8104: [[8040, 837]], 8105: [[8041, 837]], 8106: [[8042, 837]], 8107: [[8043, 837]], 8108: [[8044, 837]], 8109: [[8045, 837]], 8110: [[8046, 837]], 8111: [[8047, 837]], 8112: [[945, 774]], 8113: [[945, 772]], 8114: [[8048, 837]], 8115: [[945, 837]], 8116: [[940, 837]], 8118: [[945, 834], , { 837: 8119 }], 8119: [[8118, 837]], 8120: [[913, 774]], 8121: [[913, 772]], 8122: [[913, 768]], 8123: [[902]], 8124: [[913, 837]], 8125: [[32, 787], 256], 8126: [[953]], 8127: [[32, 787], 256, { 768: 8141, 769: 8142, 834: 8143 }], 8128: [[32, 834], 256], 8129: [[168, 834]], 8130: [[8052, 837]], 8131: [[951, 837]], 8132: [[942, 837]], 8134: [[951, 834], , { 837: 8135 }], 8135: [[8134, 837]], 8136: [[917, 768]], 8137: [[904]], 8138: [[919, 768]], 8139: [[905]], 8140: [[919, 837]], 8141: [[8127, 768]], 8142: [[8127, 769]], 8143: [[8127, 834]], 8144: [[953, 774]], 8145: [[953, 772]], 8146: [[970, 768]], 8147: [[912]], 8150: [[953, 834]], 8151: [[970, 834]], 8152: [[921, 774]], 8153: [[921, 772]], 8154: [[921, 768]], 8155: [[906]], 8157: [[8190, 768]], 8158: [[8190, 769]], 8159: [[8190, 834]], 8160: [[965, 774]], 8161: [[965, 772]], 8162: [[971, 768]], 8163: [[944]], 8164: [[961, 787]], 8165: [[961, 788]], 8166: [[965, 834]], 8167: [[971, 834]], 8168: [[933, 774]], 8169: [[933, 772]], 8170: [[933, 768]], 8171: [[910]], 8172: [[929, 788]], 8173: [[168, 768]], 8174: [[901]], 8175: [[96]], 8178: [[8060, 837]], 8179: [[969, 837]], 8180: [[974, 837]], 8182: [[969, 834], , { 837: 8183 }], 8183: [[8182, 837]], 8184: [[927, 768]], 8185: [[908]], 8186: [[937, 768]], 8187: [[911]], 8188: [[937, 837]], 8189: [[180]], 8190: [[32, 788], 256, { 768: 8157, 769: 8158, 834: 8159 }] },
        8192: { 8192: [[8194]], 8193: [[8195]], 8194: [[32], 256], 8195: [[32], 256], 8196: [[32], 256], 8197: [[32], 256], 8198: [[32], 256], 8199: [[32], 256], 8200: [[32], 256], 8201: [[32], 256], 8202: [[32], 256], 8209: [[8208], 256], 8215: [[32, 819], 256], 8228: [[46], 256], 8229: [[46, 46], 256], 8230: [[46, 46, 46], 256], 8239: [[32], 256], 8243: [[8242, 8242], 256], 8244: [[8242, 8242, 8242], 256], 8246: [[8245, 8245], 256], 8247: [[8245, 8245, 8245], 256], 8252: [[33, 33], 256], 8254: [[32, 773], 256], 8263: [[63, 63], 256], 8264: [[63, 33], 256], 8265: [[33, 63], 256], 8279: [[8242, 8242, 8242, 8242], 256], 8287: [[32], 256], 8304: [[48], 256], 8305: [[105], 256], 8308: [[52], 256], 8309: [[53], 256], 8310: [[54], 256], 8311: [[55], 256], 8312: [[56], 256], 8313: [[57], 256], 8314: [[43], 256], 8315: [[8722], 256], 8316: [[61], 256], 8317: [[40], 256], 8318: [[41], 256], 8319: [[110], 256], 8320: [[48], 256], 8321: [[49], 256], 8322: [[50], 256], 8323: [[51], 256], 8324: [[52], 256], 8325: [[53], 256], 8326: [[54], 256], 8327: [[55], 256], 8328: [[56], 256], 8329: [[57], 256], 8330: [[43], 256], 8331: [[8722], 256], 8332: [[61], 256], 8333: [[40], 256], 8334: [[41], 256], 8336: [[97], 256], 8337: [[101], 256], 8338: [[111], 256], 8339: [[120], 256], 8340: [[601], 256], 8341: [[104], 256], 8342: [[107], 256], 8343: [[108], 256], 8344: [[109], 256], 8345: [[110], 256], 8346: [[112], 256], 8347: [[115], 256], 8348: [[116], 256], 8360: [[82, 115], 256], 8400: [, 230], 8401: [, 230], 8402: [, 1], 8403: [, 1], 8404: [, 230], 8405: [, 230], 8406: [, 230], 8407: [, 230], 8408: [, 1], 8409: [, 1], 8410: [, 1], 8411: [, 230], 8412: [, 230], 8417: [, 230], 8421: [, 1], 8422: [, 1], 8423: [, 230], 8424: [, 220], 8425: [, 230], 8426: [, 1], 8427: [, 1], 8428: [, 220], 8429: [, 220], 8430: [, 220], 8431: [, 220], 8432: [, 230] },
        8448: { 8448: [[97, 47, 99], 256], 8449: [[97, 47, 115], 256], 8450: [[67], 256], 8451: [[176, 67], 256], 8453: [[99, 47, 111], 256], 8454: [[99, 47, 117], 256], 8455: [[400], 256], 8457: [[176, 70], 256], 8458: [[103], 256], 8459: [[72], 256], 8460: [[72], 256], 8461: [[72], 256], 8462: [[104], 256], 8463: [[295], 256], 8464: [[73], 256], 8465: [[73], 256], 8466: [[76], 256], 8467: [[108], 256], 8469: [[78], 256], 8470: [[78, 111], 256], 8473: [[80], 256], 8474: [[81], 256], 8475: [[82], 256], 8476: [[82], 256], 8477: [[82], 256], 8480: [[83, 77], 256], 8481: [[84, 69, 76], 256], 8482: [[84, 77], 256], 8484: [[90], 256], 8486: [[937]], 8488: [[90], 256], 8490: [[75]], 8491: [[197]], 8492: [[66], 256], 8493: [[67], 256], 8495: [[101], 256], 8496: [[69], 256], 8497: [[70], 256], 8499: [[77], 256], 8500: [[111], 256], 8501: [[1488], 256], 8502: [[1489], 256], 8503: [[1490], 256], 8504: [[1491], 256], 8505: [[105], 256], 8507: [[70, 65, 88], 256], 8508: [[960], 256], 8509: [[947], 256], 8510: [[915], 256], 8511: [[928], 256], 8512: [[8721], 256], 8517: [[68], 256], 8518: [[100], 256], 8519: [[101], 256], 8520: [[105], 256], 8521: [[106], 256], 8528: [[49, 8260, 55], 256], 8529: [[49, 8260, 57], 256], 8530: [[49, 8260, 49, 48], 256], 8531: [[49, 8260, 51], 256], 8532: [[50, 8260, 51], 256], 8533: [[49, 8260, 53], 256], 8534: [[50, 8260, 53], 256], 8535: [[51, 8260, 53], 256], 8536: [[52, 8260, 53], 256], 8537: [[49, 8260, 54], 256], 8538: [[53, 8260, 54], 256], 8539: [[49, 8260, 56], 256], 8540: [[51, 8260, 56], 256], 8541: [[53, 8260, 56], 256], 8542: [[55, 8260, 56], 256], 8543: [[49, 8260], 256], 8544: [[73], 256], 8545: [[73, 73], 256], 8546: [[73, 73, 73], 256], 8547: [[73, 86], 256], 8548: [[86], 256], 8549: [[86, 73], 256], 8550: [[86, 73, 73], 256], 8551: [[86, 73, 73, 73], 256], 8552: [[73, 88], 256], 8553: [[88], 256], 8554: [[88, 73], 256], 8555: [[88, 73, 73], 256], 8556: [[76], 256], 8557: [[67], 256], 8558: [[68], 256], 8559: [[77], 256], 8560: [[105], 256], 8561: [[105, 105], 256], 8562: [[105, 105, 105], 256], 8563: [[105, 118], 256], 8564: [[118], 256], 8565: [[118, 105], 256], 8566: [[118, 105, 105], 256], 8567: [[118, 105, 105, 105], 256], 8568: [[105, 120], 256], 8569: [[120], 256], 8570: [[120, 105], 256], 8571: [[120, 105, 105], 256], 8572: [[108], 256], 8573: [[99], 256], 8574: [[100], 256], 8575: [[109], 256], 8585: [[48, 8260, 51], 256], 8592: [, , { 824: 8602 }], 8594: [, , { 824: 8603 }], 8596: [, , { 824: 8622 }], 8602: [[8592, 824]], 8603: [[8594, 824]], 8622: [[8596, 824]], 8653: [[8656, 824]], 8654: [[8660, 824]], 8655: [[8658, 824]], 8656: [, , { 824: 8653 }], 8658: [, , { 824: 8655 }], 8660: [, , { 824: 8654 }] },
        8704: { 8707: [, , { 824: 8708 }], 8708: [[8707, 824]], 8712: [, , { 824: 8713 }], 8713: [[8712, 824]], 8715: [, , { 824: 8716 }], 8716: [[8715, 824]], 8739: [, , { 824: 8740 }], 8740: [[8739, 824]], 8741: [, , { 824: 8742 }], 8742: [[8741, 824]], 8748: [[8747, 8747], 256], 8749: [[8747, 8747, 8747], 256], 8751: [[8750, 8750], 256], 8752: [[8750, 8750, 8750], 256], 8764: [, , { 824: 8769 }], 8769: [[8764, 824]], 8771: [, , { 824: 8772 }], 8772: [[8771, 824]], 8773: [, , { 824: 8775 }], 8775: [[8773, 824]], 8776: [, , { 824: 8777 }], 8777: [[8776, 824]], 8781: [, , { 824: 8813 }], 8800: [[61, 824]], 8801: [, , { 824: 8802 }], 8802: [[8801, 824]], 8804: [, , { 824: 8816 }], 8805: [, , { 824: 8817 }], 8813: [[8781, 824]], 8814: [[60, 824]], 8815: [[62, 824]], 8816: [[8804, 824]], 8817: [[8805, 824]], 8818: [, , { 824: 8820 }], 8819: [, , { 824: 8821 }], 8820: [[8818, 824]], 8821: [[8819, 824]], 8822: [, , { 824: 8824 }], 8823: [, , { 824: 8825 }], 8824: [[8822, 824]], 8825: [[8823, 824]], 8826: [, , { 824: 8832 }], 8827: [, , { 824: 8833 }], 8828: [, , { 824: 8928 }], 8829: [, , { 824: 8929 }], 8832: [[8826, 824]], 8833: [[8827, 824]], 8834: [, , { 824: 8836 }], 8835: [, , { 824: 8837 }], 8836: [[8834, 824]], 8837: [[8835, 824]], 8838: [, , { 824: 8840 }], 8839: [, , { 824: 8841 }], 8840: [[8838, 824]], 8841: [[8839, 824]], 8849: [, , { 824: 8930 }], 8850: [, , { 824: 8931 }], 8866: [, , { 824: 8876 }], 8872: [, , { 824: 8877 }], 8873: [, , { 824: 8878 }], 8875: [, , { 824: 8879 }], 8876: [[8866, 824]], 8877: [[8872, 824]], 8878: [[8873, 824]], 8879: [[8875, 824]], 8882: [, , { 824: 8938 }], 8883: [, , { 824: 8939 }], 8884: [, , { 824: 8940 }], 8885: [, , { 824: 8941 }], 8928: [[8828, 824]], 8929: [[8829, 824]], 8930: [[8849, 824]], 8931: [[8850, 824]], 8938: [[8882, 824]], 8939: [[8883, 824]], 8940: [[8884, 824]], 8941: [[8885, 824]] },
        8960: { 9001: [[12296]], 9002: [[12297]] },
        9216: { 9312: [[49], 256], 9313: [[50], 256], 9314: [[51], 256], 9315: [[52], 256], 9316: [[53], 256], 9317: [[54], 256], 9318: [[55], 256], 9319: [[56], 256], 9320: [[57], 256], 9321: [[49, 48], 256], 9322: [[49, 49], 256], 9323: [[49, 50], 256], 9324: [[49, 51], 256], 9325: [[49, 52], 256], 9326: [[49, 53], 256], 9327: [[49, 54], 256], 9328: [[49, 55], 256], 9329: [[49, 56], 256], 9330: [[49, 57], 256], 9331: [[50, 48], 256], 9332: [[40, 49, 41], 256], 9333: [[40, 50, 41], 256], 9334: [[40, 51, 41], 256], 9335: [[40, 52, 41], 256], 9336: [[40, 53, 41], 256], 9337: [[40, 54, 41], 256], 9338: [[40, 55, 41], 256], 9339: [[40, 56, 41], 256], 9340: [[40, 57, 41], 256], 9341: [[40, 49, 48, 41], 256], 9342: [[40, 49, 49, 41], 256], 9343: [[40, 49, 50, 41], 256], 9344: [[40, 49, 51, 41], 256], 9345: [[40, 49, 52, 41], 256], 9346: [[40, 49, 53, 41], 256], 9347: [[40, 49, 54, 41], 256], 9348: [[40, 49, 55, 41], 256], 9349: [[40, 49, 56, 41], 256], 9350: [[40, 49, 57, 41], 256], 9351: [[40, 50, 48, 41], 256], 9352: [[49, 46], 256], 9353: [[50, 46], 256], 9354: [[51, 46], 256], 9355: [[52, 46], 256], 9356: [[53, 46], 256], 9357: [[54, 46], 256], 9358: [[55, 46], 256], 9359: [[56, 46], 256], 9360: [[57, 46], 256], 9361: [[49, 48, 46], 256], 9362: [[49, 49, 46], 256], 9363: [[49, 50, 46], 256], 9364: [[49, 51, 46], 256], 9365: [[49, 52, 46], 256], 9366: [[49, 53, 46], 256], 9367: [[49, 54, 46], 256], 9368: [[49, 55, 46], 256], 9369: [[49, 56, 46], 256], 9370: [[49, 57, 46], 256], 9371: [[50, 48, 46], 256], 9372: [[40, 97, 41], 256], 9373: [[40, 98, 41], 256], 9374: [[40, 99, 41], 256], 9375: [[40, 100, 41], 256], 9376: [[40, 101, 41], 256], 9377: [[40, 102, 41], 256], 9378: [[40, 103, 41], 256], 9379: [[40, 104, 41], 256], 9380: [[40, 105, 41], 256], 9381: [[40, 106, 41], 256], 9382: [[40, 107, 41], 256], 9383: [[40, 108, 41], 256], 9384: [[40, 109, 41], 256], 9385: [[40, 110, 41], 256], 9386: [[40, 111, 41], 256], 9387: [[40, 112, 41], 256], 9388: [[40, 113, 41], 256], 9389: [[40, 114, 41], 256], 9390: [[40, 115, 41], 256], 9391: [[40, 116, 41], 256], 9392: [[40, 117, 41], 256], 9393: [[40, 118, 41], 256], 9394: [[40, 119, 41], 256], 9395: [[40, 120, 41], 256], 9396: [[40, 121, 41], 256], 9397: [[40, 122, 41], 256], 9398: [[65], 256], 9399: [[66], 256], 9400: [[67], 256], 9401: [[68], 256], 9402: [[69], 256], 9403: [[70], 256], 9404: [[71], 256], 9405: [[72], 256], 9406: [[73], 256], 9407: [[74], 256], 9408: [[75], 256], 9409: [[76], 256], 9410: [[77], 256], 9411: [[78], 256], 9412: [[79], 256], 9413: [[80], 256], 9414: [[81], 256], 9415: [[82], 256], 9416: [[83], 256], 9417: [[84], 256], 9418: [[85], 256], 9419: [[86], 256], 9420: [[87], 256], 9421: [[88], 256], 9422: [[89], 256], 9423: [[90], 256], 9424: [[97], 256], 9425: [[98], 256], 9426: [[99], 256], 9427: [[100], 256], 9428: [[101], 256], 9429: [[102], 256], 9430: [[103], 256], 9431: [[104], 256], 9432: [[105], 256], 9433: [[106], 256], 9434: [[107], 256], 9435: [[108], 256], 9436: [[109], 256], 9437: [[110], 256], 9438: [[111], 256], 9439: [[112], 256], 9440: [[113], 256], 9441: [[114], 256], 9442: [[115], 256], 9443: [[116], 256], 9444: [[117], 256], 9445: [[118], 256], 9446: [[119], 256], 9447: [[120], 256], 9448: [[121], 256], 9449: [[122], 256], 9450: [[48], 256] },
        10752: { 10764: [[8747, 8747, 8747, 8747], 256], 10868: [[58, 58, 61], 256], 10869: [[61, 61], 256], 10870: [[61, 61, 61], 256], 10972: [[10973, 824], 512] },
        11264: { 11388: [[106], 256], 11389: [[86], 256], 11503: [, 230], 11504: [, 230], 11505: [, 230] },
        11520: { 11631: [[11617], 256], 11647: [, 9], 11744: [, 230], 11745: [, 230], 11746: [, 230], 11747: [, 230], 11748: [, 230], 11749: [, 230], 11750: [, 230], 11751: [, 230], 11752: [, 230], 11753: [, 230], 11754: [, 230], 11755: [, 230], 11756: [, 230], 11757: [, 230], 11758: [, 230], 11759: [, 230], 11760: [, 230], 11761: [, 230], 11762: [, 230], 11763: [, 230], 11764: [, 230], 11765: [, 230], 11766: [, 230], 11767: [, 230], 11768: [, 230], 11769: [, 230], 11770: [, 230], 11771: [, 230], 11772: [, 230], 11773: [, 230], 11774: [, 230], 11775: [, 230] },
        11776: { 11935: [[27597], 256], 12019: [[40863], 256] },
        12032: { 12032: [[19968], 256], 12033: [[20008], 256], 12034: [[20022], 256], 12035: [[20031], 256], 12036: [[20057], 256], 12037: [[20101], 256], 12038: [[20108], 256], 12039: [[20128], 256], 12040: [[20154], 256], 12041: [[20799], 256], 12042: [[20837], 256], 12043: [[20843], 256], 12044: [[20866], 256], 12045: [[20886], 256], 12046: [[20907], 256], 12047: [[20960], 256], 12048: [[20981], 256], 12049: [[20992], 256], 12050: [[21147], 256], 12051: [[21241], 256], 12052: [[21269], 256], 12053: [[21274], 256], 12054: [[21304], 256], 12055: [[21313], 256], 12056: [[21340], 256], 12057: [[21353], 256], 12058: [[21378], 256], 12059: [[21430], 256], 12060: [[21448], 256], 12061: [[21475], 256], 12062: [[22231], 256], 12063: [[22303], 256], 12064: [[22763], 256], 12065: [[22786], 256], 12066: [[22794], 256], 12067: [[22805], 256], 12068: [[22823], 256], 12069: [[22899], 256], 12070: [[23376], 256], 12071: [[23424], 256], 12072: [[23544], 256], 12073: [[23567], 256], 12074: [[23586], 256], 12075: [[23608], 256], 12076: [[23662], 256], 12077: [[23665], 256], 12078: [[24027], 256], 12079: [[24037], 256], 12080: [[24049], 256], 12081: [[24062], 256], 12082: [[24178], 256], 12083: [[24186], 256], 12084: [[24191], 256], 12085: [[24308], 256], 12086: [[24318], 256], 12087: [[24331], 256], 12088: [[24339], 256], 12089: [[24400], 256], 12090: [[24417], 256], 12091: [[24435], 256], 12092: [[24515], 256], 12093: [[25096], 256], 12094: [[25142], 256], 12095: [[25163], 256], 12096: [[25903], 256], 12097: [[25908], 256], 12098: [[25991], 256], 12099: [[26007], 256], 12100: [[26020], 256], 12101: [[26041], 256], 12102: [[26080], 256], 12103: [[26085], 256], 12104: [[26352], 256], 12105: [[26376], 256], 12106: [[26408], 256], 12107: [[27424], 256], 12108: [[27490], 256], 12109: [[27513], 256], 12110: [[27571], 256], 12111: [[27595], 256], 12112: [[27604], 256], 12113: [[27611], 256], 12114: [[27663], 256], 12115: [[27668], 256], 12116: [[27700], 256], 12117: [[28779], 256], 12118: [[29226], 256], 12119: [[29238], 256], 12120: [[29243], 256], 12121: [[29247], 256], 12122: [[29255], 256], 12123: [[29273], 256], 12124: [[29275], 256], 12125: [[29356], 256], 12126: [[29572], 256], 12127: [[29577], 256], 12128: [[29916], 256], 12129: [[29926], 256], 12130: [[29976], 256], 12131: [[29983], 256], 12132: [[29992], 256], 12133: [[3e4], 256], 12134: [[30091], 256], 12135: [[30098], 256], 12136: [[30326], 256], 12137: [[30333], 256], 12138: [[30382], 256], 12139: [[30399], 256], 12140: [[30446], 256], 12141: [[30683], 256], 12142: [[30690], 256], 12143: [[30707], 256], 12144: [[31034], 256], 12145: [[31160], 256], 12146: [[31166], 256], 12147: [[31348], 256], 12148: [[31435], 256], 12149: [[31481], 256], 12150: [[31859], 256], 12151: [[31992], 256], 12152: [[32566], 256], 12153: [[32593], 256], 12154: [[32650], 256], 12155: [[32701], 256], 12156: [[32769], 256], 12157: [[32780], 256], 12158: [[32786], 256], 12159: [[32819], 256], 12160: [[32895], 256], 12161: [[32905], 256], 12162: [[33251], 256], 12163: [[33258], 256], 12164: [[33267], 256], 12165: [[33276], 256], 12166: [[33292], 256], 12167: [[33307], 256], 12168: [[33311], 256], 12169: [[33390], 256], 12170: [[33394], 256], 12171: [[33400], 256], 12172: [[34381], 256], 12173: [[34411], 256], 12174: [[34880], 256], 12175: [[34892], 256], 12176: [[34915], 256], 12177: [[35198], 256], 12178: [[35211], 256], 12179: [[35282], 256], 12180: [[35328], 256], 12181: [[35895], 256], 12182: [[35910], 256], 12183: [[35925], 256], 12184: [[35960], 256], 12185: [[35997], 256], 12186: [[36196], 256], 12187: [[36208], 256], 12188: [[36275], 256], 12189: [[36523], 256], 12190: [[36554], 256], 12191: [[36763], 256], 12192: [[36784], 256], 12193: [[36789], 256], 12194: [[37009], 256], 12195: [[37193], 256], 12196: [[37318], 256], 12197: [[37324], 256], 12198: [[37329], 256], 12199: [[38263], 256], 12200: [[38272], 256], 12201: [[38428], 256], 12202: [[38582], 256], 12203: [[38585], 256], 12204: [[38632], 256], 12205: [[38737], 256], 12206: [[38750], 256], 12207: [[38754], 256], 12208: [[38761], 256], 12209: [[38859], 256], 12210: [[38893], 256], 12211: [[38899], 256], 12212: [[38913], 256], 12213: [[39080], 256], 12214: [[39131], 256], 12215: [[39135], 256], 12216: [[39318], 256], 12217: [[39321], 256], 12218: [[39340], 256], 12219: [[39592], 256], 12220: [[39640], 256], 12221: [[39647], 256], 12222: [[39717], 256], 12223: [[39727], 256], 12224: [[39730], 256], 12225: [[39740], 256], 12226: [[39770], 256], 12227: [[40165], 256], 12228: [[40565], 256], 12229: [[40575], 256], 12230: [[40613], 256], 12231: [[40635], 256], 12232: [[40643], 256], 12233: [[40653], 256], 12234: [[40657], 256], 12235: [[40697], 256], 12236: [[40701], 256], 12237: [[40718], 256], 12238: [[40723], 256], 12239: [[40736], 256], 12240: [[40763], 256], 12241: [[40778], 256], 12242: [[40786], 256], 12243: [[40845], 256], 12244: [[40860], 256], 12245: [[40864], 256] },
        12288: { 12288: [[32], 256], 12330: [, 218], 12331: [, 228], 12332: [, 232], 12333: [, 222], 12334: [, 224], 12335: [, 224], 12342: [[12306], 256], 12344: [[21313], 256], 12345: [[21316], 256], 12346: [[21317], 256], 12358: [, , { 12441: 12436 }], 12363: [, , { 12441: 12364 }], 12364: [[12363, 12441]], 12365: [, , { 12441: 12366 }], 12366: [[12365, 12441]], 12367: [, , { 12441: 12368 }], 12368: [[12367, 12441]], 12369: [, , { 12441: 12370 }], 12370: [[12369, 12441]], 12371: [, , { 12441: 12372 }], 12372: [[12371, 12441]], 12373: [, , { 12441: 12374 }], 12374: [[12373, 12441]], 12375: [, , { 12441: 12376 }], 12376: [[12375, 12441]], 12377: [, , { 12441: 12378 }], 12378: [[12377, 12441]], 12379: [, , { 12441: 12380 }], 12380: [[12379, 12441]], 12381: [, , { 12441: 12382 }], 12382: [[12381, 12441]], 12383: [, , { 12441: 12384 }], 12384: [[12383, 12441]], 12385: [, , { 12441: 12386 }], 12386: [[12385, 12441]], 12388: [, , { 12441: 12389 }], 12389: [[12388, 12441]], 12390: [, , { 12441: 12391 }], 12391: [[12390, 12441]], 12392: [, , { 12441: 12393 }], 12393: [[12392, 12441]], 12399: [, , { 12441: 12400, 12442: 12401 }], 12400: [[12399, 12441]], 12401: [[12399, 12442]], 12402: [, , { 12441: 12403, 12442: 12404 }], 12403: [[12402, 12441]], 12404: [[12402, 12442]], 12405: [, , { 12441: 12406, 12442: 12407 }], 12406: [[12405, 12441]], 12407: [[12405, 12442]], 12408: [, , { 12441: 12409, 12442: 12410 }], 12409: [[12408, 12441]], 12410: [[12408, 12442]], 12411: [, , { 12441: 12412, 12442: 12413 }], 12412: [[12411, 12441]], 12413: [[12411, 12442]], 12436: [[12358, 12441]], 12441: [, 8], 12442: [, 8], 12443: [[32, 12441], 256], 12444: [[32, 12442], 256], 12445: [, , { 12441: 12446 }], 12446: [[12445, 12441]], 12447: [[12424, 12426], 256], 12454: [, , { 12441: 12532 }], 12459: [, , { 12441: 12460 }], 12460: [[12459, 12441]], 12461: [, , { 12441: 12462 }], 12462: [[12461, 12441]], 12463: [, , { 12441: 12464 }], 12464: [[12463, 12441]], 12465: [, , { 12441: 12466 }], 12466: [[12465, 12441]], 12467: [, , { 12441: 12468 }], 12468: [[12467, 12441]], 12469: [, , { 12441: 12470 }], 12470: [[12469, 12441]], 12471: [, , { 12441: 12472 }], 12472: [[12471, 12441]], 12473: [, , { 12441: 12474 }], 12474: [[12473, 12441]], 12475: [, , { 12441: 12476 }], 12476: [[12475, 12441]], 12477: [, , { 12441: 12478 }], 12478: [[12477, 12441]], 12479: [, , { 12441: 12480 }], 12480: [[12479, 12441]], 12481: [, , { 12441: 12482 }], 12482: [[12481, 12441]], 12484: [, , { 12441: 12485 }], 12485: [[12484, 12441]], 12486: [, , { 12441: 12487 }], 12487: [[12486, 12441]], 12488: [, , { 12441: 12489 }], 12489: [[12488, 12441]], 12495: [, , { 12441: 12496, 12442: 12497 }], 12496: [[12495, 12441]], 12497: [[12495, 12442]], 12498: [, , { 12441: 12499, 12442: 12500 }], 12499: [[12498, 12441]], 12500: [[12498, 12442]], 12501: [, , { 12441: 12502, 12442: 12503 }], 12502: [[12501, 12441]], 12503: [[12501, 12442]], 12504: [, , { 12441: 12505, 12442: 12506 }], 12505: [[12504, 12441]], 12506: [[12504, 12442]], 12507: [, , { 12441: 12508, 12442: 12509 }], 12508: [[12507, 12441]], 12509: [[12507, 12442]], 12527: [, , { 12441: 12535 }], 12528: [, , { 12441: 12536 }], 12529: [, , { 12441: 12537 }], 12530: [, , { 12441: 12538 }], 12532: [[12454, 12441]], 12535: [[12527, 12441]], 12536: [[12528, 12441]], 12537: [[12529, 12441]], 12538: [[12530, 12441]], 12541: [, , { 12441: 12542 }], 12542: [[12541, 12441]], 12543: [[12467, 12488], 256] },
        12544: { 12593: [[4352], 256], 12594: [[4353], 256], 12595: [[4522], 256], 12596: [[4354], 256], 12597: [[4524], 256], 12598: [[4525], 256], 12599: [[4355], 256], 12600: [[4356], 256], 12601: [[4357], 256], 12602: [[4528], 256], 12603: [[4529], 256], 12604: [[4530], 256], 12605: [[4531], 256], 12606: [[4532], 256], 12607: [[4533], 256], 12608: [[4378], 256], 12609: [[4358], 256], 12610: [[4359], 256], 12611: [[4360], 256], 12612: [[4385], 256], 12613: [[4361], 256], 12614: [[4362], 256], 12615: [[4363], 256], 12616: [[4364], 256], 12617: [[4365], 256], 12618: [[4366], 256], 12619: [[4367], 256], 12620: [[4368], 256], 12621: [[4369], 256], 12622: [[4370], 256], 12623: [[4449], 256], 12624: [[4450], 256], 12625: [[4451], 256], 12626: [[4452], 256], 12627: [[4453], 256], 12628: [[4454], 256], 12629: [[4455], 256], 12630: [[4456], 256], 12631: [[4457], 256], 12632: [[4458], 256], 12633: [[4459], 256], 12634: [[4460], 256], 12635: [[4461], 256], 12636: [[4462], 256], 12637: [[4463], 256], 12638: [[4464], 256], 12639: [[4465], 256], 12640: [[4466], 256], 12641: [[4467], 256], 12642: [[4468], 256], 12643: [[4469], 256], 12644: [[4448], 256], 12645: [[4372], 256], 12646: [[4373], 256], 12647: [[4551], 256], 12648: [[4552], 256], 12649: [[4556], 256], 12650: [[4558], 256], 12651: [[4563], 256], 12652: [[4567], 256], 12653: [[4569], 256], 12654: [[4380], 256], 12655: [[4573], 256], 12656: [[4575], 256], 12657: [[4381], 256], 12658: [[4382], 256], 12659: [[4384], 256], 12660: [[4386], 256], 12661: [[4387], 256], 12662: [[4391], 256], 12663: [[4393], 256], 12664: [[4395], 256], 12665: [[4396], 256], 12666: [[4397], 256], 12667: [[4398], 256], 12668: [[4399], 256], 12669: [[4402], 256], 12670: [[4406], 256], 12671: [[4416], 256], 12672: [[4423], 256], 12673: [[4428], 256], 12674: [[4593], 256], 12675: [[4594], 256], 12676: [[4439], 256], 12677: [[4440], 256], 12678: [[4441], 256], 12679: [[4484], 256], 12680: [[4485], 256], 12681: [[4488], 256], 12682: [[4497], 256], 12683: [[4498], 256], 12684: [[4500], 256], 12685: [[4510], 256], 12686: [[4513], 256], 12690: [[19968], 256], 12691: [[20108], 256], 12692: [[19977], 256], 12693: [[22235], 256], 12694: [[19978], 256], 12695: [[20013], 256], 12696: [[19979], 256], 12697: [[30002], 256], 12698: [[20057], 256], 12699: [[19993], 256], 12700: [[19969], 256], 12701: [[22825], 256], 12702: [[22320], 256], 12703: [[20154], 256] },
        12800: { 12800: [[40, 4352, 41], 256], 12801: [[40, 4354, 41], 256], 12802: [[40, 4355, 41], 256], 12803: [[40, 4357, 41], 256], 12804: [[40, 4358, 41], 256], 12805: [[40, 4359, 41], 256], 12806: [[40, 4361, 41], 256], 12807: [[40, 4363, 41], 256], 12808: [[40, 4364, 41], 256], 12809: [[40, 4366, 41], 256], 12810: [[40, 4367, 41], 256], 12811: [[40, 4368, 41], 256], 12812: [[40, 4369, 41], 256], 12813: [[40, 4370, 41], 256], 12814: [[40, 4352, 4449, 41], 256], 12815: [[40, 4354, 4449, 41], 256], 12816: [[40, 4355, 4449, 41], 256], 12817: [[40, 4357, 4449, 41], 256], 12818: [[40, 4358, 4449, 41], 256], 12819: [[40, 4359, 4449, 41], 256], 12820: [[40, 4361, 4449, 41], 256], 12821: [[40, 4363, 4449, 41], 256], 12822: [[40, 4364, 4449, 41], 256], 12823: [[40, 4366, 4449, 41], 256], 12824: [[40, 4367, 4449, 41], 256], 12825: [[40, 4368, 4449, 41], 256], 12826: [[40, 4369, 4449, 41], 256], 12827: [[40, 4370, 4449, 41], 256], 12828: [[40, 4364, 4462, 41], 256], 12829: [[40, 4363, 4457, 4364, 4453, 4523, 41], 256], 12830: [[40, 4363, 4457, 4370, 4462, 41], 256], 12832: [[40, 19968, 41], 256], 12833: [[40, 20108, 41], 256], 12834: [[40, 19977, 41], 256], 12835: [[40, 22235, 41], 256], 12836: [[40, 20116, 41], 256], 12837: [[40, 20845, 41], 256], 12838: [[40, 19971, 41], 256], 12839: [[40, 20843, 41], 256], 12840: [[40, 20061, 41], 256], 12841: [[40, 21313, 41], 256], 12842: [[40, 26376, 41], 256], 12843: [[40, 28779, 41], 256], 12844: [[40, 27700, 41], 256], 12845: [[40, 26408, 41], 256], 12846: [[40, 37329, 41], 256], 12847: [[40, 22303, 41], 256], 12848: [[40, 26085, 41], 256], 12849: [[40, 26666, 41], 256], 12850: [[40, 26377, 41], 256], 12851: [[40, 31038, 41], 256], 12852: [[40, 21517, 41], 256], 12853: [[40, 29305, 41], 256], 12854: [[40, 36001, 41], 256], 12855: [[40, 31069, 41], 256], 12856: [[40, 21172, 41], 256], 12857: [[40, 20195, 41], 256], 12858: [[40, 21628, 41], 256], 12859: [[40, 23398, 41], 256], 12860: [[40, 30435, 41], 256], 12861: [[40, 20225, 41], 256], 12862: [[40, 36039, 41], 256], 12863: [[40, 21332, 41], 256], 12864: [[40, 31085, 41], 256], 12865: [[40, 20241, 41], 256], 12866: [[40, 33258, 41], 256], 12867: [[40, 33267, 41], 256], 12868: [[21839], 256], 12869: [[24188], 256], 12870: [[25991], 256], 12871: [[31631], 256], 12880: [[80, 84, 69], 256], 12881: [[50, 49], 256], 12882: [[50, 50], 256], 12883: [[50, 51], 256], 12884: [[50, 52], 256], 12885: [[50, 53], 256], 12886: [[50, 54], 256], 12887: [[50, 55], 256], 12888: [[50, 56], 256], 12889: [[50, 57], 256], 12890: [[51, 48], 256], 12891: [[51, 49], 256], 12892: [[51, 50], 256], 12893: [[51, 51], 256], 12894: [[51, 52], 256], 12895: [[51, 53], 256], 12896: [[4352], 256], 12897: [[4354], 256], 12898: [[4355], 256], 12899: [[4357], 256], 12900: [[4358], 256], 12901: [[4359], 256], 12902: [[4361], 256], 12903: [[4363], 256], 12904: [[4364], 256], 12905: [[4366], 256], 12906: [[4367], 256], 12907: [[4368], 256], 12908: [[4369], 256], 12909: [[4370], 256], 12910: [[4352, 4449], 256], 12911: [[4354, 4449], 256], 12912: [[4355, 4449], 256], 12913: [[4357, 4449], 256], 12914: [[4358, 4449], 256], 12915: [[4359, 4449], 256], 12916: [[4361, 4449], 256], 12917: [[4363, 4449], 256], 12918: [[4364, 4449], 256], 12919: [[4366, 4449], 256], 12920: [[4367, 4449], 256], 12921: [[4368, 4449], 256], 12922: [[4369, 4449], 256], 12923: [[4370, 4449], 256], 12924: [[4366, 4449, 4535, 4352, 4457], 256], 12925: [[4364, 4462, 4363, 4468], 256], 12926: [[4363, 4462], 256], 12928: [[19968], 256], 12929: [[20108], 256], 12930: [[19977], 256], 12931: [[22235], 256], 12932: [[20116], 256], 12933: [[20845], 256], 12934: [[19971], 256], 12935: [[20843], 256], 12936: [[20061], 256], 12937: [[21313], 256], 12938: [[26376], 256], 12939: [[28779], 256], 12940: [[27700], 256], 12941: [[26408], 256], 12942: [[37329], 256], 12943: [[22303], 256], 12944: [[26085], 256], 12945: [[26666], 256], 12946: [[26377], 256], 12947: [[31038], 256], 12948: [[21517], 256], 12949: [[29305], 256], 12950: [[36001], 256], 12951: [[31069], 256], 12952: [[21172], 256], 12953: [[31192], 256], 12954: [[30007], 256], 12955: [[22899], 256], 12956: [[36969], 256], 12957: [[20778], 256], 12958: [[21360], 256], 12959: [[27880], 256], 12960: [[38917], 256], 12961: [[20241], 256], 12962: [[20889], 256], 12963: [[27491], 256], 12964: [[19978], 256], 12965: [[20013], 256], 12966: [[19979], 256], 12967: [[24038], 256], 12968: [[21491], 256], 12969: [[21307], 256], 12970: [[23447], 256], 12971: [[23398], 256], 12972: [[30435], 256], 12973: [[20225], 256], 12974: [[36039], 256], 12975: [[21332], 256], 12976: [[22812], 256], 12977: [[51, 54], 256], 12978: [[51, 55], 256], 12979: [[51, 56], 256], 12980: [[51, 57], 256], 12981: [[52, 48], 256], 12982: [[52, 49], 256], 12983: [[52, 50], 256], 12984: [[52, 51], 256], 12985: [[52, 52], 256], 12986: [[52, 53], 256], 12987: [[52, 54], 256], 12988: [[52, 55], 256], 12989: [[52, 56], 256], 12990: [[52, 57], 256], 12991: [[53, 48], 256], 12992: [[49, 26376], 256], 12993: [[50, 26376], 256], 12994: [[51, 26376], 256], 12995: [[52, 26376], 256], 12996: [[53, 26376], 256], 12997: [[54, 26376], 256], 12998: [[55, 26376], 256], 12999: [[56, 26376], 256], 13e3: [[57, 26376], 256], 13001: [[49, 48, 26376], 256], 13002: [[49, 49, 26376], 256], 13003: [[49, 50, 26376], 256], 13004: [[72, 103], 256], 13005: [[101, 114, 103], 256], 13006: [[101, 86], 256], 13007: [[76, 84, 68], 256], 13008: [[12450], 256], 13009: [[12452], 256], 13010: [[12454], 256], 13011: [[12456], 256], 13012: [[12458], 256], 13013: [[12459], 256], 13014: [[12461], 256], 13015: [[12463], 256], 13016: [[12465], 256], 13017: [[12467], 256], 13018: [[12469], 256], 13019: [[12471], 256], 13020: [[12473], 256], 13021: [[12475], 256], 13022: [[12477], 256], 13023: [[12479], 256], 13024: [[12481], 256], 13025: [[12484], 256], 13026: [[12486], 256], 13027: [[12488], 256], 13028: [[12490], 256], 13029: [[12491], 256], 13030: [[12492], 256], 13031: [[12493], 256], 13032: [[12494], 256], 13033: [[12495], 256], 13034: [[12498], 256], 13035: [[12501], 256], 13036: [[12504], 256], 13037: [[12507], 256], 13038: [[12510], 256], 13039: [[12511], 256], 13040: [[12512], 256], 13041: [[12513], 256], 13042: [[12514], 256], 13043: [[12516], 256], 13044: [[12518], 256], 13045: [[12520], 256], 13046: [[12521], 256], 13047: [[12522], 256], 13048: [[12523], 256], 13049: [[12524], 256], 13050: [[12525], 256], 13051: [[12527], 256], 13052: [[12528], 256], 13053: [[12529], 256], 13054: [[12530], 256] },
        13056: { 13056: [[12450, 12497, 12540, 12488], 256], 13057: [[12450, 12523, 12501, 12449], 256], 13058: [[12450, 12531, 12506, 12450], 256], 13059: [[12450, 12540, 12523], 256], 13060: [[12452, 12491, 12531, 12464], 256], 13061: [[12452, 12531, 12481], 256], 13062: [[12454, 12457, 12531], 256], 13063: [[12456, 12473, 12463, 12540, 12489], 256], 13064: [[12456, 12540, 12459, 12540], 256], 13065: [[12458, 12531, 12473], 256], 13066: [[12458, 12540, 12512], 256], 13067: [[12459, 12452, 12522], 256], 13068: [[12459, 12521, 12483, 12488], 256], 13069: [[12459, 12525, 12522, 12540], 256], 13070: [[12460, 12525, 12531], 256], 13071: [[12460, 12531, 12510], 256], 13072: [[12462, 12460], 256], 13073: [[12462, 12491, 12540], 256], 13074: [[12461, 12517, 12522, 12540], 256], 13075: [[12462, 12523, 12480, 12540], 256], 13076: [[12461, 12525], 256], 13077: [[12461, 12525, 12464, 12521, 12512], 256], 13078: [[12461, 12525, 12513, 12540, 12488, 12523], 256], 13079: [[12461, 12525, 12527, 12483, 12488], 256], 13080: [[12464, 12521, 12512], 256], 13081: [[12464, 12521, 12512, 12488, 12531], 256], 13082: [[12463, 12523, 12476, 12452, 12525], 256], 13083: [[12463, 12525, 12540, 12493], 256], 13084: [[12465, 12540, 12473], 256], 13085: [[12467, 12523, 12490], 256], 13086: [[12467, 12540, 12509], 256], 13087: [[12469, 12452, 12463, 12523], 256], 13088: [[12469, 12531, 12481, 12540, 12512], 256], 13089: [[12471, 12522, 12531, 12464], 256], 13090: [[12475, 12531, 12481], 256], 13091: [[12475, 12531, 12488], 256], 13092: [[12480, 12540, 12473], 256], 13093: [[12487, 12471], 256], 13094: [[12489, 12523], 256], 13095: [[12488, 12531], 256], 13096: [[12490, 12494], 256], 13097: [[12494, 12483, 12488], 256], 13098: [[12495, 12452, 12484], 256], 13099: [[12497, 12540, 12475, 12531, 12488], 256], 13100: [[12497, 12540, 12484], 256], 13101: [[12496, 12540, 12524, 12523], 256], 13102: [[12500, 12450, 12473, 12488, 12523], 256], 13103: [[12500, 12463, 12523], 256], 13104: [[12500, 12467], 256], 13105: [[12499, 12523], 256], 13106: [[12501, 12449, 12521, 12483, 12489], 256], 13107: [[12501, 12451, 12540, 12488], 256], 13108: [[12502, 12483, 12471, 12455, 12523], 256], 13109: [[12501, 12521, 12531], 256], 13110: [[12504, 12463, 12479, 12540, 12523], 256], 13111: [[12506, 12477], 256], 13112: [[12506, 12491, 12498], 256], 13113: [[12504, 12523, 12484], 256], 13114: [[12506, 12531, 12473], 256], 13115: [[12506, 12540, 12472], 256], 13116: [[12505, 12540, 12479], 256], 13117: [[12509, 12452, 12531, 12488], 256], 13118: [[12508, 12523, 12488], 256], 13119: [[12507, 12531], 256], 13120: [[12509, 12531, 12489], 256], 13121: [[12507, 12540, 12523], 256], 13122: [[12507, 12540, 12531], 256], 13123: [[12510, 12452, 12463, 12525], 256], 13124: [[12510, 12452, 12523], 256], 13125: [[12510, 12483, 12495], 256], 13126: [[12510, 12523, 12463], 256], 13127: [[12510, 12531, 12471, 12519, 12531], 256], 13128: [[12511, 12463, 12525, 12531], 256], 13129: [[12511, 12522], 256], 13130: [[12511, 12522, 12496, 12540, 12523], 256], 13131: [[12513, 12460], 256], 13132: [[12513, 12460, 12488, 12531], 256], 13133: [[12513, 12540, 12488, 12523], 256], 13134: [[12516, 12540, 12489], 256], 13135: [[12516, 12540, 12523], 256], 13136: [[12518, 12450, 12531], 256], 13137: [[12522, 12483, 12488, 12523], 256], 13138: [[12522, 12521], 256], 13139: [[12523, 12500, 12540], 256], 13140: [[12523, 12540, 12502, 12523], 256], 13141: [[12524, 12512], 256], 13142: [[12524, 12531, 12488, 12466, 12531], 256], 13143: [[12527, 12483, 12488], 256], 13144: [[48, 28857], 256], 13145: [[49, 28857], 256], 13146: [[50, 28857], 256], 13147: [[51, 28857], 256], 13148: [[52, 28857], 256], 13149: [[53, 28857], 256], 13150: [[54, 28857], 256], 13151: [[55, 28857], 256], 13152: [[56, 28857], 256], 13153: [[57, 28857], 256], 13154: [[49, 48, 28857], 256], 13155: [[49, 49, 28857], 256], 13156: [[49, 50, 28857], 256], 13157: [[49, 51, 28857], 256], 13158: [[49, 52, 28857], 256], 13159: [[49, 53, 28857], 256], 13160: [[49, 54, 28857], 256], 13161: [[49, 55, 28857], 256], 13162: [[49, 56, 28857], 256], 13163: [[49, 57, 28857], 256], 13164: [[50, 48, 28857], 256], 13165: [[50, 49, 28857], 256], 13166: [[50, 50, 28857], 256], 13167: [[50, 51, 28857], 256], 13168: [[50, 52, 28857], 256], 13169: [[104, 80, 97], 256], 13170: [[100, 97], 256], 13171: [[65, 85], 256], 13172: [[98, 97, 114], 256], 13173: [[111, 86], 256], 13174: [[112, 99], 256], 13175: [[100, 109], 256], 13176: [[100, 109, 178], 256], 13177: [[100, 109, 179], 256], 13178: [[73, 85], 256], 13179: [[24179, 25104], 256], 13180: [[26157, 21644], 256], 13181: [[22823, 27491], 256], 13182: [[26126, 27835], 256], 13183: [[26666, 24335, 20250, 31038], 256], 13184: [[112, 65], 256], 13185: [[110, 65], 256], 13186: [[956, 65], 256], 13187: [[109, 65], 256], 13188: [[107, 65], 256], 13189: [[75, 66], 256], 13190: [[77, 66], 256], 13191: [[71, 66], 256], 13192: [[99, 97, 108], 256], 13193: [[107, 99, 97, 108], 256], 13194: [[112, 70], 256], 13195: [[110, 70], 256], 13196: [[956, 70], 256], 13197: [[956, 103], 256], 13198: [[109, 103], 256], 13199: [[107, 103], 256], 13200: [[72, 122], 256], 13201: [[107, 72, 122], 256], 13202: [[77, 72, 122], 256], 13203: [[71, 72, 122], 256], 13204: [[84, 72, 122], 256], 13205: [[956, 8467], 256], 13206: [[109, 8467], 256], 13207: [[100, 8467], 256], 13208: [[107, 8467], 256], 13209: [[102, 109], 256], 13210: [[110, 109], 256], 13211: [[956, 109], 256], 13212: [[109, 109], 256], 13213: [[99, 109], 256], 13214: [[107, 109], 256], 13215: [[109, 109, 178], 256], 13216: [[99, 109, 178], 256], 13217: [[109, 178], 256], 13218: [[107, 109, 178], 256], 13219: [[109, 109, 179], 256], 13220: [[99, 109, 179], 256], 13221: [[109, 179], 256], 13222: [[107, 109, 179], 256], 13223: [[109, 8725, 115], 256], 13224: [[109, 8725, 115, 178], 256], 13225: [[80, 97], 256], 13226: [[107, 80, 97], 256], 13227: [[77, 80, 97], 256], 13228: [[71, 80, 97], 256], 13229: [[114, 97, 100], 256], 13230: [[114, 97, 100, 8725, 115], 256], 13231: [[114, 97, 100, 8725, 115, 178], 256], 13232: [[112, 115], 256], 13233: [[110, 115], 256], 13234: [[956, 115], 256], 13235: [[109, 115], 256], 13236: [[112, 86], 256], 13237: [[110, 86], 256], 13238: [[956, 86], 256], 13239: [[109, 86], 256], 13240: [[107, 86], 256], 13241: [[77, 86], 256], 13242: [[112, 87], 256], 13243: [[110, 87], 256], 13244: [[956, 87], 256], 13245: [[109, 87], 256], 13246: [[107, 87], 256], 13247: [[77, 87], 256], 13248: [[107, 937], 256], 13249: [[77, 937], 256], 13250: [[97, 46, 109, 46], 256], 13251: [[66, 113], 256], 13252: [[99, 99], 256], 13253: [[99, 100], 256], 13254: [[67, 8725, 107, 103], 256], 13255: [[67, 111, 46], 256], 13256: [[100, 66], 256], 13257: [[71, 121], 256], 13258: [[104, 97], 256], 13259: [[72, 80], 256], 13260: [[105, 110], 256], 13261: [[75, 75], 256], 13262: [[75, 77], 256], 13263: [[107, 116], 256], 13264: [[108, 109], 256], 13265: [[108, 110], 256], 13266: [[108, 111, 103], 256], 13267: [[108, 120], 256], 13268: [[109, 98], 256], 13269: [[109, 105, 108], 256], 13270: [[109, 111, 108], 256], 13271: [[80, 72], 256], 13272: [[112, 46, 109, 46], 256], 13273: [[80, 80, 77], 256], 13274: [[80, 82], 256], 13275: [[115, 114], 256], 13276: [[83, 118], 256], 13277: [[87, 98], 256], 13278: [[86, 8725, 109], 256], 13279: [[65, 8725, 109], 256], 13280: [[49, 26085], 256], 13281: [[50, 26085], 256], 13282: [[51, 26085], 256], 13283: [[52, 26085], 256], 13284: [[53, 26085], 256], 13285: [[54, 26085], 256], 13286: [[55, 26085], 256], 13287: [[56, 26085], 256], 13288: [[57, 26085], 256], 13289: [[49, 48, 26085], 256], 13290: [[49, 49, 26085], 256], 13291: [[49, 50, 26085], 256], 13292: [[49, 51, 26085], 256], 13293: [[49, 52, 26085], 256], 13294: [[49, 53, 26085], 256], 13295: [[49, 54, 26085], 256], 13296: [[49, 55, 26085], 256], 13297: [[49, 56, 26085], 256], 13298: [[49, 57, 26085], 256], 13299: [[50, 48, 26085], 256], 13300: [[50, 49, 26085], 256], 13301: [[50, 50, 26085], 256], 13302: [[50, 51, 26085], 256], 13303: [[50, 52, 26085], 256], 13304: [[50, 53, 26085], 256], 13305: [[50, 54, 26085], 256], 13306: [[50, 55, 26085], 256], 13307: [[50, 56, 26085], 256], 13308: [[50, 57, 26085], 256], 13309: [[51, 48, 26085], 256], 13310: [[51, 49, 26085], 256], 13311: [[103, 97, 108], 256] },
        27136: { 92912: [, 1], 92913: [, 1], 92914: [, 1], 92915: [, 1], 92916: [, 1] },
        27392: { 92976: [, 230], 92977: [, 230], 92978: [, 230], 92979: [, 230], 92980: [, 230], 92981: [, 230], 92982: [, 230] },
        42496: { 42607: [, 230], 42612: [, 230], 42613: [, 230], 42614: [, 230], 42615: [, 230], 42616: [, 230], 42617: [, 230], 42618: [, 230], 42619: [, 230], 42620: [, 230], 42621: [, 230], 42652: [[1098], 256], 42653: [[1100], 256], 42655: [, 230], 42736: [, 230], 42737: [, 230] },
        42752: { 42864: [[42863], 256], 43e3: [[294], 256], 43001: [[339], 256] },
        43008: { 43014: [, 9], 43204: [, 9], 43232: [, 230], 43233: [, 230], 43234: [, 230], 43235: [, 230], 43236: [, 230], 43237: [, 230], 43238: [, 230], 43239: [, 230], 43240: [, 230], 43241: [, 230], 43242: [, 230], 43243: [, 230], 43244: [, 230], 43245: [, 230], 43246: [, 230], 43247: [, 230], 43248: [, 230], 43249: [, 230] },
        43264: { 43307: [, 220], 43308: [, 220], 43309: [, 220], 43347: [, 9], 43443: [, 7], 43456: [, 9] },
        43520: { 43696: [, 230], 43698: [, 230], 43699: [, 230], 43700: [, 220], 43703: [, 230], 43704: [, 230], 43710: [, 230], 43711: [, 230], 43713: [, 230], 43766: [, 9] },
        43776: { 43868: [[42791], 256], 43869: [[43831], 256], 43870: [[619], 256], 43871: [[43858], 256], 44013: [, 9] },
        48128: { 113822: [, 1] },
        53504: { 119134: [[119127, 119141], 512], 119135: [[119128, 119141], 512], 119136: [[119135, 119150], 512], 119137: [[119135, 119151], 512], 119138: [[119135, 119152], 512], 119139: [[119135, 119153], 512], 119140: [[119135, 119154], 512], 119141: [, 216], 119142: [, 216], 119143: [, 1], 119144: [, 1], 119145: [, 1], 119149: [, 226], 119150: [, 216], 119151: [, 216], 119152: [, 216], 119153: [, 216], 119154: [, 216], 119163: [, 220], 119164: [, 220], 119165: [, 220], 119166: [, 220], 119167: [, 220], 119168: [, 220], 119169: [, 220], 119170: [, 220], 119173: [, 230], 119174: [, 230], 119175: [, 230], 119176: [, 230], 119177: [, 230], 119178: [, 220], 119179: [, 220], 119210: [, 230], 119211: [, 230], 119212: [, 230], 119213: [, 230], 119227: [[119225, 119141], 512], 119228: [[119226, 119141], 512], 119229: [[119227, 119150], 512], 119230: [[119228, 119150], 512], 119231: [[119227, 119151], 512], 119232: [[119228, 119151], 512] },
        53760: { 119362: [, 230], 119363: [, 230], 119364: [, 230] },
        54272: { 119808: [[65], 256], 119809: [[66], 256], 119810: [[67], 256], 119811: [[68], 256], 119812: [[69], 256], 119813: [[70], 256], 119814: [[71], 256], 119815: [[72], 256], 119816: [[73], 256], 119817: [[74], 256], 119818: [[75], 256], 119819: [[76], 256], 119820: [[77], 256], 119821: [[78], 256], 119822: [[79], 256], 119823: [[80], 256], 119824: [[81], 256], 119825: [[82], 256], 119826: [[83], 256], 119827: [[84], 256], 119828: [[85], 256], 119829: [[86], 256], 119830: [[87], 256], 119831: [[88], 256], 119832: [[89], 256], 119833: [[90], 256], 119834: [[97], 256], 119835: [[98], 256], 119836: [[99], 256], 119837: [[100], 256], 119838: [[101], 256], 119839: [[102], 256], 119840: [[103], 256], 119841: [[104], 256], 119842: [[105], 256], 119843: [[106], 256], 119844: [[107], 256], 119845: [[108], 256], 119846: [[109], 256], 119847: [[110], 256], 119848: [[111], 256], 119849: [[112], 256], 119850: [[113], 256], 119851: [[114], 256], 119852: [[115], 256], 119853: [[116], 256], 119854: [[117], 256], 119855: [[118], 256], 119856: [[119], 256], 119857: [[120], 256], 119858: [[121], 256], 119859: [[122], 256], 119860: [[65], 256], 119861: [[66], 256], 119862: [[67], 256], 119863: [[68], 256], 119864: [[69], 256], 119865: [[70], 256], 119866: [[71], 256], 119867: [[72], 256], 119868: [[73], 256], 119869: [[74], 256], 119870: [[75], 256], 119871: [[76], 256], 119872: [[77], 256], 119873: [[78], 256], 119874: [[79], 256], 119875: [[80], 256], 119876: [[81], 256], 119877: [[82], 256], 119878: [[83], 256], 119879: [[84], 256], 119880: [[85], 256], 119881: [[86], 256], 119882: [[87], 256], 119883: [[88], 256], 119884: [[89], 256], 119885: [[90], 256], 119886: [[97], 256], 119887: [[98], 256], 119888: [[99], 256], 119889: [[100], 256], 119890: [[101], 256], 119891: [[102], 256], 119892: [[103], 256], 119894: [[105], 256], 119895: [[106], 256], 119896: [[107], 256], 119897: [[108], 256], 119898: [[109], 256], 119899: [[110], 256], 119900: [[111], 256], 119901: [[112], 256], 119902: [[113], 256], 119903: [[114], 256], 119904: [[115], 256], 119905: [[116], 256], 119906: [[117], 256], 119907: [[118], 256], 119908: [[119], 256], 119909: [[120], 256], 119910: [[121], 256], 119911: [[122], 256], 119912: [[65], 256], 119913: [[66], 256], 119914: [[67], 256], 119915: [[68], 256], 119916: [[69], 256], 119917: [[70], 256], 119918: [[71], 256], 119919: [[72], 256], 119920: [[73], 256], 119921: [[74], 256], 119922: [[75], 256], 119923: [[76], 256], 119924: [[77], 256], 119925: [[78], 256], 119926: [[79], 256], 119927: [[80], 256], 119928: [[81], 256], 119929: [[82], 256], 119930: [[83], 256], 119931: [[84], 256], 119932: [[85], 256], 119933: [[86], 256], 119934: [[87], 256], 119935: [[88], 256], 119936: [[89], 256], 119937: [[90], 256], 119938: [[97], 256], 119939: [[98], 256], 119940: [[99], 256], 119941: [[100], 256], 119942: [[101], 256], 119943: [[102], 256], 119944: [[103], 256], 119945: [[104], 256], 119946: [[105], 256], 119947: [[106], 256], 119948: [[107], 256], 119949: [[108], 256], 119950: [[109], 256], 119951: [[110], 256], 119952: [[111], 256], 119953: [[112], 256], 119954: [[113], 256], 119955: [[114], 256], 119956: [[115], 256], 119957: [[116], 256], 119958: [[117], 256], 119959: [[118], 256], 119960: [[119], 256], 119961: [[120], 256], 119962: [[121], 256], 119963: [[122], 256], 119964: [[65], 256], 119966: [[67], 256], 119967: [[68], 256], 119970: [[71], 256], 119973: [[74], 256], 119974: [[75], 256], 119977: [[78], 256], 119978: [[79], 256], 119979: [[80], 256], 119980: [[81], 256], 119982: [[83], 256], 119983: [[84], 256], 119984: [[85], 256], 119985: [[86], 256], 119986: [[87], 256], 119987: [[88], 256], 119988: [[89], 256], 119989: [[90], 256], 119990: [[97], 256], 119991: [[98], 256], 119992: [[99], 256], 119993: [[100], 256], 119995: [[102], 256], 119997: [[104], 256], 119998: [[105], 256], 119999: [[106], 256], 12e4: [[107], 256], 120001: [[108], 256], 120002: [[109], 256], 120003: [[110], 256], 120005: [[112], 256], 120006: [[113], 256], 120007: [[114], 256], 120008: [[115], 256], 120009: [[116], 256], 120010: [[117], 256], 120011: [[118], 256], 120012: [[119], 256], 120013: [[120], 256], 120014: [[121], 256], 120015: [[122], 256], 120016: [[65], 256], 120017: [[66], 256], 120018: [[67], 256], 120019: [[68], 256], 120020: [[69], 256], 120021: [[70], 256], 120022: [[71], 256], 120023: [[72], 256], 120024: [[73], 256], 120025: [[74], 256], 120026: [[75], 256], 120027: [[76], 256], 120028: [[77], 256], 120029: [[78], 256], 120030: [[79], 256], 120031: [[80], 256], 120032: [[81], 256], 120033: [[82], 256], 120034: [[83], 256], 120035: [[84], 256], 120036: [[85], 256], 120037: [[86], 256], 120038: [[87], 256], 120039: [[88], 256], 120040: [[89], 256], 120041: [[90], 256], 120042: [[97], 256], 120043: [[98], 256], 120044: [[99], 256], 120045: [[100], 256], 120046: [[101], 256], 120047: [[102], 256], 120048: [[103], 256], 120049: [[104], 256], 120050: [[105], 256], 120051: [[106], 256], 120052: [[107], 256], 120053: [[108], 256], 120054: [[109], 256], 120055: [[110], 256], 120056: [[111], 256], 120057: [[112], 256], 120058: [[113], 256], 120059: [[114], 256], 120060: [[115], 256], 120061: [[116], 256], 120062: [[117], 256], 120063: [[118], 256] },
        54528: { 120064: [[119], 256], 120065: [[120], 256], 120066: [[121], 256], 120067: [[122], 256], 120068: [[65], 256], 120069: [[66], 256], 120071: [[68], 256], 120072: [[69], 256], 120073: [[70], 256], 120074: [[71], 256], 120077: [[74], 256], 120078: [[75], 256], 120079: [[76], 256], 120080: [[77], 256], 120081: [[78], 256], 120082: [[79], 256], 120083: [[80], 256], 120084: [[81], 256], 120086: [[83], 256], 120087: [[84], 256], 120088: [[85], 256], 120089: [[86], 256], 120090: [[87], 256], 120091: [[88], 256], 120092: [[89], 256], 120094: [[97], 256], 120095: [[98], 256], 120096: [[99], 256], 120097: [[100], 256], 120098: [[101], 256], 120099: [[102], 256], 120100: [[103], 256], 120101: [[104], 256], 120102: [[105], 256], 120103: [[106], 256], 120104: [[107], 256], 120105: [[108], 256], 120106: [[109], 256], 120107: [[110], 256], 120108: [[111], 256], 120109: [[112], 256], 120110: [[113], 256], 120111: [[114], 256], 120112: [[115], 256], 120113: [[116], 256], 120114: [[117], 256], 120115: [[118], 256], 120116: [[119], 256], 120117: [[120], 256], 120118: [[121], 256], 120119: [[122], 256], 120120: [[65], 256], 120121: [[66], 256], 120123: [[68], 256], 120124: [[69], 256], 120125: [[70], 256], 120126: [[71], 256], 120128: [[73], 256], 120129: [[74], 256], 120130: [[75], 256], 120131: [[76], 256], 120132: [[77], 256], 120134: [[79], 256], 120138: [[83], 256], 120139: [[84], 256], 120140: [[85], 256], 120141: [[86], 256], 120142: [[87], 256], 120143: [[88], 256], 120144: [[89], 256], 120146: [[97], 256], 120147: [[98], 256], 120148: [[99], 256], 120149: [[100], 256], 120150: [[101], 256], 120151: [[102], 256], 120152: [[103], 256], 120153: [[104], 256], 120154: [[105], 256], 120155: [[106], 256], 120156: [[107], 256], 120157: [[108], 256], 120158: [[109], 256], 120159: [[110], 256], 120160: [[111], 256], 120161: [[112], 256], 120162: [[113], 256], 120163: [[114], 256], 120164: [[115], 256], 120165: [[116], 256], 120166: [[117], 256], 120167: [[118], 256], 120168: [[119], 256], 120169: [[120], 256], 120170: [[121], 256], 120171: [[122], 256], 120172: [[65], 256], 120173: [[66], 256], 120174: [[67], 256], 120175: [[68], 256], 120176: [[69], 256], 120177: [[70], 256], 120178: [[71], 256], 120179: [[72], 256], 120180: [[73], 256], 120181: [[74], 256], 120182: [[75], 256], 120183: [[76], 256], 120184: [[77], 256], 120185: [[78], 256], 120186: [[79], 256], 120187: [[80], 256], 120188: [[81], 256], 120189: [[82], 256], 120190: [[83], 256], 120191: [[84], 256], 120192: [[85], 256], 120193: [[86], 256], 120194: [[87], 256], 120195: [[88], 256], 120196: [[89], 256], 120197: [[90], 256], 120198: [[97], 256], 120199: [[98], 256], 120200: [[99], 256], 120201: [[100], 256], 120202: [[101], 256], 120203: [[102], 256], 120204: [[103], 256], 120205: [[104], 256], 120206: [[105], 256], 120207: [[106], 256], 120208: [[107], 256], 120209: [[108], 256], 120210: [[109], 256], 120211: [[110], 256], 120212: [[111], 256], 120213: [[112], 256], 120214: [[113], 256], 120215: [[114], 256], 120216: [[115], 256], 120217: [[116], 256], 120218: [[117], 256], 120219: [[118], 256], 120220: [[119], 256], 120221: [[120], 256], 120222: [[121], 256], 120223: [[122], 256], 120224: [[65], 256], 120225: [[66], 256], 120226: [[67], 256], 120227: [[68], 256], 120228: [[69], 256], 120229: [[70], 256], 120230: [[71], 256], 120231: [[72], 256], 120232: [[73], 256], 120233: [[74], 256], 120234: [[75], 256], 120235: [[76], 256], 120236: [[77], 256], 120237: [[78], 256], 120238: [[79], 256], 120239: [[80], 256], 120240: [[81], 256], 120241: [[82], 256], 120242: [[83], 256], 120243: [[84], 256], 120244: [[85], 256], 120245: [[86], 256], 120246: [[87], 256], 120247: [[88], 256], 120248: [[89], 256], 120249: [[90], 256], 120250: [[97], 256], 120251: [[98], 256], 120252: [[99], 256], 120253: [[100], 256], 120254: [[101], 256], 120255: [[102], 256], 120256: [[103], 256], 120257: [[104], 256], 120258: [[105], 256], 120259: [[106], 256], 120260: [[107], 256], 120261: [[108], 256], 120262: [[109], 256], 120263: [[110], 256], 120264: [[111], 256], 120265: [[112], 256], 120266: [[113], 256], 120267: [[114], 256], 120268: [[115], 256], 120269: [[116], 256], 120270: [[117], 256], 120271: [[118], 256], 120272: [[119], 256], 120273: [[120], 256], 120274: [[121], 256], 120275: [[122], 256], 120276: [[65], 256], 120277: [[66], 256], 120278: [[67], 256], 120279: [[68], 256], 120280: [[69], 256], 120281: [[70], 256], 120282: [[71], 256], 120283: [[72], 256], 120284: [[73], 256], 120285: [[74], 256], 120286: [[75], 256], 120287: [[76], 256], 120288: [[77], 256], 120289: [[78], 256], 120290: [[79], 256], 120291: [[80], 256], 120292: [[81], 256], 120293: [[82], 256], 120294: [[83], 256], 120295: [[84], 256], 120296: [[85], 256], 120297: [[86], 256], 120298: [[87], 256], 120299: [[88], 256], 120300: [[89], 256], 120301: [[90], 256], 120302: [[97], 256], 120303: [[98], 256], 120304: [[99], 256], 120305: [[100], 256], 120306: [[101], 256], 120307: [[102], 256], 120308: [[103], 256], 120309: [[104], 256], 120310: [[105], 256], 120311: [[106], 256], 120312: [[107], 256], 120313: [[108], 256], 120314: [[109], 256], 120315: [[110], 256], 120316: [[111], 256], 120317: [[112], 256], 120318: [[113], 256], 120319: [[114], 256] },
        54784: { 120320: [[115], 256], 120321: [[116], 256], 120322: [[117], 256], 120323: [[118], 256], 120324: [[119], 256], 120325: [[120], 256], 120326: [[121], 256], 120327: [[122], 256], 120328: [[65], 256], 120329: [[66], 256], 120330: [[67], 256], 120331: [[68], 256], 120332: [[69], 256], 120333: [[70], 256], 120334: [[71], 256], 120335: [[72], 256], 120336: [[73], 256], 120337: [[74], 256], 120338: [[75], 256], 120339: [[76], 256], 120340: [[77], 256], 120341: [[78], 256], 120342: [[79], 256], 120343: [[80], 256], 120344: [[81], 256], 120345: [[82], 256], 120346: [[83], 256], 120347: [[84], 256], 120348: [[85], 256], 120349: [[86], 256], 120350: [[87], 256], 120351: [[88], 256], 120352: [[89], 256], 120353: [[90], 256], 120354: [[97], 256], 120355: [[98], 256], 120356: [[99], 256], 120357: [[100], 256], 120358: [[101], 256], 120359: [[102], 256], 120360: [[103], 256], 120361: [[104], 256], 120362: [[105], 256], 120363: [[106], 256], 120364: [[107], 256], 120365: [[108], 256], 120366: [[109], 256], 120367: [[110], 256], 120368: [[111], 256], 120369: [[112], 256], 120370: [[113], 256], 120371: [[114], 256], 120372: [[115], 256], 120373: [[116], 256], 120374: [[117], 256], 120375: [[118], 256], 120376: [[119], 256], 120377: [[120], 256], 120378: [[121], 256], 120379: [[122], 256], 120380: [[65], 256], 120381: [[66], 256], 120382: [[67], 256], 120383: [[68], 256], 120384: [[69], 256], 120385: [[70], 256], 120386: [[71], 256], 120387: [[72], 256], 120388: [[73], 256], 120389: [[74], 256], 120390: [[75], 256], 120391: [[76], 256], 120392: [[77], 256], 120393: [[78], 256], 120394: [[79], 256], 120395: [[80], 256], 120396: [[81], 256], 120397: [[82], 256], 120398: [[83], 256], 120399: [[84], 256], 120400: [[85], 256], 120401: [[86], 256], 120402: [[87], 256], 120403: [[88], 256], 120404: [[89], 256], 120405: [[90], 256], 120406: [[97], 256], 120407: [[98], 256], 120408: [[99], 256], 120409: [[100], 256], 120410: [[101], 256], 120411: [[102], 256], 120412: [[103], 256], 120413: [[104], 256], 120414: [[105], 256], 120415: [[106], 256], 120416: [[107], 256], 120417: [[108], 256], 120418: [[109], 256], 120419: [[110], 256], 120420: [[111], 256], 120421: [[112], 256], 120422: [[113], 256], 120423: [[114], 256], 120424: [[115], 256], 120425: [[116], 256], 120426: [[117], 256], 120427: [[118], 256], 120428: [[119], 256], 120429: [[120], 256], 120430: [[121], 256], 120431: [[122], 256], 120432: [[65], 256], 120433: [[66], 256], 120434: [[67], 256], 120435: [[68], 256], 120436: [[69], 256], 120437: [[70], 256], 120438: [[71], 256], 120439: [[72], 256], 120440: [[73], 256], 120441: [[74], 256], 120442: [[75], 256], 120443: [[76], 256], 120444: [[77], 256], 120445: [[78], 256], 120446: [[79], 256], 120447: [[80], 256], 120448: [[81], 256], 120449: [[82], 256], 120450: [[83], 256], 120451: [[84], 256], 120452: [[85], 256], 120453: [[86], 256], 120454: [[87], 256], 120455: [[88], 256], 120456: [[89], 256], 120457: [[90], 256], 120458: [[97], 256], 120459: [[98], 256], 120460: [[99], 256], 120461: [[100], 256], 120462: [[101], 256], 120463: [[102], 256], 120464: [[103], 256], 120465: [[104], 256], 120466: [[105], 256], 120467: [[106], 256], 120468: [[107], 256], 120469: [[108], 256], 120470: [[109], 256], 120471: [[110], 256], 120472: [[111], 256], 120473: [[112], 256], 120474: [[113], 256], 120475: [[114], 256], 120476: [[115], 256], 120477: [[116], 256], 120478: [[117], 256], 120479: [[118], 256], 120480: [[119], 256], 120481: [[120], 256], 120482: [[121], 256], 120483: [[122], 256], 120484: [[305], 256], 120485: [[567], 256], 120488: [[913], 256], 120489: [[914], 256], 120490: [[915], 256], 120491: [[916], 256], 120492: [[917], 256], 120493: [[918], 256], 120494: [[919], 256], 120495: [[920], 256], 120496: [[921], 256], 120497: [[922], 256], 120498: [[923], 256], 120499: [[924], 256], 120500: [[925], 256], 120501: [[926], 256], 120502: [[927], 256], 120503: [[928], 256], 120504: [[929], 256], 120505: [[1012], 256], 120506: [[931], 256], 120507: [[932], 256], 120508: [[933], 256], 120509: [[934], 256], 120510: [[935], 256], 120511: [[936], 256], 120512: [[937], 256], 120513: [[8711], 256], 120514: [[945], 256], 120515: [[946], 256], 120516: [[947], 256], 120517: [[948], 256], 120518: [[949], 256], 120519: [[950], 256], 120520: [[951], 256], 120521: [[952], 256], 120522: [[953], 256], 120523: [[954], 256], 120524: [[955], 256], 120525: [[956], 256], 120526: [[957], 256], 120527: [[958], 256], 120528: [[959], 256], 120529: [[960], 256], 120530: [[961], 256], 120531: [[962], 256], 120532: [[963], 256], 120533: [[964], 256], 120534: [[965], 256], 120535: [[966], 256], 120536: [[967], 256], 120537: [[968], 256], 120538: [[969], 256], 120539: [[8706], 256], 120540: [[1013], 256], 120541: [[977], 256], 120542: [[1008], 256], 120543: [[981], 256], 120544: [[1009], 256], 120545: [[982], 256], 120546: [[913], 256], 120547: [[914], 256], 120548: [[915], 256], 120549: [[916], 256], 120550: [[917], 256], 120551: [[918], 256], 120552: [[919], 256], 120553: [[920], 256], 120554: [[921], 256], 120555: [[922], 256], 120556: [[923], 256], 120557: [[924], 256], 120558: [[925], 256], 120559: [[926], 256], 120560: [[927], 256], 120561: [[928], 256], 120562: [[929], 256], 120563: [[1012], 256], 120564: [[931], 256], 120565: [[932], 256], 120566: [[933], 256], 120567: [[934], 256], 120568: [[935], 256], 120569: [[936], 256], 120570: [[937], 256], 120571: [[8711], 256], 120572: [[945], 256], 120573: [[946], 256], 120574: [[947], 256], 120575: [[948], 256] },
        55040: { 120576: [[949], 256], 120577: [[950], 256], 120578: [[951], 256], 120579: [[952], 256], 120580: [[953], 256], 120581: [[954], 256], 120582: [[955], 256], 120583: [[956], 256], 120584: [[957], 256], 120585: [[958], 256], 120586: [[959], 256], 120587: [[960], 256], 120588: [[961], 256], 120589: [[962], 256], 120590: [[963], 256], 120591: [[964], 256], 120592: [[965], 256], 120593: [[966], 256], 120594: [[967], 256], 120595: [[968], 256], 120596: [[969], 256], 120597: [[8706], 256], 120598: [[1013], 256], 120599: [[977], 256], 120600: [[1008], 256], 120601: [[981], 256], 120602: [[1009], 256], 120603: [[982], 256], 120604: [[913], 256], 120605: [[914], 256], 120606: [[915], 256], 120607: [[916], 256], 120608: [[917], 256], 120609: [[918], 256], 120610: [[919], 256], 120611: [[920], 256], 120612: [[921], 256], 120613: [[922], 256], 120614: [[923], 256], 120615: [[924], 256], 120616: [[925], 256], 120617: [[926], 256], 120618: [[927], 256], 120619: [[928], 256], 120620: [[929], 256], 120621: [[1012], 256], 120622: [[931], 256], 120623: [[932], 256], 120624: [[933], 256], 120625: [[934], 256], 120626: [[935], 256], 120627: [[936], 256], 120628: [[937], 256], 120629: [[8711], 256], 120630: [[945], 256], 120631: [[946], 256], 120632: [[947], 256], 120633: [[948], 256], 120634: [[949], 256], 120635: [[950], 256], 120636: [[951], 256], 120637: [[952], 256], 120638: [[953], 256], 120639: [[954], 256], 120640: [[955], 256], 120641: [[956], 256], 120642: [[957], 256], 120643: [[958], 256], 120644: [[959], 256], 120645: [[960], 256], 120646: [[961], 256], 120647: [[962], 256], 120648: [[963], 256], 120649: [[964], 256], 120650: [[965], 256], 120651: [[966], 256], 120652: [[967], 256], 120653: [[968], 256], 120654: [[969], 256], 120655: [[8706], 256], 120656: [[1013], 256], 120657: [[977], 256], 120658: [[1008], 256], 120659: [[981], 256], 120660: [[1009], 256], 120661: [[982], 256], 120662: [[913], 256], 120663: [[914], 256], 120664: [[915], 256], 120665: [[916], 256], 120666: [[917], 256], 120667: [[918], 256], 120668: [[919], 256], 120669: [[920], 256], 120670: [[921], 256], 120671: [[922], 256], 120672: [[923], 256], 120673: [[924], 256], 120674: [[925], 256], 120675: [[926], 256], 120676: [[927], 256], 120677: [[928], 256], 120678: [[929], 256], 120679: [[1012], 256], 120680: [[931], 256], 120681: [[932], 256], 120682: [[933], 256], 120683: [[934], 256], 120684: [[935], 256], 120685: [[936], 256], 120686: [[937], 256], 120687: [[8711], 256], 120688: [[945], 256], 120689: [[946], 256], 120690: [[947], 256], 120691: [[948], 256], 120692: [[949], 256], 120693: [[950], 256], 120694: [[951], 256], 120695: [[952], 256], 120696: [[953], 256], 120697: [[954], 256], 120698: [[955], 256], 120699: [[956], 256], 120700: [[957], 256], 120701: [[958], 256], 120702: [[959], 256], 120703: [[960], 256], 120704: [[961], 256], 120705: [[962], 256], 120706: [[963], 256], 120707: [[964], 256], 120708: [[965], 256], 120709: [[966], 256], 120710: [[967], 256], 120711: [[968], 256], 120712: [[969], 256], 120713: [[8706], 256], 120714: [[1013], 256], 120715: [[977], 256], 120716: [[1008], 256], 120717: [[981], 256], 120718: [[1009], 256], 120719: [[982], 256], 120720: [[913], 256], 120721: [[914], 256], 120722: [[915], 256], 120723: [[916], 256], 120724: [[917], 256], 120725: [[918], 256], 120726: [[919], 256], 120727: [[920], 256], 120728: [[921], 256], 120729: [[922], 256], 120730: [[923], 256], 120731: [[924], 256], 120732: [[925], 256], 120733: [[926], 256], 120734: [[927], 256], 120735: [[928], 256], 120736: [[929], 256], 120737: [[1012], 256], 120738: [[931], 256], 120739: [[932], 256], 120740: [[933], 256], 120741: [[934], 256], 120742: [[935], 256], 120743: [[936], 256], 120744: [[937], 256], 120745: [[8711], 256], 120746: [[945], 256], 120747: [[946], 256], 120748: [[947], 256], 120749: [[948], 256], 120750: [[949], 256], 120751: [[950], 256], 120752: [[951], 256], 120753: [[952], 256], 120754: [[953], 256], 120755: [[954], 256], 120756: [[955], 256], 120757: [[956], 256], 120758: [[957], 256], 120759: [[958], 256], 120760: [[959], 256], 120761: [[960], 256], 120762: [[961], 256], 120763: [[962], 256], 120764: [[963], 256], 120765: [[964], 256], 120766: [[965], 256], 120767: [[966], 256], 120768: [[967], 256], 120769: [[968], 256], 120770: [[969], 256], 120771: [[8706], 256], 120772: [[1013], 256], 120773: [[977], 256], 120774: [[1008], 256], 120775: [[981], 256], 120776: [[1009], 256], 120777: [[982], 256], 120778: [[988], 256], 120779: [[989], 256], 120782: [[48], 256], 120783: [[49], 256], 120784: [[50], 256], 120785: [[51], 256], 120786: [[52], 256], 120787: [[53], 256], 120788: [[54], 256], 120789: [[55], 256], 120790: [[56], 256], 120791: [[57], 256], 120792: [[48], 256], 120793: [[49], 256], 120794: [[50], 256], 120795: [[51], 256], 120796: [[52], 256], 120797: [[53], 256], 120798: [[54], 256], 120799: [[55], 256], 120800: [[56], 256], 120801: [[57], 256], 120802: [[48], 256], 120803: [[49], 256], 120804: [[50], 256], 120805: [[51], 256], 120806: [[52], 256], 120807: [[53], 256], 120808: [[54], 256], 120809: [[55], 256], 120810: [[56], 256], 120811: [[57], 256], 120812: [[48], 256], 120813: [[49], 256], 120814: [[50], 256], 120815: [[51], 256], 120816: [[52], 256], 120817: [[53], 256], 120818: [[54], 256], 120819: [[55], 256], 120820: [[56], 256], 120821: [[57], 256], 120822: [[48], 256], 120823: [[49], 256], 120824: [[50], 256], 120825: [[51], 256], 120826: [[52], 256], 120827: [[53], 256], 120828: [[54], 256], 120829: [[55], 256], 120830: [[56], 256], 120831: [[57], 256] },
        59392: { 125136: [, 220], 125137: [, 220], 125138: [, 220], 125139: [, 220], 125140: [, 220], 125141: [, 220], 125142: [, 220] },
        60928: { 126464: [[1575], 256], 126465: [[1576], 256], 126466: [[1580], 256], 126467: [[1583], 256], 126469: [[1608], 256], 126470: [[1586], 256], 126471: [[1581], 256], 126472: [[1591], 256], 126473: [[1610], 256], 126474: [[1603], 256], 126475: [[1604], 256], 126476: [[1605], 256], 126477: [[1606], 256], 126478: [[1587], 256], 126479: [[1593], 256], 126480: [[1601], 256], 126481: [[1589], 256], 126482: [[1602], 256], 126483: [[1585], 256], 126484: [[1588], 256], 126485: [[1578], 256], 126486: [[1579], 256], 126487: [[1582], 256], 126488: [[1584], 256], 126489: [[1590], 256], 126490: [[1592], 256], 126491: [[1594], 256], 126492: [[1646], 256], 126493: [[1722], 256], 126494: [[1697], 256], 126495: [[1647], 256], 126497: [[1576], 256], 126498: [[1580], 256], 126500: [[1607], 256], 126503: [[1581], 256], 126505: [[1610], 256], 126506: [[1603], 256], 126507: [[1604], 256], 126508: [[1605], 256], 126509: [[1606], 256], 126510: [[1587], 256], 126511: [[1593], 256], 126512: [[1601], 256], 126513: [[1589], 256], 126514: [[1602], 256], 126516: [[1588], 256], 126517: [[1578], 256], 126518: [[1579], 256], 126519: [[1582], 256], 126521: [[1590], 256], 126523: [[1594], 256], 126530: [[1580], 256], 126535: [[1581], 256], 126537: [[1610], 256], 126539: [[1604], 256], 126541: [[1606], 256], 126542: [[1587], 256], 126543: [[1593], 256], 126545: [[1589], 256], 126546: [[1602], 256], 126548: [[1588], 256], 126551: [[1582], 256], 126553: [[1590], 256], 126555: [[1594], 256], 126557: [[1722], 256], 126559: [[1647], 256], 126561: [[1576], 256], 126562: [[1580], 256], 126564: [[1607], 256], 126567: [[1581], 256], 126568: [[1591], 256], 126569: [[1610], 256], 126570: [[1603], 256], 126572: [[1605], 256], 126573: [[1606], 256], 126574: [[1587], 256], 126575: [[1593], 256], 126576: [[1601], 256], 126577: [[1589], 256], 126578: [[1602], 256], 126580: [[1588], 256], 126581: [[1578], 256], 126582: [[1579], 256], 126583: [[1582], 256], 126585: [[1590], 256], 126586: [[1592], 256], 126587: [[1594], 256], 126588: [[1646], 256], 126590: [[1697], 256], 126592: [[1575], 256], 126593: [[1576], 256], 126594: [[1580], 256], 126595: [[1583], 256], 126596: [[1607], 256], 126597: [[1608], 256], 126598: [[1586], 256], 126599: [[1581], 256], 126600: [[1591], 256], 126601: [[1610], 256], 126603: [[1604], 256], 126604: [[1605], 256], 126605: [[1606], 256], 126606: [[1587], 256], 126607: [[1593], 256], 126608: [[1601], 256], 126609: [[1589], 256], 126610: [[1602], 256], 126611: [[1585], 256], 126612: [[1588], 256], 126613: [[1578], 256], 126614: [[1579], 256], 126615: [[1582], 256], 126616: [[1584], 256], 126617: [[1590], 256], 126618: [[1592], 256], 126619: [[1594], 256], 126625: [[1576], 256], 126626: [[1580], 256], 126627: [[1583], 256], 126629: [[1608], 256], 126630: [[1586], 256], 126631: [[1581], 256], 126632: [[1591], 256], 126633: [[1610], 256], 126635: [[1604], 256], 126636: [[1605], 256], 126637: [[1606], 256], 126638: [[1587], 256], 126639: [[1593], 256], 126640: [[1601], 256], 126641: [[1589], 256], 126642: [[1602], 256], 126643: [[1585], 256], 126644: [[1588], 256], 126645: [[1578], 256], 126646: [[1579], 256], 126647: [[1582], 256], 126648: [[1584], 256], 126649: [[1590], 256], 126650: [[1592], 256], 126651: [[1594], 256] },
        61696: { 127232: [[48, 46], 256], 127233: [[48, 44], 256], 127234: [[49, 44], 256], 127235: [[50, 44], 256], 127236: [[51, 44], 256], 127237: [[52, 44], 256], 127238: [[53, 44], 256], 127239: [[54, 44], 256], 127240: [[55, 44], 256], 127241: [[56, 44], 256], 127242: [[57, 44], 256], 127248: [[40, 65, 41], 256], 127249: [[40, 66, 41], 256], 127250: [[40, 67, 41], 256], 127251: [[40, 68, 41], 256], 127252: [[40, 69, 41], 256], 127253: [[40, 70, 41], 256], 127254: [[40, 71, 41], 256], 127255: [[40, 72, 41], 256], 127256: [[40, 73, 41], 256], 127257: [[40, 74, 41], 256], 127258: [[40, 75, 41], 256], 127259: [[40, 76, 41], 256], 127260: [[40, 77, 41], 256], 127261: [[40, 78, 41], 256], 127262: [[40, 79, 41], 256], 127263: [[40, 80, 41], 256], 127264: [[40, 81, 41], 256], 127265: [[40, 82, 41], 256], 127266: [[40, 83, 41], 256], 127267: [[40, 84, 41], 256], 127268: [[40, 85, 41], 256], 127269: [[40, 86, 41], 256], 127270: [[40, 87, 41], 256], 127271: [[40, 88, 41], 256], 127272: [[40, 89, 41], 256], 127273: [[40, 90, 41], 256], 127274: [[12308, 83, 12309], 256], 127275: [[67], 256], 127276: [[82], 256], 127277: [[67, 68], 256], 127278: [[87, 90], 256], 127280: [[65], 256], 127281: [[66], 256], 127282: [[67], 256], 127283: [[68], 256], 127284: [[69], 256], 127285: [[70], 256], 127286: [[71], 256], 127287: [[72], 256], 127288: [[73], 256], 127289: [[74], 256], 127290: [[75], 256], 127291: [[76], 256], 127292: [[77], 256], 127293: [[78], 256], 127294: [[79], 256], 127295: [[80], 256], 127296: [[81], 256], 127297: [[82], 256], 127298: [[83], 256], 127299: [[84], 256], 127300: [[85], 256], 127301: [[86], 256], 127302: [[87], 256], 127303: [[88], 256], 127304: [[89], 256], 127305: [[90], 256], 127306: [[72, 86], 256], 127307: [[77, 86], 256], 127308: [[83, 68], 256], 127309: [[83, 83], 256], 127310: [[80, 80, 86], 256], 127311: [[87, 67], 256], 127338: [[77, 67], 256], 127339: [[77, 68], 256], 127376: [[68, 74], 256] },
        61952: { 127488: [[12411, 12363], 256], 127489: [[12467, 12467], 256], 127490: [[12469], 256], 127504: [[25163], 256], 127505: [[23383], 256], 127506: [[21452], 256], 127507: [[12487], 256], 127508: [[20108], 256], 127509: [[22810], 256], 127510: [[35299], 256], 127511: [[22825], 256], 127512: [[20132], 256], 127513: [[26144], 256], 127514: [[28961], 256], 127515: [[26009], 256], 127516: [[21069], 256], 127517: [[24460], 256], 127518: [[20877], 256], 127519: [[26032], 256], 127520: [[21021], 256], 127521: [[32066], 256], 127522: [[29983], 256], 127523: [[36009], 256], 127524: [[22768], 256], 127525: [[21561], 256], 127526: [[28436], 256], 127527: [[25237], 256], 127528: [[25429], 256], 127529: [[19968], 256], 127530: [[19977], 256], 127531: [[36938], 256], 127532: [[24038], 256], 127533: [[20013], 256], 127534: [[21491], 256], 127535: [[25351], 256], 127536: [[36208], 256], 127537: [[25171], 256], 127538: [[31105], 256], 127539: [[31354], 256], 127540: [[21512], 256], 127541: [[28288], 256], 127542: [[26377], 256], 127543: [[26376], 256], 127544: [[30003], 256], 127545: [[21106], 256], 127546: [[21942], 256], 127552: [[12308, 26412, 12309], 256], 127553: [[12308, 19977, 12309], 256], 127554: [[12308, 20108, 12309], 256], 127555: [[12308, 23433, 12309], 256], 127556: [[12308, 28857, 12309], 256], 127557: [[12308, 25171, 12309], 256], 127558: [[12308, 30423, 12309], 256], 127559: [[12308, 21213, 12309], 256], 127560: [[12308, 25943, 12309], 256], 127568: [[24471], 256], 127569: [[21487], 256] },
        63488: { 194560: [[20029]], 194561: [[20024]], 194562: [[20033]], 194563: [[131362]], 194564: [[20320]], 194565: [[20398]], 194566: [[20411]], 194567: [[20482]], 194568: [[20602]], 194569: [[20633]], 194570: [[20711]], 194571: [[20687]], 194572: [[13470]], 194573: [[132666]], 194574: [[20813]], 194575: [[20820]], 194576: [[20836]], 194577: [[20855]], 194578: [[132380]], 194579: [[13497]], 194580: [[20839]], 194581: [[20877]], 194582: [[132427]], 194583: [[20887]], 194584: [[20900]], 194585: [[20172]], 194586: [[20908]], 194587: [[20917]], 194588: [[168415]], 194589: [[20981]], 194590: [[20995]], 194591: [[13535]], 194592: [[21051]], 194593: [[21062]], 194594: [[21106]], 194595: [[21111]], 194596: [[13589]], 194597: [[21191]], 194598: [[21193]], 194599: [[21220]], 194600: [[21242]], 194601: [[21253]], 194602: [[21254]], 194603: [[21271]], 194604: [[21321]], 194605: [[21329]], 194606: [[21338]], 194607: [[21363]], 194608: [[21373]], 194609: [[21375]], 194610: [[21375]], 194611: [[21375]], 194612: [[133676]], 194613: [[28784]], 194614: [[21450]], 194615: [[21471]], 194616: [[133987]], 194617: [[21483]], 194618: [[21489]], 194619: [[21510]], 194620: [[21662]], 194621: [[21560]], 194622: [[21576]], 194623: [[21608]], 194624: [[21666]], 194625: [[21750]], 194626: [[21776]], 194627: [[21843]], 194628: [[21859]], 194629: [[21892]], 194630: [[21892]], 194631: [[21913]], 194632: [[21931]], 194633: [[21939]], 194634: [[21954]], 194635: [[22294]], 194636: [[22022]], 194637: [[22295]], 194638: [[22097]], 194639: [[22132]], 194640: [[20999]], 194641: [[22766]], 194642: [[22478]], 194643: [[22516]], 194644: [[22541]], 194645: [[22411]], 194646: [[22578]], 194647: [[22577]], 194648: [[22700]], 194649: [[136420]], 194650: [[22770]], 194651: [[22775]], 194652: [[22790]], 194653: [[22810]], 194654: [[22818]], 194655: [[22882]], 194656: [[136872]], 194657: [[136938]], 194658: [[23020]], 194659: [[23067]], 194660: [[23079]], 194661: [[23e3]], 194662: [[23142]], 194663: [[14062]], 194664: [[14076]], 194665: [[23304]], 194666: [[23358]], 194667: [[23358]], 194668: [[137672]], 194669: [[23491]], 194670: [[23512]], 194671: [[23527]], 194672: [[23539]], 194673: [[138008]], 194674: [[23551]], 194675: [[23558]], 194676: [[24403]], 194677: [[23586]], 194678: [[14209]], 194679: [[23648]], 194680: [[23662]], 194681: [[23744]], 194682: [[23693]], 194683: [[138724]], 194684: [[23875]], 194685: [[138726]], 194686: [[23918]], 194687: [[23915]], 194688: [[23932]], 194689: [[24033]], 194690: [[24034]], 194691: [[14383]], 194692: [[24061]], 194693: [[24104]], 194694: [[24125]], 194695: [[24169]], 194696: [[14434]], 194697: [[139651]], 194698: [[14460]], 194699: [[24240]], 194700: [[24243]], 194701: [[24246]], 194702: [[24266]], 194703: [[172946]], 194704: [[24318]], 194705: [[140081]], 194706: [[140081]], 194707: [[33281]], 194708: [[24354]], 194709: [[24354]], 194710: [[14535]], 194711: [[144056]], 194712: [[156122]], 194713: [[24418]], 194714: [[24427]], 194715: [[14563]], 194716: [[24474]], 194717: [[24525]], 194718: [[24535]], 194719: [[24569]], 194720: [[24705]], 194721: [[14650]], 194722: [[14620]], 194723: [[24724]], 194724: [[141012]], 194725: [[24775]], 194726: [[24904]], 194727: [[24908]], 194728: [[24910]], 194729: [[24908]], 194730: [[24954]], 194731: [[24974]], 194732: [[25010]], 194733: [[24996]], 194734: [[25007]], 194735: [[25054]], 194736: [[25074]], 194737: [[25078]], 194738: [[25104]], 194739: [[25115]], 194740: [[25181]], 194741: [[25265]], 194742: [[25300]], 194743: [[25424]], 194744: [[142092]], 194745: [[25405]], 194746: [[25340]], 194747: [[25448]], 194748: [[25475]], 194749: [[25572]], 194750: [[142321]], 194751: [[25634]], 194752: [[25541]], 194753: [[25513]], 194754: [[14894]], 194755: [[25705]], 194756: [[25726]], 194757: [[25757]], 194758: [[25719]], 194759: [[14956]], 194760: [[25935]], 194761: [[25964]], 194762: [[143370]], 194763: [[26083]], 194764: [[26360]], 194765: [[26185]], 194766: [[15129]], 194767: [[26257]], 194768: [[15112]], 194769: [[15076]], 194770: [[20882]], 194771: [[20885]], 194772: [[26368]], 194773: [[26268]], 194774: [[32941]], 194775: [[17369]], 194776: [[26391]], 194777: [[26395]], 194778: [[26401]], 194779: [[26462]], 194780: [[26451]], 194781: [[144323]], 194782: [[15177]], 194783: [[26618]], 194784: [[26501]], 194785: [[26706]], 194786: [[26757]], 194787: [[144493]], 194788: [[26766]], 194789: [[26655]], 194790: [[26900]], 194791: [[15261]], 194792: [[26946]], 194793: [[27043]], 194794: [[27114]], 194795: [[27304]], 194796: [[145059]], 194797: [[27355]], 194798: [[15384]], 194799: [[27425]], 194800: [[145575]], 194801: [[27476]], 194802: [[15438]], 194803: [[27506]], 194804: [[27551]], 194805: [[27578]], 194806: [[27579]], 194807: [[146061]], 194808: [[138507]], 194809: [[146170]], 194810: [[27726]], 194811: [[146620]], 194812: [[27839]], 194813: [[27853]], 194814: [[27751]], 194815: [[27926]] },
        63744: { 63744: [[35912]], 63745: [[26356]], 63746: [[36554]], 63747: [[36040]], 63748: [[28369]], 63749: [[20018]], 63750: [[21477]], 63751: [[40860]], 63752: [[40860]], 63753: [[22865]], 63754: [[37329]], 63755: [[21895]], 63756: [[22856]], 63757: [[25078]], 63758: [[30313]], 63759: [[32645]], 63760: [[34367]], 63761: [[34746]], 63762: [[35064]], 63763: [[37007]], 63764: [[27138]], 63765: [[27931]], 63766: [[28889]], 63767: [[29662]], 63768: [[33853]], 63769: [[37226]], 63770: [[39409]], 63771: [[20098]], 63772: [[21365]], 63773: [[27396]], 63774: [[29211]], 63775: [[34349]], 63776: [[40478]], 63777: [[23888]], 63778: [[28651]], 63779: [[34253]], 63780: [[35172]], 63781: [[25289]], 63782: [[33240]], 63783: [[34847]], 63784: [[24266]], 63785: [[26391]], 63786: [[28010]], 63787: [[29436]], 63788: [[37070]], 63789: [[20358]], 63790: [[20919]], 63791: [[21214]], 63792: [[25796]], 63793: [[27347]], 63794: [[29200]], 63795: [[30439]], 63796: [[32769]], 63797: [[34310]], 63798: [[34396]], 63799: [[36335]], 63800: [[38706]], 63801: [[39791]], 63802: [[40442]], 63803: [[30860]], 63804: [[31103]], 63805: [[32160]], 63806: [[33737]], 63807: [[37636]], 63808: [[40575]], 63809: [[35542]], 63810: [[22751]], 63811: [[24324]], 63812: [[31840]], 63813: [[32894]], 63814: [[29282]], 63815: [[30922]], 63816: [[36034]], 63817: [[38647]], 63818: [[22744]], 63819: [[23650]], 63820: [[27155]], 63821: [[28122]], 63822: [[28431]], 63823: [[32047]], 63824: [[32311]], 63825: [[38475]], 63826: [[21202]], 63827: [[32907]], 63828: [[20956]], 63829: [[20940]], 63830: [[31260]], 63831: [[32190]], 63832: [[33777]], 63833: [[38517]], 63834: [[35712]], 63835: [[25295]], 63836: [[27138]], 63837: [[35582]], 63838: [[20025]], 63839: [[23527]], 63840: [[24594]], 63841: [[29575]], 63842: [[30064]], 63843: [[21271]], 63844: [[30971]], 63845: [[20415]], 63846: [[24489]], 63847: [[19981]], 63848: [[27852]], 63849: [[25976]], 63850: [[32034]], 63851: [[21443]], 63852: [[22622]], 63853: [[30465]], 63854: [[33865]], 63855: [[35498]], 63856: [[27578]], 63857: [[36784]], 63858: [[27784]], 63859: [[25342]], 63860: [[33509]], 63861: [[25504]], 63862: [[30053]], 63863: [[20142]], 63864: [[20841]], 63865: [[20937]], 63866: [[26753]], 63867: [[31975]], 63868: [[33391]], 63869: [[35538]], 63870: [[37327]], 63871: [[21237]], 63872: [[21570]], 63873: [[22899]], 63874: [[24300]], 63875: [[26053]], 63876: [[28670]], 63877: [[31018]], 63878: [[38317]], 63879: [[39530]], 63880: [[40599]], 63881: [[40654]], 63882: [[21147]], 63883: [[26310]], 63884: [[27511]], 63885: [[36706]], 63886: [[24180]], 63887: [[24976]], 63888: [[25088]], 63889: [[25754]], 63890: [[28451]], 63891: [[29001]], 63892: [[29833]], 63893: [[31178]], 63894: [[32244]], 63895: [[32879]], 63896: [[36646]], 63897: [[34030]], 63898: [[36899]], 63899: [[37706]], 63900: [[21015]], 63901: [[21155]], 63902: [[21693]], 63903: [[28872]], 63904: [[35010]], 63905: [[35498]], 63906: [[24265]], 63907: [[24565]], 63908: [[25467]], 63909: [[27566]], 63910: [[31806]], 63911: [[29557]], 63912: [[20196]], 63913: [[22265]], 63914: [[23527]], 63915: [[23994]], 63916: [[24604]], 63917: [[29618]], 63918: [[29801]], 63919: [[32666]], 63920: [[32838]], 63921: [[37428]], 63922: [[38646]], 63923: [[38728]], 63924: [[38936]], 63925: [[20363]], 63926: [[31150]], 63927: [[37300]], 63928: [[38584]], 63929: [[24801]], 63930: [[20102]], 63931: [[20698]], 63932: [[23534]], 63933: [[23615]], 63934: [[26009]], 63935: [[27138]], 63936: [[29134]], 63937: [[30274]], 63938: [[34044]], 63939: [[36988]], 63940: [[40845]], 63941: [[26248]], 63942: [[38446]], 63943: [[21129]], 63944: [[26491]], 63945: [[26611]], 63946: [[27969]], 63947: [[28316]], 63948: [[29705]], 63949: [[30041]], 63950: [[30827]], 63951: [[32016]], 63952: [[39006]], 63953: [[20845]], 63954: [[25134]], 63955: [[38520]], 63956: [[20523]], 63957: [[23833]], 63958: [[28138]], 63959: [[36650]], 63960: [[24459]], 63961: [[24900]], 63962: [[26647]], 63963: [[29575]], 63964: [[38534]], 63965: [[21033]], 63966: [[21519]], 63967: [[23653]], 63968: [[26131]], 63969: [[26446]], 63970: [[26792]], 63971: [[27877]], 63972: [[29702]], 63973: [[30178]], 63974: [[32633]], 63975: [[35023]], 63976: [[35041]], 63977: [[37324]], 63978: [[38626]], 63979: [[21311]], 63980: [[28346]], 63981: [[21533]], 63982: [[29136]], 63983: [[29848]], 63984: [[34298]], 63985: [[38563]], 63986: [[40023]], 63987: [[40607]], 63988: [[26519]], 63989: [[28107]], 63990: [[33256]], 63991: [[31435]], 63992: [[31520]], 63993: [[31890]], 63994: [[29376]], 63995: [[28825]], 63996: [[35672]], 63997: [[20160]], 63998: [[33590]], 63999: [[21050]], 194816: [[27966]], 194817: [[28023]], 194818: [[27969]], 194819: [[28009]], 194820: [[28024]], 194821: [[28037]], 194822: [[146718]], 194823: [[27956]], 194824: [[28207]], 194825: [[28270]], 194826: [[15667]], 194827: [[28363]], 194828: [[28359]], 194829: [[147153]], 194830: [[28153]], 194831: [[28526]], 194832: [[147294]], 194833: [[147342]], 194834: [[28614]], 194835: [[28729]], 194836: [[28702]], 194837: [[28699]], 194838: [[15766]], 194839: [[28746]], 194840: [[28797]], 194841: [[28791]], 194842: [[28845]], 194843: [[132389]], 194844: [[28997]], 194845: [[148067]], 194846: [[29084]], 194847: [[148395]], 194848: [[29224]], 194849: [[29237]], 194850: [[29264]], 194851: [[149e3]], 194852: [[29312]], 194853: [[29333]], 194854: [[149301]], 194855: [[149524]], 194856: [[29562]], 194857: [[29579]], 194858: [[16044]], 194859: [[29605]], 194860: [[16056]], 194861: [[16056]], 194862: [[29767]], 194863: [[29788]], 194864: [[29809]], 194865: [[29829]], 194866: [[29898]], 194867: [[16155]], 194868: [[29988]], 194869: [[150582]], 194870: [[30014]], 194871: [[150674]], 194872: [[30064]], 194873: [[139679]], 194874: [[30224]], 194875: [[151457]], 194876: [[151480]], 194877: [[151620]], 194878: [[16380]], 194879: [[16392]], 194880: [[30452]], 194881: [[151795]], 194882: [[151794]], 194883: [[151833]], 194884: [[151859]], 194885: [[30494]], 194886: [[30495]], 194887: [[30495]], 194888: [[30538]], 194889: [[16441]], 194890: [[30603]], 194891: [[16454]], 194892: [[16534]], 194893: [[152605]], 194894: [[30798]], 194895: [[30860]], 194896: [[30924]], 194897: [[16611]], 194898: [[153126]], 194899: [[31062]], 194900: [[153242]], 194901: [[153285]], 194902: [[31119]], 194903: [[31211]], 194904: [[16687]], 194905: [[31296]], 194906: [[31306]], 194907: [[31311]], 194908: [[153980]], 194909: [[154279]], 194910: [[154279]], 194911: [[31470]], 194912: [[16898]], 194913: [[154539]], 194914: [[31686]], 194915: [[31689]], 194916: [[16935]], 194917: [[154752]], 194918: [[31954]], 194919: [[17056]], 194920: [[31976]], 194921: [[31971]], 194922: [[32e3]], 194923: [[155526]], 194924: [[32099]], 194925: [[17153]], 194926: [[32199]], 194927: [[32258]], 194928: [[32325]], 194929: [[17204]], 194930: [[156200]], 194931: [[156231]], 194932: [[17241]], 194933: [[156377]], 194934: [[32634]], 194935: [[156478]], 194936: [[32661]], 194937: [[32762]], 194938: [[32773]], 194939: [[156890]], 194940: [[156963]], 194941: [[32864]], 194942: [[157096]], 194943: [[32880]], 194944: [[144223]], 194945: [[17365]], 194946: [[32946]], 194947: [[33027]], 194948: [[17419]], 194949: [[33086]], 194950: [[23221]], 194951: [[157607]], 194952: [[157621]], 194953: [[144275]], 194954: [[144284]], 194955: [[33281]], 194956: [[33284]], 194957: [[36766]], 194958: [[17515]], 194959: [[33425]], 194960: [[33419]], 194961: [[33437]], 194962: [[21171]], 194963: [[33457]], 194964: [[33459]], 194965: [[33469]], 194966: [[33510]], 194967: [[158524]], 194968: [[33509]], 194969: [[33565]], 194970: [[33635]], 194971: [[33709]], 194972: [[33571]], 194973: [[33725]], 194974: [[33767]], 194975: [[33879]], 194976: [[33619]], 194977: [[33738]], 194978: [[33740]], 194979: [[33756]], 194980: [[158774]], 194981: [[159083]], 194982: [[158933]], 194983: [[17707]], 194984: [[34033]], 194985: [[34035]], 194986: [[34070]], 194987: [[160714]], 194988: [[34148]], 194989: [[159532]], 194990: [[17757]], 194991: [[17761]], 194992: [[159665]], 194993: [[159954]], 194994: [[17771]], 194995: [[34384]], 194996: [[34396]], 194997: [[34407]], 194998: [[34409]], 194999: [[34473]], 195e3: [[34440]], 195001: [[34574]], 195002: [[34530]], 195003: [[34681]], 195004: [[34600]], 195005: [[34667]], 195006: [[34694]], 195007: [[17879]], 195008: [[34785]], 195009: [[34817]], 195010: [[17913]], 195011: [[34912]], 195012: [[34915]], 195013: [[161383]], 195014: [[35031]], 195015: [[35038]], 195016: [[17973]], 195017: [[35066]], 195018: [[13499]], 195019: [[161966]], 195020: [[162150]], 195021: [[18110]], 195022: [[18119]], 195023: [[35488]], 195024: [[35565]], 195025: [[35722]], 195026: [[35925]], 195027: [[162984]], 195028: [[36011]], 195029: [[36033]], 195030: [[36123]], 195031: [[36215]], 195032: [[163631]], 195033: [[133124]], 195034: [[36299]], 195035: [[36284]], 195036: [[36336]], 195037: [[133342]], 195038: [[36564]], 195039: [[36664]], 195040: [[165330]], 195041: [[165357]], 195042: [[37012]], 195043: [[37105]], 195044: [[37137]], 195045: [[165678]], 195046: [[37147]], 195047: [[37432]], 195048: [[37591]], 195049: [[37592]], 195050: [[37500]], 195051: [[37881]], 195052: [[37909]], 195053: [[166906]], 195054: [[38283]], 195055: [[18837]], 195056: [[38327]], 195057: [[167287]], 195058: [[18918]], 195059: [[38595]], 195060: [[23986]], 195061: [[38691]], 195062: [[168261]], 195063: [[168474]], 195064: [[19054]], 195065: [[19062]], 195066: [[38880]], 195067: [[168970]], 195068: [[19122]], 195069: [[169110]], 195070: [[38923]], 195071: [[38923]] },
        64e3: { 64e3: [[20999]], 64001: [[24230]], 64002: [[25299]], 64003: [[31958]], 64004: [[23429]], 64005: [[27934]], 64006: [[26292]], 64007: [[36667]], 64008: [[34892]], 64009: [[38477]], 64010: [[35211]], 64011: [[24275]], 64012: [[20800]], 64013: [[21952]], 64016: [[22618]], 64018: [[26228]], 64021: [[20958]], 64022: [[29482]], 64023: [[30410]], 64024: [[31036]], 64025: [[31070]], 64026: [[31077]], 64027: [[31119]], 64028: [[38742]], 64029: [[31934]], 64030: [[32701]], 64032: [[34322]], 64034: [[35576]], 64037: [[36920]], 64038: [[37117]], 64042: [[39151]], 64043: [[39164]], 64044: [[39208]], 64045: [[40372]], 64046: [[37086]], 64047: [[38583]], 64048: [[20398]], 64049: [[20711]], 64050: [[20813]], 64051: [[21193]], 64052: [[21220]], 64053: [[21329]], 64054: [[21917]], 64055: [[22022]], 64056: [[22120]], 64057: [[22592]], 64058: [[22696]], 64059: [[23652]], 64060: [[23662]], 64061: [[24724]], 64062: [[24936]], 64063: [[24974]], 64064: [[25074]], 64065: [[25935]], 64066: [[26082]], 64067: [[26257]], 64068: [[26757]], 64069: [[28023]], 64070: [[28186]], 64071: [[28450]], 64072: [[29038]], 64073: [[29227]], 64074: [[29730]], 64075: [[30865]], 64076: [[31038]], 64077: [[31049]], 64078: [[31048]], 64079: [[31056]], 64080: [[31062]], 64081: [[31069]], 64082: [[31117]], 64083: [[31118]], 64084: [[31296]], 64085: [[31361]], 64086: [[31680]], 64087: [[32244]], 64088: [[32265]], 64089: [[32321]], 64090: [[32626]], 64091: [[32773]], 64092: [[33261]], 64093: [[33401]], 64094: [[33401]], 64095: [[33879]], 64096: [[35088]], 64097: [[35222]], 64098: [[35585]], 64099: [[35641]], 64100: [[36051]], 64101: [[36104]], 64102: [[36790]], 64103: [[36920]], 64104: [[38627]], 64105: [[38911]], 64106: [[38971]], 64107: [[24693]], 64108: [[148206]], 64109: [[33304]], 64112: [[20006]], 64113: [[20917]], 64114: [[20840]], 64115: [[20352]], 64116: [[20805]], 64117: [[20864]], 64118: [[21191]], 64119: [[21242]], 64120: [[21917]], 64121: [[21845]], 64122: [[21913]], 64123: [[21986]], 64124: [[22618]], 64125: [[22707]], 64126: [[22852]], 64127: [[22868]], 64128: [[23138]], 64129: [[23336]], 64130: [[24274]], 64131: [[24281]], 64132: [[24425]], 64133: [[24493]], 64134: [[24792]], 64135: [[24910]], 64136: [[24840]], 64137: [[24974]], 64138: [[24928]], 64139: [[25074]], 64140: [[25140]], 64141: [[25540]], 64142: [[25628]], 64143: [[25682]], 64144: [[25942]], 64145: [[26228]], 64146: [[26391]], 64147: [[26395]], 64148: [[26454]], 64149: [[27513]], 64150: [[27578]], 64151: [[27969]], 64152: [[28379]], 64153: [[28363]], 64154: [[28450]], 64155: [[28702]], 64156: [[29038]], 64157: [[30631]], 64158: [[29237]], 64159: [[29359]], 64160: [[29482]], 64161: [[29809]], 64162: [[29958]], 64163: [[30011]], 64164: [[30237]], 64165: [[30239]], 64166: [[30410]], 64167: [[30427]], 64168: [[30452]], 64169: [[30538]], 64170: [[30528]], 64171: [[30924]], 64172: [[31409]], 64173: [[31680]], 64174: [[31867]], 64175: [[32091]], 64176: [[32244]], 64177: [[32574]], 64178: [[32773]], 64179: [[33618]], 64180: [[33775]], 64181: [[34681]], 64182: [[35137]], 64183: [[35206]], 64184: [[35222]], 64185: [[35519]], 64186: [[35576]], 64187: [[35531]], 64188: [[35585]], 64189: [[35582]], 64190: [[35565]], 64191: [[35641]], 64192: [[35722]], 64193: [[36104]], 64194: [[36664]], 64195: [[36978]], 64196: [[37273]], 64197: [[37494]], 64198: [[38524]], 64199: [[38627]], 64200: [[38742]], 64201: [[38875]], 64202: [[38911]], 64203: [[38923]], 64204: [[38971]], 64205: [[39698]], 64206: [[40860]], 64207: [[141386]], 64208: [[141380]], 64209: [[144341]], 64210: [[15261]], 64211: [[16408]], 64212: [[16441]], 64213: [[152137]], 64214: [[154832]], 64215: [[163539]], 64216: [[40771]], 64217: [[40846]], 195072: [[38953]], 195073: [[169398]], 195074: [[39138]], 195075: [[19251]], 195076: [[39209]], 195077: [[39335]], 195078: [[39362]], 195079: [[39422]], 195080: [[19406]], 195081: [[170800]], 195082: [[39698]], 195083: [[4e4]], 195084: [[40189]], 195085: [[19662]], 195086: [[19693]], 195087: [[40295]], 195088: [[172238]], 195089: [[19704]], 195090: [[172293]], 195091: [[172558]], 195092: [[172689]], 195093: [[40635]], 195094: [[19798]], 195095: [[40697]], 195096: [[40702]], 195097: [[40709]], 195098: [[40719]], 195099: [[40726]], 195100: [[40763]], 195101: [[173568]] },
        64256: { 64256: [[102, 102], 256], 64257: [[102, 105], 256], 64258: [[102, 108], 256], 64259: [[102, 102, 105], 256], 64260: [[102, 102, 108], 256], 64261: [[383, 116], 256], 64262: [[115, 116], 256], 64275: [[1396, 1398], 256], 64276: [[1396, 1381], 256], 64277: [[1396, 1387], 256], 64278: [[1406, 1398], 256], 64279: [[1396, 1389], 256], 64285: [[1497, 1460], 512], 64286: [, 26], 64287: [[1522, 1463], 512], 64288: [[1506], 256], 64289: [[1488], 256], 64290: [[1491], 256], 64291: [[1492], 256], 64292: [[1499], 256], 64293: [[1500], 256], 64294: [[1501], 256], 64295: [[1512], 256], 64296: [[1514], 256], 64297: [[43], 256], 64298: [[1513, 1473], 512], 64299: [[1513, 1474], 512], 64300: [[64329, 1473], 512], 64301: [[64329, 1474], 512], 64302: [[1488, 1463], 512], 64303: [[1488, 1464], 512], 64304: [[1488, 1468], 512], 64305: [[1489, 1468], 512], 64306: [[1490, 1468], 512], 64307: [[1491, 1468], 512], 64308: [[1492, 1468], 512], 64309: [[1493, 1468], 512], 64310: [[1494, 1468], 512], 64312: [[1496, 1468], 512], 64313: [[1497, 1468], 512], 64314: [[1498, 1468], 512], 64315: [[1499, 1468], 512], 64316: [[1500, 1468], 512], 64318: [[1502, 1468], 512], 64320: [[1504, 1468], 512], 64321: [[1505, 1468], 512], 64323: [[1507, 1468], 512], 64324: [[1508, 1468], 512], 64326: [[1510, 1468], 512], 64327: [[1511, 1468], 512], 64328: [[1512, 1468], 512], 64329: [[1513, 1468], 512], 64330: [[1514, 1468], 512], 64331: [[1493, 1465], 512], 64332: [[1489, 1471], 512], 64333: [[1499, 1471], 512], 64334: [[1508, 1471], 512], 64335: [[1488, 1500], 256], 64336: [[1649], 256], 64337: [[1649], 256], 64338: [[1659], 256], 64339: [[1659], 256], 64340: [[1659], 256], 64341: [[1659], 256], 64342: [[1662], 256], 64343: [[1662], 256], 64344: [[1662], 256], 64345: [[1662], 256], 64346: [[1664], 256], 64347: [[1664], 256], 64348: [[1664], 256], 64349: [[1664], 256], 64350: [[1658], 256], 64351: [[1658], 256], 64352: [[1658], 256], 64353: [[1658], 256], 64354: [[1663], 256], 64355: [[1663], 256], 64356: [[1663], 256], 64357: [[1663], 256], 64358: [[1657], 256], 64359: [[1657], 256], 64360: [[1657], 256], 64361: [[1657], 256], 64362: [[1700], 256], 64363: [[1700], 256], 64364: [[1700], 256], 64365: [[1700], 256], 64366: [[1702], 256], 64367: [[1702], 256], 64368: [[1702], 256], 64369: [[1702], 256], 64370: [[1668], 256], 64371: [[1668], 256], 64372: [[1668], 256], 64373: [[1668], 256], 64374: [[1667], 256], 64375: [[1667], 256], 64376: [[1667], 256], 64377: [[1667], 256], 64378: [[1670], 256], 64379: [[1670], 256], 64380: [[1670], 256], 64381: [[1670], 256], 64382: [[1671], 256], 64383: [[1671], 256], 64384: [[1671], 256], 64385: [[1671], 256], 64386: [[1677], 256], 64387: [[1677], 256], 64388: [[1676], 256], 64389: [[1676], 256], 64390: [[1678], 256], 64391: [[1678], 256], 64392: [[1672], 256], 64393: [[1672], 256], 64394: [[1688], 256], 64395: [[1688], 256], 64396: [[1681], 256], 64397: [[1681], 256], 64398: [[1705], 256], 64399: [[1705], 256], 64400: [[1705], 256], 64401: [[1705], 256], 64402: [[1711], 256], 64403: [[1711], 256], 64404: [[1711], 256], 64405: [[1711], 256], 64406: [[1715], 256], 64407: [[1715], 256], 64408: [[1715], 256], 64409: [[1715], 256], 64410: [[1713], 256], 64411: [[1713], 256], 64412: [[1713], 256], 64413: [[1713], 256], 64414: [[1722], 256], 64415: [[1722], 256], 64416: [[1723], 256], 64417: [[1723], 256], 64418: [[1723], 256], 64419: [[1723], 256], 64420: [[1728], 256], 64421: [[1728], 256], 64422: [[1729], 256], 64423: [[1729], 256], 64424: [[1729], 256], 64425: [[1729], 256], 64426: [[1726], 256], 64427: [[1726], 256], 64428: [[1726], 256], 64429: [[1726], 256], 64430: [[1746], 256], 64431: [[1746], 256], 64432: [[1747], 256], 64433: [[1747], 256], 64467: [[1709], 256], 64468: [[1709], 256], 64469: [[1709], 256], 64470: [[1709], 256], 64471: [[1735], 256], 64472: [[1735], 256], 64473: [[1734], 256], 64474: [[1734], 256], 64475: [[1736], 256], 64476: [[1736], 256], 64477: [[1655], 256], 64478: [[1739], 256], 64479: [[1739], 256], 64480: [[1733], 256], 64481: [[1733], 256], 64482: [[1737], 256], 64483: [[1737], 256], 64484: [[1744], 256], 64485: [[1744], 256], 64486: [[1744], 256], 64487: [[1744], 256], 64488: [[1609], 256], 64489: [[1609], 256], 64490: [[1574, 1575], 256], 64491: [[1574, 1575], 256], 64492: [[1574, 1749], 256], 64493: [[1574, 1749], 256], 64494: [[1574, 1608], 256], 64495: [[1574, 1608], 256], 64496: [[1574, 1735], 256], 64497: [[1574, 1735], 256], 64498: [[1574, 1734], 256], 64499: [[1574, 1734], 256], 64500: [[1574, 1736], 256], 64501: [[1574, 1736], 256], 64502: [[1574, 1744], 256], 64503: [[1574, 1744], 256], 64504: [[1574, 1744], 256], 64505: [[1574, 1609], 256], 64506: [[1574, 1609], 256], 64507: [[1574, 1609], 256], 64508: [[1740], 256], 64509: [[1740], 256], 64510: [[1740], 256], 64511: [[1740], 256] },
        64512: { 64512: [[1574, 1580], 256], 64513: [[1574, 1581], 256], 64514: [[1574, 1605], 256], 64515: [[1574, 1609], 256], 64516: [[1574, 1610], 256], 64517: [[1576, 1580], 256], 64518: [[1576, 1581], 256], 64519: [[1576, 1582], 256], 64520: [[1576, 1605], 256], 64521: [[1576, 1609], 256], 64522: [[1576, 1610], 256], 64523: [[1578, 1580], 256], 64524: [[1578, 1581], 256], 64525: [[1578, 1582], 256], 64526: [[1578, 1605], 256], 64527: [[1578, 1609], 256], 64528: [[1578, 1610], 256], 64529: [[1579, 1580], 256], 64530: [[1579, 1605], 256], 64531: [[1579, 1609], 256], 64532: [[1579, 1610], 256], 64533: [[1580, 1581], 256], 64534: [[1580, 1605], 256], 64535: [[1581, 1580], 256], 64536: [[1581, 1605], 256], 64537: [[1582, 1580], 256], 64538: [[1582, 1581], 256], 64539: [[1582, 1605], 256], 64540: [[1587, 1580], 256], 64541: [[1587, 1581], 256], 64542: [[1587, 1582], 256], 64543: [[1587, 1605], 256], 64544: [[1589, 1581], 256], 64545: [[1589, 1605], 256], 64546: [[1590, 1580], 256], 64547: [[1590, 1581], 256], 64548: [[1590, 1582], 256], 64549: [[1590, 1605], 256], 64550: [[1591, 1581], 256], 64551: [[1591, 1605], 256], 64552: [[1592, 1605], 256], 64553: [[1593, 1580], 256], 64554: [[1593, 1605], 256], 64555: [[1594, 1580], 256], 64556: [[1594, 1605], 256], 64557: [[1601, 1580], 256], 64558: [[1601, 1581], 256], 64559: [[1601, 1582], 256], 64560: [[1601, 1605], 256], 64561: [[1601, 1609], 256], 64562: [[1601, 1610], 256], 64563: [[1602, 1581], 256], 64564: [[1602, 1605], 256], 64565: [[1602, 1609], 256], 64566: [[1602, 1610], 256], 64567: [[1603, 1575], 256], 64568: [[1603, 1580], 256], 64569: [[1603, 1581], 256], 64570: [[1603, 1582], 256], 64571: [[1603, 1604], 256], 64572: [[1603, 1605], 256], 64573: [[1603, 1609], 256], 64574: [[1603, 1610], 256], 64575: [[1604, 1580], 256], 64576: [[1604, 1581], 256], 64577: [[1604, 1582], 256], 64578: [[1604, 1605], 256], 64579: [[1604, 1609], 256], 64580: [[1604, 1610], 256], 64581: [[1605, 1580], 256], 64582: [[1605, 1581], 256], 64583: [[1605, 1582], 256], 64584: [[1605, 1605], 256], 64585: [[1605, 1609], 256], 64586: [[1605, 1610], 256], 64587: [[1606, 1580], 256], 64588: [[1606, 1581], 256], 64589: [[1606, 1582], 256], 64590: [[1606, 1605], 256], 64591: [[1606, 1609], 256], 64592: [[1606, 1610], 256], 64593: [[1607, 1580], 256], 64594: [[1607, 1605], 256], 64595: [[1607, 1609], 256], 64596: [[1607, 1610], 256], 64597: [[1610, 1580], 256], 64598: [[1610, 1581], 256], 64599: [[1610, 1582], 256], 64600: [[1610, 1605], 256], 64601: [[1610, 1609], 256], 64602: [[1610, 1610], 256], 64603: [[1584, 1648], 256], 64604: [[1585, 1648], 256], 64605: [[1609, 1648], 256], 64606: [[32, 1612, 1617], 256], 64607: [[32, 1613, 1617], 256], 64608: [[32, 1614, 1617], 256], 64609: [[32, 1615, 1617], 256], 64610: [[32, 1616, 1617], 256], 64611: [[32, 1617, 1648], 256], 64612: [[1574, 1585], 256], 64613: [[1574, 1586], 256], 64614: [[1574, 1605], 256], 64615: [[1574, 1606], 256], 64616: [[1574, 1609], 256], 64617: [[1574, 1610], 256], 64618: [[1576, 1585], 256], 64619: [[1576, 1586], 256], 64620: [[1576, 1605], 256], 64621: [[1576, 1606], 256], 64622: [[1576, 1609], 256], 64623: [[1576, 1610], 256], 64624: [[1578, 1585], 256], 64625: [[1578, 1586], 256], 64626: [[1578, 1605], 256], 64627: [[1578, 1606], 256], 64628: [[1578, 1609], 256], 64629: [[1578, 1610], 256], 64630: [[1579, 1585], 256], 64631: [[1579, 1586], 256], 64632: [[1579, 1605], 256], 64633: [[1579, 1606], 256], 64634: [[1579, 1609], 256], 64635: [[1579, 1610], 256], 64636: [[1601, 1609], 256], 64637: [[1601, 1610], 256], 64638: [[1602, 1609], 256], 64639: [[1602, 1610], 256], 64640: [[1603, 1575], 256], 64641: [[1603, 1604], 256], 64642: [[1603, 1605], 256], 64643: [[1603, 1609], 256], 64644: [[1603, 1610], 256], 64645: [[1604, 1605], 256], 64646: [[1604, 1609], 256], 64647: [[1604, 1610], 256], 64648: [[1605, 1575], 256], 64649: [[1605, 1605], 256], 64650: [[1606, 1585], 256], 64651: [[1606, 1586], 256], 64652: [[1606, 1605], 256], 64653: [[1606, 1606], 256], 64654: [[1606, 1609], 256], 64655: [[1606, 1610], 256], 64656: [[1609, 1648], 256], 64657: [[1610, 1585], 256], 64658: [[1610, 1586], 256], 64659: [[1610, 1605], 256], 64660: [[1610, 1606], 256], 64661: [[1610, 1609], 256], 64662: [[1610, 1610], 256], 64663: [[1574, 1580], 256], 64664: [[1574, 1581], 256], 64665: [[1574, 1582], 256], 64666: [[1574, 1605], 256], 64667: [[1574, 1607], 256], 64668: [[1576, 1580], 256], 64669: [[1576, 1581], 256], 64670: [[1576, 1582], 256], 64671: [[1576, 1605], 256], 64672: [[1576, 1607], 256], 64673: [[1578, 1580], 256], 64674: [[1578, 1581], 256], 64675: [[1578, 1582], 256], 64676: [[1578, 1605], 256], 64677: [[1578, 1607], 256], 64678: [[1579, 1605], 256], 64679: [[1580, 1581], 256], 64680: [[1580, 1605], 256], 64681: [[1581, 1580], 256], 64682: [[1581, 1605], 256], 64683: [[1582, 1580], 256], 64684: [[1582, 1605], 256], 64685: [[1587, 1580], 256], 64686: [[1587, 1581], 256], 64687: [[1587, 1582], 256], 64688: [[1587, 1605], 256], 64689: [[1589, 1581], 256], 64690: [[1589, 1582], 256], 64691: [[1589, 1605], 256], 64692: [[1590, 1580], 256], 64693: [[1590, 1581], 256], 64694: [[1590, 1582], 256], 64695: [[1590, 1605], 256], 64696: [[1591, 1581], 256], 64697: [[1592, 1605], 256], 64698: [[1593, 1580], 256], 64699: [[1593, 1605], 256], 64700: [[1594, 1580], 256], 64701: [[1594, 1605], 256], 64702: [[1601, 1580], 256], 64703: [[1601, 1581], 256], 64704: [[1601, 1582], 256], 64705: [[1601, 1605], 256], 64706: [[1602, 1581], 256], 64707: [[1602, 1605], 256], 64708: [[1603, 1580], 256], 64709: [[1603, 1581], 256], 64710: [[1603, 1582], 256], 64711: [[1603, 1604], 256], 64712: [[1603, 1605], 256], 64713: [[1604, 1580], 256], 64714: [[1604, 1581], 256], 64715: [[1604, 1582], 256], 64716: [[1604, 1605], 256], 64717: [[1604, 1607], 256], 64718: [[1605, 1580], 256], 64719: [[1605, 1581], 256], 64720: [[1605, 1582], 256], 64721: [[1605, 1605], 256], 64722: [[1606, 1580], 256], 64723: [[1606, 1581], 256], 64724: [[1606, 1582], 256], 64725: [[1606, 1605], 256], 64726: [[1606, 1607], 256], 64727: [[1607, 1580], 256], 64728: [[1607, 1605], 256], 64729: [[1607, 1648], 256], 64730: [[1610, 1580], 256], 64731: [[1610, 1581], 256], 64732: [[1610, 1582], 256], 64733: [[1610, 1605], 256], 64734: [[1610, 1607], 256], 64735: [[1574, 1605], 256], 64736: [[1574, 1607], 256], 64737: [[1576, 1605], 256], 64738: [[1576, 1607], 256], 64739: [[1578, 1605], 256], 64740: [[1578, 1607], 256], 64741: [[1579, 1605], 256], 64742: [[1579, 1607], 256], 64743: [[1587, 1605], 256], 64744: [[1587, 1607], 256], 64745: [[1588, 1605], 256], 64746: [[1588, 1607], 256], 64747: [[1603, 1604], 256], 64748: [[1603, 1605], 256], 64749: [[1604, 1605], 256], 64750: [[1606, 1605], 256], 64751: [[1606, 1607], 256], 64752: [[1610, 1605], 256], 64753: [[1610, 1607], 256], 64754: [[1600, 1614, 1617], 256], 64755: [[1600, 1615, 1617], 256], 64756: [[1600, 1616, 1617], 256], 64757: [[1591, 1609], 256], 64758: [[1591, 1610], 256], 64759: [[1593, 1609], 256], 64760: [[1593, 1610], 256], 64761: [[1594, 1609], 256], 64762: [[1594, 1610], 256], 64763: [[1587, 1609], 256], 64764: [[1587, 1610], 256], 64765: [[1588, 1609], 256], 64766: [[1588, 1610], 256], 64767: [[1581, 1609], 256] },
        64768: { 64768: [[1581, 1610], 256], 64769: [[1580, 1609], 256], 64770: [[1580, 1610], 256], 64771: [[1582, 1609], 256], 64772: [[1582, 1610], 256], 64773: [[1589, 1609], 256], 64774: [[1589, 1610], 256], 64775: [[1590, 1609], 256], 64776: [[1590, 1610], 256], 64777: [[1588, 1580], 256], 64778: [[1588, 1581], 256], 64779: [[1588, 1582], 256], 64780: [[1588, 1605], 256], 64781: [[1588, 1585], 256], 64782: [[1587, 1585], 256], 64783: [[1589, 1585], 256], 64784: [[1590, 1585], 256], 64785: [[1591, 1609], 256], 64786: [[1591, 1610], 256], 64787: [[1593, 1609], 256], 64788: [[1593, 1610], 256], 64789: [[1594, 1609], 256], 64790: [[1594, 1610], 256], 64791: [[1587, 1609], 256], 64792: [[1587, 1610], 256], 64793: [[1588, 1609], 256], 64794: [[1588, 1610], 256], 64795: [[1581, 1609], 256], 64796: [[1581, 1610], 256], 64797: [[1580, 1609], 256], 64798: [[1580, 1610], 256], 64799: [[1582, 1609], 256], 64800: [[1582, 1610], 256], 64801: [[1589, 1609], 256], 64802: [[1589, 1610], 256], 64803: [[1590, 1609], 256], 64804: [[1590, 1610], 256], 64805: [[1588, 1580], 256], 64806: [[1588, 1581], 256], 64807: [[1588, 1582], 256], 64808: [[1588, 1605], 256], 64809: [[1588, 1585], 256], 64810: [[1587, 1585], 256], 64811: [[1589, 1585], 256], 64812: [[1590, 1585], 256], 64813: [[1588, 1580], 256], 64814: [[1588, 1581], 256], 64815: [[1588, 1582], 256], 64816: [[1588, 1605], 256], 64817: [[1587, 1607], 256], 64818: [[1588, 1607], 256], 64819: [[1591, 1605], 256], 64820: [[1587, 1580], 256], 64821: [[1587, 1581], 256], 64822: [[1587, 1582], 256], 64823: [[1588, 1580], 256], 64824: [[1588, 1581], 256], 64825: [[1588, 1582], 256], 64826: [[1591, 1605], 256], 64827: [[1592, 1605], 256], 64828: [[1575, 1611], 256], 64829: [[1575, 1611], 256], 64848: [[1578, 1580, 1605], 256], 64849: [[1578, 1581, 1580], 256], 64850: [[1578, 1581, 1580], 256], 64851: [[1578, 1581, 1605], 256], 64852: [[1578, 1582, 1605], 256], 64853: [[1578, 1605, 1580], 256], 64854: [[1578, 1605, 1581], 256], 64855: [[1578, 1605, 1582], 256], 64856: [[1580, 1605, 1581], 256], 64857: [[1580, 1605, 1581], 256], 64858: [[1581, 1605, 1610], 256], 64859: [[1581, 1605, 1609], 256], 64860: [[1587, 1581, 1580], 256], 64861: [[1587, 1580, 1581], 256], 64862: [[1587, 1580, 1609], 256], 64863: [[1587, 1605, 1581], 256], 64864: [[1587, 1605, 1581], 256], 64865: [[1587, 1605, 1580], 256], 64866: [[1587, 1605, 1605], 256], 64867: [[1587, 1605, 1605], 256], 64868: [[1589, 1581, 1581], 256], 64869: [[1589, 1581, 1581], 256], 64870: [[1589, 1605, 1605], 256], 64871: [[1588, 1581, 1605], 256], 64872: [[1588, 1581, 1605], 256], 64873: [[1588, 1580, 1610], 256], 64874: [[1588, 1605, 1582], 256], 64875: [[1588, 1605, 1582], 256], 64876: [[1588, 1605, 1605], 256], 64877: [[1588, 1605, 1605], 256], 64878: [[1590, 1581, 1609], 256], 64879: [[1590, 1582, 1605], 256], 64880: [[1590, 1582, 1605], 256], 64881: [[1591, 1605, 1581], 256], 64882: [[1591, 1605, 1581], 256], 64883: [[1591, 1605, 1605], 256], 64884: [[1591, 1605, 1610], 256], 64885: [[1593, 1580, 1605], 256], 64886: [[1593, 1605, 1605], 256], 64887: [[1593, 1605, 1605], 256], 64888: [[1593, 1605, 1609], 256], 64889: [[1594, 1605, 1605], 256], 64890: [[1594, 1605, 1610], 256], 64891: [[1594, 1605, 1609], 256], 64892: [[1601, 1582, 1605], 256], 64893: [[1601, 1582, 1605], 256], 64894: [[1602, 1605, 1581], 256], 64895: [[1602, 1605, 1605], 256], 64896: [[1604, 1581, 1605], 256], 64897: [[1604, 1581, 1610], 256], 64898: [[1604, 1581, 1609], 256], 64899: [[1604, 1580, 1580], 256], 64900: [[1604, 1580, 1580], 256], 64901: [[1604, 1582, 1605], 256], 64902: [[1604, 1582, 1605], 256], 64903: [[1604, 1605, 1581], 256], 64904: [[1604, 1605, 1581], 256], 64905: [[1605, 1581, 1580], 256], 64906: [[1605, 1581, 1605], 256], 64907: [[1605, 1581, 1610], 256], 64908: [[1605, 1580, 1581], 256], 64909: [[1605, 1580, 1605], 256], 64910: [[1605, 1582, 1580], 256], 64911: [[1605, 1582, 1605], 256], 64914: [[1605, 1580, 1582], 256], 64915: [[1607, 1605, 1580], 256], 64916: [[1607, 1605, 1605], 256], 64917: [[1606, 1581, 1605], 256], 64918: [[1606, 1581, 1609], 256], 64919: [[1606, 1580, 1605], 256], 64920: [[1606, 1580, 1605], 256], 64921: [[1606, 1580, 1609], 256], 64922: [[1606, 1605, 1610], 256], 64923: [[1606, 1605, 1609], 256], 64924: [[1610, 1605, 1605], 256], 64925: [[1610, 1605, 1605], 256], 64926: [[1576, 1582, 1610], 256], 64927: [[1578, 1580, 1610], 256], 64928: [[1578, 1580, 1609], 256], 64929: [[1578, 1582, 1610], 256], 64930: [[1578, 1582, 1609], 256], 64931: [[1578, 1605, 1610], 256], 64932: [[1578, 1605, 1609], 256], 64933: [[1580, 1605, 1610], 256], 64934: [[1580, 1581, 1609], 256], 64935: [[1580, 1605, 1609], 256], 64936: [[1587, 1582, 1609], 256], 64937: [[1589, 1581, 1610], 256], 64938: [[1588, 1581, 1610], 256], 64939: [[1590, 1581, 1610], 256], 64940: [[1604, 1580, 1610], 256], 64941: [[1604, 1605, 1610], 256], 64942: [[1610, 1581, 1610], 256], 64943: [[1610, 1580, 1610], 256], 64944: [[1610, 1605, 1610], 256], 64945: [[1605, 1605, 1610], 256], 64946: [[1602, 1605, 1610], 256], 64947: [[1606, 1581, 1610], 256], 64948: [[1602, 1605, 1581], 256], 64949: [[1604, 1581, 1605], 256], 64950: [[1593, 1605, 1610], 256], 64951: [[1603, 1605, 1610], 256], 64952: [[1606, 1580, 1581], 256], 64953: [[1605, 1582, 1610], 256], 64954: [[1604, 1580, 1605], 256], 64955: [[1603, 1605, 1605], 256], 64956: [[1604, 1580, 1605], 256], 64957: [[1606, 1580, 1581], 256], 64958: [[1580, 1581, 1610], 256], 64959: [[1581, 1580, 1610], 256], 64960: [[1605, 1580, 1610], 256], 64961: [[1601, 1605, 1610], 256], 64962: [[1576, 1581, 1610], 256], 64963: [[1603, 1605, 1605], 256], 64964: [[1593, 1580, 1605], 256], 64965: [[1589, 1605, 1605], 256], 64966: [[1587, 1582, 1610], 256], 64967: [[1606, 1580, 1610], 256], 65008: [[1589, 1604, 1746], 256], 65009: [[1602, 1604, 1746], 256], 65010: [[1575, 1604, 1604, 1607], 256], 65011: [[1575, 1603, 1576, 1585], 256], 65012: [[1605, 1581, 1605, 1583], 256], 65013: [[1589, 1604, 1593, 1605], 256], 65014: [[1585, 1587, 1608, 1604], 256], 65015: [[1593, 1604, 1610, 1607], 256], 65016: [[1608, 1587, 1604, 1605], 256], 65017: [[1589, 1604, 1609], 256], 65018: [[1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605], 256], 65019: [[1580, 1604, 32, 1580, 1604, 1575, 1604, 1607], 256], 65020: [[1585, 1740, 1575, 1604], 256] },
        65024: { 65040: [[44], 256], 65041: [[12289], 256], 65042: [[12290], 256], 65043: [[58], 256], 65044: [[59], 256], 65045: [[33], 256], 65046: [[63], 256], 65047: [[12310], 256], 65048: [[12311], 256], 65049: [[8230], 256], 65056: [, 230], 65057: [, 230], 65058: [, 230], 65059: [, 230], 65060: [, 230], 65061: [, 230], 65062: [, 230], 65063: [, 220], 65064: [, 220], 65065: [, 220], 65066: [, 220], 65067: [, 220], 65068: [, 220], 65069: [, 220], 65072: [[8229], 256], 65073: [[8212], 256], 65074: [[8211], 256], 65075: [[95], 256], 65076: [[95], 256], 65077: [[40], 256], 65078: [[41], 256], 65079: [[123], 256], 65080: [[125], 256], 65081: [[12308], 256], 65082: [[12309], 256], 65083: [[12304], 256], 65084: [[12305], 256], 65085: [[12298], 256], 65086: [[12299], 256], 65087: [[12296], 256], 65088: [[12297], 256], 65089: [[12300], 256], 65090: [[12301], 256], 65091: [[12302], 256], 65092: [[12303], 256], 65095: [[91], 256], 65096: [[93], 256], 65097: [[8254], 256], 65098: [[8254], 256], 65099: [[8254], 256], 65100: [[8254], 256], 65101: [[95], 256], 65102: [[95], 256], 65103: [[95], 256], 65104: [[44], 256], 65105: [[12289], 256], 65106: [[46], 256], 65108: [[59], 256], 65109: [[58], 256], 65110: [[63], 256], 65111: [[33], 256], 65112: [[8212], 256], 65113: [[40], 256], 65114: [[41], 256], 65115: [[123], 256], 65116: [[125], 256], 65117: [[12308], 256], 65118: [[12309], 256], 65119: [[35], 256], 65120: [[38], 256], 65121: [[42], 256], 65122: [[43], 256], 65123: [[45], 256], 65124: [[60], 256], 65125: [[62], 256], 65126: [[61], 256], 65128: [[92], 256], 65129: [[36], 256], 65130: [[37], 256], 65131: [[64], 256], 65136: [[32, 1611], 256], 65137: [[1600, 1611], 256], 65138: [[32, 1612], 256], 65140: [[32, 1613], 256], 65142: [[32, 1614], 256], 65143: [[1600, 1614], 256], 65144: [[32, 1615], 256], 65145: [[1600, 1615], 256], 65146: [[32, 1616], 256], 65147: [[1600, 1616], 256], 65148: [[32, 1617], 256], 65149: [[1600, 1617], 256], 65150: [[32, 1618], 256], 65151: [[1600, 1618], 256], 65152: [[1569], 256], 65153: [[1570], 256], 65154: [[1570], 256], 65155: [[1571], 256], 65156: [[1571], 256], 65157: [[1572], 256], 65158: [[1572], 256], 65159: [[1573], 256], 65160: [[1573], 256], 65161: [[1574], 256], 65162: [[1574], 256], 65163: [[1574], 256], 65164: [[1574], 256], 65165: [[1575], 256], 65166: [[1575], 256], 65167: [[1576], 256], 65168: [[1576], 256], 65169: [[1576], 256], 65170: [[1576], 256], 65171: [[1577], 256], 65172: [[1577], 256], 65173: [[1578], 256], 65174: [[1578], 256], 65175: [[1578], 256], 65176: [[1578], 256], 65177: [[1579], 256], 65178: [[1579], 256], 65179: [[1579], 256], 65180: [[1579], 256], 65181: [[1580], 256], 65182: [[1580], 256], 65183: [[1580], 256], 65184: [[1580], 256], 65185: [[1581], 256], 65186: [[1581], 256], 65187: [[1581], 256], 65188: [[1581], 256], 65189: [[1582], 256], 65190: [[1582], 256], 65191: [[1582], 256], 65192: [[1582], 256], 65193: [[1583], 256], 65194: [[1583], 256], 65195: [[1584], 256], 65196: [[1584], 256], 65197: [[1585], 256], 65198: [[1585], 256], 65199: [[1586], 256], 65200: [[1586], 256], 65201: [[1587], 256], 65202: [[1587], 256], 65203: [[1587], 256], 65204: [[1587], 256], 65205: [[1588], 256], 65206: [[1588], 256], 65207: [[1588], 256], 65208: [[1588], 256], 65209: [[1589], 256], 65210: [[1589], 256], 65211: [[1589], 256], 65212: [[1589], 256], 65213: [[1590], 256], 65214: [[1590], 256], 65215: [[1590], 256], 65216: [[1590], 256], 65217: [[1591], 256], 65218: [[1591], 256], 65219: [[1591], 256], 65220: [[1591], 256], 65221: [[1592], 256], 65222: [[1592], 256], 65223: [[1592], 256], 65224: [[1592], 256], 65225: [[1593], 256], 65226: [[1593], 256], 65227: [[1593], 256], 65228: [[1593], 256], 65229: [[1594], 256], 65230: [[1594], 256], 65231: [[1594], 256], 65232: [[1594], 256], 65233: [[1601], 256], 65234: [[1601], 256], 65235: [[1601], 256], 65236: [[1601], 256], 65237: [[1602], 256], 65238: [[1602], 256], 65239: [[1602], 256], 65240: [[1602], 256], 65241: [[1603], 256], 65242: [[1603], 256], 65243: [[1603], 256], 65244: [[1603], 256], 65245: [[1604], 256], 65246: [[1604], 256], 65247: [[1604], 256], 65248: [[1604], 256], 65249: [[1605], 256], 65250: [[1605], 256], 65251: [[1605], 256], 65252: [[1605], 256], 65253: [[1606], 256], 65254: [[1606], 256], 65255: [[1606], 256], 65256: [[1606], 256], 65257: [[1607], 256], 65258: [[1607], 256], 65259: [[1607], 256], 65260: [[1607], 256], 65261: [[1608], 256], 65262: [[1608], 256], 65263: [[1609], 256], 65264: [[1609], 256], 65265: [[1610], 256], 65266: [[1610], 256], 65267: [[1610], 256], 65268: [[1610], 256], 65269: [[1604, 1570], 256], 65270: [[1604, 1570], 256], 65271: [[1604, 1571], 256], 65272: [[1604, 1571], 256], 65273: [[1604, 1573], 256], 65274: [[1604, 1573], 256], 65275: [[1604, 1575], 256], 65276: [[1604, 1575], 256] },
        65280: { 65281: [[33], 256], 65282: [[34], 256], 65283: [[35], 256], 65284: [[36], 256], 65285: [[37], 256], 65286: [[38], 256], 65287: [[39], 256], 65288: [[40], 256], 65289: [[41], 256], 65290: [[42], 256], 65291: [[43], 256], 65292: [[44], 256], 65293: [[45], 256], 65294: [[46], 256], 65295: [[47], 256], 65296: [[48], 256], 65297: [[49], 256], 65298: [[50], 256], 65299: [[51], 256], 65300: [[52], 256], 65301: [[53], 256], 65302: [[54], 256], 65303: [[55], 256], 65304: [[56], 256], 65305: [[57], 256], 65306: [[58], 256], 65307: [[59], 256], 65308: [[60], 256], 65309: [[61], 256], 65310: [[62], 256], 65311: [[63], 256], 65312: [[64], 256], 65313: [[65], 256], 65314: [[66], 256], 65315: [[67], 256], 65316: [[68], 256], 65317: [[69], 256], 65318: [[70], 256], 65319: [[71], 256], 65320: [[72], 256], 65321: [[73], 256], 65322: [[74], 256], 65323: [[75], 256], 65324: [[76], 256], 65325: [[77], 256], 65326: [[78], 256], 65327: [[79], 256], 65328: [[80], 256], 65329: [[81], 256], 65330: [[82], 256], 65331: [[83], 256], 65332: [[84], 256], 65333: [[85], 256], 65334: [[86], 256], 65335: [[87], 256], 65336: [[88], 256], 65337: [[89], 256], 65338: [[90], 256], 65339: [[91], 256], 65340: [[92], 256], 65341: [[93], 256], 65342: [[94], 256], 65343: [[95], 256], 65344: [[96], 256], 65345: [[97], 256], 65346: [[98], 256], 65347: [[99], 256], 65348: [[100], 256], 65349: [[101], 256], 65350: [[102], 256], 65351: [[103], 256], 65352: [[104], 256], 65353: [[105], 256], 65354: [[106], 256], 65355: [[107], 256], 65356: [[108], 256], 65357: [[109], 256], 65358: [[110], 256], 65359: [[111], 256], 65360: [[112], 256], 65361: [[113], 256], 65362: [[114], 256], 65363: [[115], 256], 65364: [[116], 256], 65365: [[117], 256], 65366: [[118], 256], 65367: [[119], 256], 65368: [[120], 256], 65369: [[121], 256], 65370: [[122], 256], 65371: [[123], 256], 65372: [[124], 256], 65373: [[125], 256], 65374: [[126], 256], 65375: [[10629], 256], 65376: [[10630], 256], 65377: [[12290], 256], 65378: [[12300], 256], 65379: [[12301], 256], 65380: [[12289], 256], 65381: [[12539], 256], 65382: [[12530], 256], 65383: [[12449], 256], 65384: [[12451], 256], 65385: [[12453], 256], 65386: [[12455], 256], 65387: [[12457], 256], 65388: [[12515], 256], 65389: [[12517], 256], 65390: [[12519], 256], 65391: [[12483], 256], 65392: [[12540], 256], 65393: [[12450], 256], 65394: [[12452], 256], 65395: [[12454], 256], 65396: [[12456], 256], 65397: [[12458], 256], 65398: [[12459], 256], 65399: [[12461], 256], 65400: [[12463], 256], 65401: [[12465], 256], 65402: [[12467], 256], 65403: [[12469], 256], 65404: [[12471], 256], 65405: [[12473], 256], 65406: [[12475], 256], 65407: [[12477], 256], 65408: [[12479], 256], 65409: [[12481], 256], 65410: [[12484], 256], 65411: [[12486], 256], 65412: [[12488], 256], 65413: [[12490], 256], 65414: [[12491], 256], 65415: [[12492], 256], 65416: [[12493], 256], 65417: [[12494], 256], 65418: [[12495], 256], 65419: [[12498], 256], 65420: [[12501], 256], 65421: [[12504], 256], 65422: [[12507], 256], 65423: [[12510], 256], 65424: [[12511], 256], 65425: [[12512], 256], 65426: [[12513], 256], 65427: [[12514], 256], 65428: [[12516], 256], 65429: [[12518], 256], 65430: [[12520], 256], 65431: [[12521], 256], 65432: [[12522], 256], 65433: [[12523], 256], 65434: [[12524], 256], 65435: [[12525], 256], 65436: [[12527], 256], 65437: [[12531], 256], 65438: [[12441], 256], 65439: [[12442], 256], 65440: [[12644], 256], 65441: [[12593], 256], 65442: [[12594], 256], 65443: [[12595], 256], 65444: [[12596], 256], 65445: [[12597], 256], 65446: [[12598], 256], 65447: [[12599], 256], 65448: [[12600], 256], 65449: [[12601], 256], 65450: [[12602], 256], 65451: [[12603], 256], 65452: [[12604], 256], 65453: [[12605], 256], 65454: [[12606], 256], 65455: [[12607], 256], 65456: [[12608], 256], 65457: [[12609], 256], 65458: [[12610], 256], 65459: [[12611], 256], 65460: [[12612], 256], 65461: [[12613], 256], 65462: [[12614], 256], 65463: [[12615], 256], 65464: [[12616], 256], 65465: [[12617], 256], 65466: [[12618], 256], 65467: [[12619], 256], 65468: [[12620], 256], 65469: [[12621], 256], 65470: [[12622], 256], 65474: [[12623], 256], 65475: [[12624], 256], 65476: [[12625], 256], 65477: [[12626], 256], 65478: [[12627], 256], 65479: [[12628], 256], 65482: [[12629], 256], 65483: [[12630], 256], 65484: [[12631], 256], 65485: [[12632], 256], 65486: [[12633], 256], 65487: [[12634], 256], 65490: [[12635], 256], 65491: [[12636], 256], 65492: [[12637], 256], 65493: [[12638], 256], 65494: [[12639], 256], 65495: [[12640], 256], 65498: [[12641], 256], 65499: [[12642], 256], 65500: [[12643], 256], 65504: [[162], 256], 65505: [[163], 256], 65506: [[172], 256], 65507: [[175], 256], 65508: [[166], 256], 65509: [[165], 256], 65510: [[8361], 256], 65512: [[9474], 256], 65513: [[8592], 256], 65514: [[8593], 256], 65515: [[8594], 256], 65516: [[8595], 256], 65517: [[9632], 256], 65518: [[9675], 256] }
      };
      var unorm2 = {
        nfc,
        nfd,
        nfkc,
        nfkd
      };
      {
        module.exports = unorm2;
      }
      unorm2.shimApplied = false;
      if (!String.prototype.normalize) {
        Object.defineProperty(String.prototype, "normalize", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: function normalize2() {
            var str = "" + this;
            var form = arguments[0] === void 0 ? "NFC" : arguments[0];
            if (this === null || this === void 0) {
              throw new TypeError("Cannot call method on " + Object.prototype.toString.call(this));
            }
            if (form === "NFC") {
              return unorm2.nfc(str);
            } else if (form === "NFD") {
              return unorm2.nfd(str);
            } else if (form === "NFKC") {
              return unorm2.nfkc(str);
            } else if (form === "NFKD") {
              return unorm2.nfkd(str);
            } else {
              throw new RangeError("Invalid normalization form: " + form);
            }
          }
        });
        unorm2.shimApplied = true;
      }
    })();
  })(unorm);
  return unorm.exports;
}
var hasRequiredContentcollector;
function requireContentcollector() {
  if (hasRequiredContentcollector)
    return contentcollector;
  hasRequiredContentcollector = 1;
  const _MAX_LIST_LEVEL = 16;
  const AttributeMap = requireAttributeMap();
  const UNorm = requireUnorm();
  const Changeset2 = requireChangeset();
  const hooks$1 = hooks;
  const sanitizeUnicode = (s) => UNorm.nfc(s);
  const tagName = (n) => n.tagName && n.tagName.toLowerCase();
  const supportedElems = /* @__PURE__ */ new Set([
    "author",
    "b",
    "bold",
    "br",
    "div",
    "font",
    "i",
    "insertorder",
    "italic",
    "li",
    "lmkr",
    "ol",
    "p",
    "pre",
    "strong",
    "s",
    "span",
    "u",
    "ul"
  ]);
  const makeContentCollector = (collectStyles, abrowser, apool, className2Author) => {
    const _blockElems = {
      div: 1,
      p: 1,
      pre: 1,
      li: 1
    };
    hooks$1.callAll("ccRegisterBlockElements").forEach((element) => {
      _blockElems[element] = 1;
      supportedElems.add(element);
    });
    const isBlockElement = (n) => !!_blockElems[tagName(n) || ""];
    const textify = (str) => sanitizeUnicode(
      str.replace(/(\n | \n)/g, " ").replace(/[\n\r ]/g, " ").replace(/\xa0/g, " ").replace(/\t/g, "        ")
    );
    const getAssoc = (node, name) => node[`_magicdom_${name}`];
    const lines = (() => {
      const textArray = [];
      const attribsArray = [];
      let attribsBuilder = null;
      const op = new Changeset2.Op("+");
      const self2 = {
        length: () => textArray.length,
        atColumnZero: () => textArray[textArray.length - 1] === "",
        startNew: () => {
          textArray.push("");
          self2.flush(true);
          attribsBuilder = Changeset2.smartOpAssembler();
        },
        textOfLine: (i) => textArray[i],
        appendText: (txt, attrString = "") => {
          textArray[textArray.length - 1] += txt;
          op.attribs = attrString;
          op.chars = txt.length;
          attribsBuilder.append(op);
        },
        textLines: () => textArray.slice(),
        attribLines: () => attribsArray,
        // call flush only when you're done
        flush: (withNewline) => {
          if (attribsBuilder) {
            attribsArray.push(attribsBuilder.toString());
            attribsBuilder = null;
          }
        }
      };
      self2.startNew();
      return self2;
    })();
    const cc = {};
    const _ensureColumnZero = (state) => {
      if (!lines.atColumnZero()) {
        cc.startNewLine(state);
      }
    };
    let selection, startPoint, endPoint;
    let selStart = [-1, -1];
    let selEnd = [-1, -1];
    const _isEmpty = (node, state) => {
      if (node.childNodes.length === 0)
        return true;
      if (node.childNodes.length === 1 && getAssoc(node, "shouldBeEmpty") && node.innerHTML === "&nbsp;" && !getAssoc(node, "unpasted")) {
        if (state) {
          const child = node.childNodes[0];
          _reachPoint(child, 0, state);
          _reachPoint(child, 1, state);
        }
        return true;
      }
      return false;
    };
    const _pointHere = (charsAfter, state) => {
      const ln = lines.length() - 1;
      let chr = lines.textOfLine(ln).length;
      if (chr === 0 && Object.keys(state.lineAttributes).length !== 0) {
        chr += 1;
      }
      chr += charsAfter;
      return [ln, chr];
    };
    const _reachBlockPoint = (nd, idx, state) => {
      if (nd.nodeType !== nd.TEXT_NODE)
        _reachPoint(nd, idx, state);
    };
    const _reachPoint = (nd, idx, state) => {
      if (startPoint && nd === startPoint.node && startPoint.index === idx) {
        selStart = _pointHere(0, state);
      }
      if (endPoint && nd === endPoint.node && endPoint.index === idx) {
        selEnd = _pointHere(0, state);
      }
    };
    cc.incrementFlag = (state, flagName) => {
      state.flags[flagName] = (state.flags[flagName] || 0) + 1;
    };
    cc.decrementFlag = (state, flagName) => {
      state.flags[flagName]--;
    };
    cc.incrementAttrib = (state, attribName) => {
      if (!state.attribs[attribName]) {
        state.attribs[attribName] = 1;
      } else {
        state.attribs[attribName]++;
      }
      _recalcAttribString(state);
    };
    cc.decrementAttrib = (state, attribName) => {
      state.attribs[attribName]--;
      _recalcAttribString(state);
    };
    const _enterList = (state, listType) => {
      if (!listType)
        return;
      const oldListType = state.lineAttributes.list;
      if (listType !== "none") {
        state.listNesting = (state.listNesting || 0) + 1;
        if (listType.indexOf("number") !== -1) {
          state.start = (state.start || 0) + 1;
        }
      }
      if (listType === "none") {
        delete state.lineAttributes.list;
      } else {
        state.lineAttributes.list = listType;
      }
      _recalcAttribString(state);
      return oldListType;
    };
    const _exitList = (state, oldListType) => {
      if (state.lineAttributes.list) {
        state.listNesting--;
      }
      if (oldListType && oldListType !== "none") {
        state.lineAttributes.list = oldListType;
      } else {
        delete state.lineAttributes.list;
        delete state.lineAttributes.start;
      }
      _recalcAttribString(state);
    };
    const _enterAuthor = (state, author) => {
      const oldAuthor = state.author;
      state.authorLevel = (state.authorLevel || 0) + 1;
      state.author = author;
      _recalcAttribString(state);
      return oldAuthor;
    };
    const _exitAuthor = (state, oldAuthor) => {
      state.authorLevel--;
      state.author = oldAuthor;
      _recalcAttribString(state);
    };
    const _recalcAttribString = (state) => {
      const attribs = new AttributeMap(apool);
      for (const [a, count] of Object.entries(state.attribs)) {
        if (!count)
          continue;
        const ATTRIBUTE_SPLIT_STRING = "::";
        const attributeSplits = a.split(ATTRIBUTE_SPLIT_STRING);
        if (attributeSplits.length > 1) {
          const [k, v] = attributeSplits;
          if (v)
            attribs.set(k, v);
        } else {
          attribs.set(a, "true");
        }
      }
      if (state.authorLevel > 0) {
        if (apool.putAttrib(["author", state.author], true) >= 0) {
          if (state.author)
            attribs.set("author", state.author);
        }
      }
      state.attribString = attribs.toString();
    };
    const _produceLineAttributesMarker = (state) => {
      const attribs = new AttributeMap(apool).set("lmkr", "1").set("insertorder", "first").update(Object.entries(state.lineAttributes).map(([k, v]) => [k, v || ""]), true);
      lines.appendText("*", attribs.toString());
    };
    cc.startNewLine = (state) => {
      if (state) {
        const atBeginningOfLine = lines.textOfLine(lines.length() - 1).length === 0;
        if (atBeginningOfLine && Object.keys(state.lineAttributes).length !== 0) {
          _produceLineAttributesMarker(state);
        }
      }
      lines.startNew();
    };
    cc.notifySelection = (sel) => {
      if (sel) {
        selection = sel;
        startPoint = selection.startPoint;
        endPoint = selection.endPoint;
      }
    };
    cc.doAttrib = (state, na) => {
      state.localAttribs = state.localAttribs || [];
      state.localAttribs.push(na);
      cc.incrementAttrib(state, na);
    };
    cc.collectContent = function(node, state) {
      let unsupportedElements = null;
      if (!state) {
        state = {
          flags: {
            /* name -> nesting counter*/
          },
          localAttribs: null,
          attribs: {
            /* name -> nesting counter*/
          },
          attribString: "",
          // lineAttributes maintain a map from attributes to attribute values set on a line
          lineAttributes: {
            /*
            example:
            'list': 'bullet1',
            */
          },
          unsupportedElements: /* @__PURE__ */ new Set()
        };
        unsupportedElements = state.unsupportedElements;
      }
      const localAttribs = state.localAttribs;
      state.localAttribs = null;
      const isBlock = isBlockElement(node);
      if (!isBlock && node.name && node.name !== "body") {
        if (!supportedElems.has(node.name))
          state.unsupportedElements.add(node.name);
      }
      const isEmpty2 = _isEmpty(node, state);
      if (isBlock)
        _ensureColumnZero(state);
      const startLine = lines.length() - 1;
      _reachBlockPoint(node, 0, state);
      if (node.nodeType === node.TEXT_NODE) {
        const tname = node.parentNode.getAttribute("name");
        const context = { cc: this, state, tname, node, text: node.nodeValue };
        const [hookTxt] = hooks$1.callAll("collectContentLineText", context).filter((s) => typeof s === "string");
        let txt = context.text === node.nodeValue && hookTxt != null ? hookTxt : context.text;
        let rest2 = "";
        let x = 0;
        if (txt.length === 0) {
          if (startPoint && node === startPoint.node) {
            selStart = _pointHere(0, state);
          }
          if (endPoint && node === endPoint.node) {
            selEnd = _pointHere(0, state);
          }
        }
        while (txt.length > 0) {
          let consumed = 0;
          if (state.flags.preMode) {
            const firstLine = txt.split("\n", 1)[0];
            consumed = firstLine.length + 1;
            rest2 = txt.substring(consumed);
            txt = firstLine;
          }
          if (startPoint && node === startPoint.node && startPoint.index - x <= txt.length) {
            selStart = _pointHere(startPoint.index - x, state);
          }
          if (endPoint && node === endPoint.node && endPoint.index - x <= txt.length) {
            selEnd = _pointHere(endPoint.index - x, state);
          }
          let txt2 = txt;
          if (!state.flags.preMode && /^[\r\n]*$/.exec(txt)) {
            txt2 = "";
          }
          const atBeginningOfLine = lines.textOfLine(lines.length() - 1).length === 0;
          if (atBeginningOfLine) {
            txt2 = txt2.replace(/^\n*/, "");
          }
          if (atBeginningOfLine && Object.keys(state.lineAttributes).length !== 0) {
            _produceLineAttributesMarker(state);
          }
          lines.appendText(textify(txt2), state.attribString);
          x += consumed;
          txt = rest2;
          if (txt.length > 0) {
            cc.startNewLine(state);
          }
        }
      } else if (node.nodeType === node.ELEMENT_NODE) {
        const tname = tagName(node) || "";
        if (tname === "img") {
          hooks$1.callAll("collectContentImage", {
            cc,
            state,
            tname,
            styl: null,
            cls: null,
            node
          });
        } else {
          delete state.lineAttributes.img;
        }
        if (tname === "br") {
          this.breakLine = true;
          const tvalue = node.getAttribute("value");
          const [startNewLine = true] = hooks$1.callAll("collectContentLineBreak", {
            cc: this,
            state,
            tname,
            tvalue,
            styl: null,
            cls: null
          });
          if (startNewLine) {
            cc.startNewLine(state);
          }
        } else if (tname === "script" || tname === "style")
          ;
        else if (!isEmpty2) {
          let styl = node.getAttribute("style");
          let cls = node.getAttribute("class");
          let isPre = tname === "pre";
          if (!isPre && abrowser && abrowser.safari) {
            isPre = styl && /\bwhite-space:\s*pre\b/i.exec(styl);
          }
          if (isPre)
            cc.incrementFlag(state, "preMode");
          let oldListTypeOrNull = null;
          let oldAuthorOrNull = null;
          if (cls === "Numbering_20_Symbols" || cls === "Bullet_20_Symbols") {
            styl = null;
            cls = null;
            return;
          }
          if (collectStyles) {
            hooks$1.callAll("collectContentPre", {
              cc,
              state,
              tname,
              styl,
              cls
            });
            if (tname === "b" || styl && /\bfont-weight:\s*bold\b/i.exec(styl) || tname === "strong") {
              cc.doAttrib(state, "bold");
            }
            if (tname === "i" || styl && /\bfont-style:\s*italic\b/i.exec(styl) || tname === "em") {
              cc.doAttrib(state, "italic");
            }
            if (tname === "u" || styl && /\btext-decoration:\s*underline\b/i.exec(styl) || tname === "ins") {
              cc.doAttrib(state, "underline");
            }
            if (tname === "s" || styl && /\btext-decoration:\s*line-through\b/i.exec(styl) || tname === "del") {
              cc.doAttrib(state, "strikethrough");
            }
            if (tname === "ul" || tname === "ol") {
              let type = node.getAttribute("class");
              const rr = cls && /(?:^| )list-([a-z]+[0-9]+)\b/.exec(cls);
              if (!rr && !type) {
                for (const child of node.childNodes) {
                  if (tagName(child) !== "ul")
                    continue;
                  type = child.getAttribute("class");
                  if (type)
                    break;
                }
              }
              if (rr && rr[1]) {
                type = rr[1];
              } else {
                if (tname === "ul") {
                  const cls2 = node.getAttribute("class");
                  if (type && type.match("indent") || cls2 && cls2.match("indent")) {
                    type = "indent";
                  } else {
                    type = "bullet";
                  }
                } else {
                  type = "number";
                }
                type += String(Math.min(_MAX_LIST_LEVEL, (state.listNesting || 0) + 1));
              }
              oldListTypeOrNull = _enterList(state, type) || "none";
            } else if ((tname === "div" || tname === "p") && cls && cls.match(/(?:^| )ace-line\b/)) {
              if (!abrowser.chrome)
                oldListTypeOrNull = _enterList(state, void 0) || "none";
            } else if (tname === "li") {
              state.lineAttributes.start = state.start || 0;
              _recalcAttribString(state);
              if (state.lineAttributes.list.indexOf("number") !== -1) {
                if (node.parentNode && tagName(node.parentNode) !== "ol") {
                  state.start++;
                }
              }
              if (node.parentNode && tagName(node.parentNode) === "ul") {
                state.start++;
              }
            } else
              ;
            if (className2Author && cls) {
              const classes = cls.match(/\S+/g);
              if (classes && classes.length > 0) {
                for (let i = 0; i < classes.length; i++) {
                  const c = classes[i];
                  const a = className2Author(c);
                  if (a) {
                    oldAuthorOrNull = _enterAuthor(state, a) || "none";
                    break;
                  }
                }
              }
            }
          }
          for (const c of node.childNodes) {
            cc.collectContent(c, state);
          }
          if (collectStyles) {
            hooks$1.callAll("collectContentPost", {
              cc,
              state,
              tname,
              styl,
              cls
            });
          }
          if (isPre)
            cc.decrementFlag(state, "preMode");
          if (state.localAttribs) {
            for (let i = 0; i < state.localAttribs.length; i++) {
              cc.decrementAttrib(state, state.localAttribs[i]);
            }
          }
          if (oldListTypeOrNull) {
            _exitList(state, oldListTypeOrNull);
          }
          if (oldAuthorOrNull) {
            _exitAuthor(state, oldAuthorOrNull);
          }
        }
      }
      _reachBlockPoint(node, 1, state);
      if (isBlock) {
        if (lines.length() - 1 === startLine) {
          if (state.lineAttributes && !state.lineAttributes.list || typeof window === "undefined") {
            cc.startNewLine(state);
          }
        } else {
          _ensureColumnZero(state);
        }
      }
      state.localAttribs = localAttribs;
      if (unsupportedElements && unsupportedElements.size) {
        console.warn(`Ignoring unsupported elements (you might want to install a plugin): ${[...unsupportedElements].join(", ")}`);
      }
    };
    cc.notifyNextNode = (node) => {
      if (!node || isBlockElement(node) && !_isEmpty(node)) {
        _ensureColumnZero(null);
      }
    };
    const getSelectionStart = () => selStart;
    const getSelectionEnd = () => selEnd;
    cc.getLines = () => lines.textLines();
    cc.finish = () => {
      lines.flush();
      const lineAttribs = lines.attribLines();
      const lineStrings = cc.getLines();
      lineStrings.length--;
      lineAttribs.length--;
      const ss = getSelectionStart();
      const se = getSelectionEnd();
      const fixLongLines = () => {
        const lineLimit = 2e3;
        const buffer = 10;
        let linesWrapped = 0;
        let numLinesAfter = 0;
        for (let i = lineStrings.length - 1; i >= 0; i--) {
          let oldString = lineStrings[i];
          let oldAttribString = lineAttribs[i];
          if (oldString.length > lineLimit + buffer) {
            const newStrings = [];
            const newAttribStrings = [];
            while (oldString.length > lineLimit) {
              const lengthToTake = lineLimit;
              newStrings.push(oldString.substring(0, lengthToTake));
              oldString = oldString.substring(lengthToTake);
              newAttribStrings.push(Changeset2.subattribution(oldAttribString, 0, lengthToTake));
              oldAttribString = Changeset2.subattribution(oldAttribString, lengthToTake);
            }
            if (oldString.length > 0) {
              newStrings.push(oldString);
              newAttribStrings.push(oldAttribString);
            }
            const fixLineNumber = (lineChar) => {
              if (lineChar[0] < 0)
                return;
              let n = lineChar[0];
              let c = lineChar[1];
              if (n > i) {
                n += newStrings.length - 1;
              } else if (n === i) {
                let a = 0;
                while (c > newStrings[a].length) {
                  c -= newStrings[a].length;
                  a++;
                }
                n += a;
              }
              lineChar[0] = n;
              lineChar[1] = c;
            };
            fixLineNumber(ss);
            fixLineNumber(se);
            linesWrapped++;
            numLinesAfter += newStrings.length;
            lineStrings.splice(i, 1, ...newStrings);
            lineAttribs.splice(i, 1, ...newAttribStrings);
          }
        }
        return {
          linesWrapped,
          numLinesAfter
        };
      };
      const wrapData = fixLongLines();
      return {
        selStart: ss,
        selEnd: se,
        linesWrapped: wrapData.linesWrapped,
        numLinesAfter: wrapData.numLinesAfter,
        lines: lineStrings,
        lineAttribs
      };
    };
    return cc;
  };
  contentcollector.sanitizeUnicode = sanitizeUnicode;
  contentcollector.makeContentCollector = makeContentCollector;
  contentcollector.supportedElems = supportedElems;
  return contentcollector;
}
var domline = {};
var VERSION = "1.13.6";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
function isNull(obj) {
  return obj === null;
}
function isUndefined(obj) {
  return obj === void 0;
}
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
const isString = tagTester("String");
const isNumber = tagTester("Number");
const isDate = tagTester("Date");
const isRegExp = tagTester("RegExp");
const isError = tagTester("Error");
const isSymbol = tagTester("Symbol");
const isArrayBuffer = tagTester("ArrayBuffer");
var isFunction = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction = function(obj) {
    return typeof obj == "function" || false;
  };
}
const isFunction$1 = isFunction;
const hasObjectTag = tagTester("Object");
var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
var isDataView = tagTester("DataView");
function ie10IsDataView(obj) {
  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
}
const isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;
const isArray = nativeIsArray || tagTester("Array");
function has$1(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has$1(obj, "callee");
    };
  }
})();
const isArguments$1 = isArguments;
function isFinite$1(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
function isNaN$1(obj) {
  return isNumber(obj) && _isNaN(obj);
}
function constant(value) {
  return function() {
    return value;
  };
}
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
const getByteLength = shallowProperty("byteLength");
const isBufferLike = createSizePropertyCheck(getByteLength);
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
}
const isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
const getLength = shallowProperty("length");
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i = 0; i < l; ++i)
    hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has$1(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
function keys(obj) {
  if (!isObject(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has$1(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength(obj);
  if (typeof length == "number" && (isArray(obj) || isString(obj) || isArguments$1(obj)))
    return length === 0;
  return getLength(keys(obj)) === 0;
}
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}
function _$1(obj) {
  if (obj instanceof _$1)
    return obj;
  if (!(this instanceof _$1))
    return new _$1(obj);
  this._wrapped = obj;
}
_$1.VERSION = VERSION;
_$1.prototype.value = function() {
  return this._wrapped;
};
_$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
_$1.prototype.toString = function() {
  return String(this._wrapped);
};
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength(bufferSource)
  );
}
var tagDataView = "[object DataView]";
function eq(a, b, aStack, bStack) {
  if (a === b)
    return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null)
    return false;
  if (a !== a)
    return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object")
    return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _$1)
    a = a._wrapped;
  if (b instanceof _$1)
    b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b))
    return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView$1(a)) {
    if (!isDataView$1(b))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a)
        return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray$1(a)) {
    var byteLength = getByteLength(a);
    if (byteLength !== getByteLength(b))
      return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object")
      return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length)
      return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
function allKeys(obj) {
  if (!isObject(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
function ie11fingerprint(methods) {
  var length = getLength(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength(keys2))
      return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction$1(obj[methods[i]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
  };
}
var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
const isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
const isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
const isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
const isWeakSet = tagTester("WeakSet");
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction$1(obj[key]))
      names.push(key);
  }
  return names.sort();
}
function createAssigner(keysFunc, defaults2) {
  return function(obj) {
    var length = arguments.length;
    if (defaults2)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
      for (var i = 0; i < l; i++) {
        var key = keys2[i];
        if (!defaults2 || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}
const extend = createAssigner(allKeys);
const extendOwn = createAssigner(keys);
const defaults = createAssigner(allKeys, true);
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn(result2, props);
  return result2;
}
function clone(obj) {
  if (!isObject(obj))
    return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
function toPath$1(path) {
  return isArray(path) ? path : [path];
}
_$1.toPath = toPath$1;
function toPath(path) {
  return _$1.toPath(path);
}
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null)
      return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath(path));
  return isUndefined(value) ? defaultValue : value;
}
function has(obj, path) {
  path = toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has$1(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}
function identity(value) {
  return value;
}
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
function property(path) {
  path = toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction$1(value))
    return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray(value))
    return matcher(value);
  return property(value);
}
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_$1.iteratee = iteratee;
function cb(value, context, argCount) {
  if (_$1.iteratee !== iteratee)
    return _$1.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
function noop() {
}
function propertyOf(obj) {
  if (obj == null)
    return noop;
  return function(path) {
    return get(obj, path);
  };
}
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++)
    accum[i] = iteratee2(i);
  return accum;
}
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
const now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function createEscaper(map2) {
  var escaper = function(match) {
    return map2[match];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
const escapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};
const escape$1 = createEscaper(escapeMap);
const unescapeMap = invert(escapeMap);
const unescape = createEscaper(unescapeMap);
const templateSettings = _$1.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return "\\" + escapes[match];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults({}, settings, _$1.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _$1);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
function result(obj, path, fallback) {
  path = toPath(path);
  var length = path.length;
  if (!length) {
    return isFunction$1(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction$1(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
function chain(obj) {
  var instance = _$1(obj);
  instance._chain = true;
  return instance;
}
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2))
    return result2;
  return self2;
}
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length)
      args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _$1;
const bind = restArguments(function(func, context, args) {
  if (!isFunction$1(func))
    throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});
const isArrayLike = createSizePropertyCheck(getLength);
function flatten$1(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      if (depth > 1) {
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len)
          output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
const bindAll = restArguments(function(obj, keys2) {
  keys2 = flatten$1(keys2, false, false);
  var index = keys2.length;
  if (index < 1)
    throw new Error("bindAll must be passed function names");
  while (index--) {
    var key = keys2[index];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
});
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has$1(cache, address))
      cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
const delay = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});
const defer = partial(delay, _$1, 1);
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
function wrap(func, wrapper) {
  return partial(wrapper, func);
}
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--)
      result2 = args[i].call(this, result2);
    return result2;
  };
}
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}
const once = partial(before, 2);
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj))
      return key;
  }
}
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array))
        return index;
    }
    return -1;
  };
}
const findIndex = createPredicateIndexFinder(1);
const findLastIndex = createPredicateIndexFinder(-1);
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN$1);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
const indexOf = createIndexFinder(1, findIndex, sortedIndex);
const lastIndexOf = createIndexFinder(-1, findLastIndex);
function find(obj, predicate, context) {
  var keyFinder = isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
const reduce = createReduce(1);
const reduceRight = createReduce(-1);
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list))
      results.push(value);
  });
  return results;
}
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}
const invoke = restArguments(function(obj, path, args) {
  var contextPath, func;
  if (isFunction$1(path)) {
    func = path;
  } else {
    path = toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null)
        return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});
function pluck(obj, key) {
  return map(obj, property(key));
}
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
function max(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray(obj))
    return slice.call(obj);
  if (isString(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike(obj))
    return map(obj, identity);
  return values(obj);
}
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
function shuffle(obj) {
  return sample(obj, Infinity);
}
function sortBy(obj, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0)
        return 1;
      if (a < b || b === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
function group(behavior, partition2) {
  return function(obj, iteratee2, context) {
    var result2 = partition2 ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
const groupBy = group(function(result2, value, key) {
  if (has$1(result2, key))
    result2[key].push(value);
  else
    result2[key] = [value];
});
const indexBy = group(function(result2, value, key) {
  result2[key] = value;
});
const countBy = group(function(result2, value, key) {
  if (has$1(result2, key))
    result2[key]++;
  else
    result2[key] = 1;
});
const partition = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);
function size(obj) {
  if (obj == null)
    return 0;
  return isArrayLike(obj) ? obj.length : keys(obj).length;
}
function keyInObj(value, key, obj) {
  return key in obj;
}
const pick = restArguments(function(obj, keys2) {
  var result2 = {}, iteratee2 = keys2[0];
  if (obj == null)
    return result2;
  if (isFunction$1(iteratee2)) {
    if (keys2.length > 1)
      iteratee2 = optimizeCb(iteratee2, keys2[1]);
    keys2 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys2 = flatten$1(keys2, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys2.length; i < length; i++) {
    var key = keys2[i];
    var value = obj[key];
    if (iteratee2(value, key, obj))
      result2[key] = value;
  }
  return result2;
});
const omit = restArguments(function(obj, keys2) {
  var iteratee2 = keys2[0], context;
  if (isFunction$1(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys2.length > 1)
      context = keys2[1];
  } else {
    keys2 = map(flatten$1(keys2, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys2, key);
    };
  }
  return pick(obj, iteratee2, context);
});
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
function first(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[0];
  return initial(array, array.length - n);
}
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
function last(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
function compact(array) {
  return filter(array, Boolean);
}
function flatten(array, depth) {
  return flatten$1(array, depth, false);
}
const difference = restArguments(function(array, rest2) {
  rest2 = flatten$1(rest2, true, true);
  return filter(array, function(value) {
    return !contains(rest2, value);
  });
});
const without = restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
});
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
const union = restArguments(function(arrays) {
  return uniq(flatten$1(arrays, true, true));
});
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item))
      continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item))
        break;
    }
    if (j === argsLength)
      result2.push(item);
  }
  return result2;
}
function unzip(array) {
  var length = array && max(array, getLength).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
const zip = restArguments(unzip);
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
function chunk(array, count) {
  if (count == null || count < 1)
    return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}
function chainResult(instance, obj) {
  return instance._chain ? _$1(obj).chain() : obj;
}
function mixin$1(obj) {
  each(functions(obj), function(name) {
    var func = _$1[name] = obj[name];
    _$1.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_$1, args));
    };
  });
  return _$1;
}
each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each(["concat", "join", "slice"], function(name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null)
      obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
const allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION,
  after,
  all: every,
  allKeys,
  any: some,
  assign: extendOwn,
  before,
  bind,
  bindAll,
  chain,
  chunk,
  clone,
  collect: map,
  compact,
  compose,
  constant,
  contains,
  countBy,
  create,
  debounce,
  default: _$1,
  defaults,
  defer,
  delay,
  detect: find,
  difference,
  drop: rest,
  each,
  escape: escape$1,
  every,
  extend,
  extendOwn,
  filter,
  find,
  findIndex,
  findKey,
  findLastIndex,
  findWhere,
  first,
  flatten,
  foldl: reduce,
  foldr: reduceRight,
  forEach: each,
  functions,
  get,
  groupBy,
  has,
  head: first,
  identity,
  include: contains,
  includes: contains,
  indexBy,
  indexOf,
  initial,
  inject: reduce,
  intersection,
  invert,
  invoke,
  isArguments: isArguments$1,
  isArray,
  isArrayBuffer,
  isBoolean,
  isDataView: isDataView$1,
  isDate,
  isElement,
  isEmpty,
  isEqual,
  isError,
  isFinite: isFinite$1,
  isFunction: isFunction$1,
  isMap,
  isMatch,
  isNaN: isNaN$1,
  isNull,
  isNumber,
  isObject,
  isRegExp,
  isSet,
  isString,
  isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined,
  isWeakMap,
  isWeakSet,
  iteratee,
  keys,
  last,
  lastIndexOf,
  map,
  mapObject,
  matcher,
  matches: matcher,
  max,
  memoize,
  methods: functions,
  min,
  mixin: mixin$1,
  negate,
  noop,
  now,
  object,
  omit,
  once,
  pairs,
  partial,
  partition,
  pick,
  pluck,
  property,
  propertyOf,
  random,
  range,
  reduce,
  reduceRight,
  reject,
  rest,
  restArguments,
  result,
  sample,
  select: filter,
  shuffle,
  size,
  some,
  sortBy,
  sortedIndex,
  tail: rest,
  take: first,
  tap,
  template,
  templateSettings,
  throttle,
  times,
  toArray,
  toPath: toPath$1,
  transpose: unzip,
  unescape,
  union,
  uniq,
  unique: uniq,
  uniqueId,
  unzip,
  values,
  where,
  without,
  wrap,
  zip
}, Symbol.toStringTag, { value: "Module" }));
var _ = mixin$1(allExports);
_._ = _;
const indexAll = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION,
  after,
  all: every,
  allKeys,
  any: some,
  assign: extendOwn,
  before,
  bind,
  bindAll,
  chain,
  chunk,
  clone,
  collect: map,
  compact,
  compose,
  constant,
  contains,
  countBy,
  create,
  debounce,
  default: _,
  defaults,
  defer,
  delay,
  detect: find,
  difference,
  drop: rest,
  each,
  escape: escape$1,
  every,
  extend,
  extendOwn,
  filter,
  find,
  findIndex,
  findKey,
  findLastIndex,
  findWhere,
  first,
  flatten,
  foldl: reduce,
  foldr: reduceRight,
  forEach: each,
  functions,
  get,
  groupBy,
  has,
  head: first,
  identity,
  include: contains,
  includes: contains,
  indexBy,
  indexOf,
  initial,
  inject: reduce,
  intersection,
  invert,
  invoke,
  isArguments: isArguments$1,
  isArray,
  isArrayBuffer,
  isBoolean,
  isDataView: isDataView$1,
  isDate,
  isElement,
  isEmpty,
  isEqual,
  isError,
  isFinite: isFinite$1,
  isFunction: isFunction$1,
  isMap,
  isMatch,
  isNaN: isNaN$1,
  isNull,
  isNumber,
  isObject,
  isRegExp,
  isSet,
  isString,
  isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined,
  isWeakMap,
  isWeakSet,
  iteratee,
  keys,
  last,
  lastIndexOf,
  map,
  mapObject,
  matcher,
  matches: matcher,
  max,
  memoize,
  methods: functions,
  min,
  mixin: mixin$1,
  negate,
  noop,
  now,
  object,
  omit,
  once,
  pairs,
  partial,
  partition,
  pick,
  pluck,
  property,
  propertyOf,
  random,
  range,
  reduce,
  reduceRight,
  reject,
  rest,
  restArguments,
  result,
  sample,
  select: filter,
  shuffle,
  size,
  some,
  sortBy,
  sortedIndex,
  tail: rest,
  take: first,
  tap,
  template,
  templateSettings,
  throttle,
  times,
  toArray,
  toPath: toPath$1,
  transpose: unzip,
  unescape,
  union,
  uniq,
  unique: uniq,
  uniqueId,
  unzip,
  values,
  where,
  without,
  wrap,
  zip
}, Symbol.toStringTag, { value: "Module" }));
var underscore;
var hasRequiredUnderscore;
function requireUnderscore() {
  if (hasRequiredUnderscore)
    return underscore;
  hasRequiredUnderscore = 1;
  underscore = indexAll;
  return underscore;
}
var linestylefilter = {};
var ChangesetUtils = {};
var hasRequiredChangesetUtils;
function requireChangesetUtils() {
  if (hasRequiredChangesetUtils)
    return ChangesetUtils;
  hasRequiredChangesetUtils = 1;
  ChangesetUtils.buildRemoveRange = (rep, builder, start, end) => {
    const startLineOffset = rep.lines.offsetOfIndex(start[0]);
    const endLineOffset = rep.lines.offsetOfIndex(end[0]);
    if (end[0] > start[0]) {
      builder.remove(endLineOffset - startLineOffset - start[1], end[0] - start[0]);
      builder.remove(end[1]);
    } else {
      builder.remove(end[1] - start[1]);
    }
  };
  ChangesetUtils.buildKeepRange = (rep, builder, start, end, attribs, pool) => {
    const startLineOffset = rep.lines.offsetOfIndex(start[0]);
    const endLineOffset = rep.lines.offsetOfIndex(end[0]);
    if (end[0] > start[0]) {
      builder.keep(endLineOffset - startLineOffset - start[1], end[0] - start[0], attribs, pool);
      builder.keep(end[1], 0, attribs, pool);
    } else {
      builder.keep(end[1] - start[1], 0, attribs, pool);
    }
  };
  ChangesetUtils.buildKeepToStartOfRange = (rep, builder, start) => {
    const startLineOffset = rep.lines.offsetOfIndex(start[0]);
    builder.keep(startLineOffset, start[0]);
    builder.keep(start[1]);
  };
  return ChangesetUtils;
}
var AttributeManager_1;
var hasRequiredAttributeManager;
function requireAttributeManager() {
  if (hasRequiredAttributeManager)
    return AttributeManager_1;
  hasRequiredAttributeManager = 1;
  const AttributeMap = requireAttributeMap();
  const Changeset2 = requireChangeset();
  const ChangesetUtils2 = requireChangesetUtils();
  const attributes2 = requireAttributes();
  const underscore2 = indexAll;
  const lineMarkerAttribute = "lmkr";
  const DEFAULT_LINE_ATTRIBUTES = ["author", "lmkr", "insertorder", "start"];
  const lineAttributes = [lineMarkerAttribute, "list"];
  const AttributeManager = function(rep, applyChangesetCallback) {
    this.rep = rep;
    this.applyChangesetCallback = applyChangesetCallback;
    this.author = "";
  };
  AttributeManager.DEFAULT_LINE_ATTRIBUTES = DEFAULT_LINE_ATTRIBUTES;
  AttributeManager.lineAttributes = lineAttributes;
  AttributeManager.prototype = underscore2.default(AttributeManager.prototype).extend({
    applyChangeset(changeset) {
      if (!this.applyChangesetCallback)
        return changeset;
      const cs = changeset.toString();
      if (!Changeset2.isIdentity(cs)) {
        this.applyChangesetCallback(cs);
      }
      return changeset;
    },
    /*
      Sets attributes on a range
      @param start [row, col] tuple pointing to the start of the range
      @param end [row, col] tuple pointing to the end of the range
      @param attribs: an array of attributes
    */
    setAttributesOnRange(start, end, attribs) {
      if (start[0] < 0)
        throw new RangeError("selection start line number is negative");
      if (start[1] < 0)
        throw new RangeError("selection start column number is negative");
      if (end[0] < 0)
        throw new RangeError("selection end line number is negative");
      if (end[1] < 0)
        throw new RangeError("selection end column number is negative");
      if (start[0] > end[0] || start[0] === end[0] && start[1] > end[1]) {
        throw new RangeError("selection ends before it starts");
      }
      let allChangesets;
      for (let row = start[0]; row <= end[0]; row++) {
        const [startCol, endCol] = this._findRowRange(row, start, end);
        const rowChangeset = this._setAttributesOnRangeByLine(row, startCol, endCol, attribs);
        if (allChangesets) {
          allChangesets = Changeset2.compose(
            allChangesets.toString(),
            rowChangeset.toString(),
            this.rep.apool
          );
        } else {
          allChangesets = rowChangeset;
        }
      }
      return this.applyChangeset(allChangesets);
    },
    _findRowRange(row, start, end) {
      if (row < start[0] || row > end[0])
        throw new RangeError(`line ${row} not in selection`);
      if (row >= this.rep.lines.length())
        throw new RangeError(`selected line ${row} does not exist`);
      const lineLength = this.rep.lines.offsetOfIndex(row + 1) - this.rep.lines.offsetOfIndex(row) - 1;
      const markerWidth = this.lineHasMarker(row) ? 1 : 0;
      if (lineLength - markerWidth < 0)
        throw new Error(`line ${row} has negative length`);
      if (start[1] < 0)
        throw new RangeError("selection starts at negative column");
      const startCol = Math.max(markerWidth, row === start[0] ? start[1] : 0);
      if (startCol > lineLength)
        throw new RangeError("selection starts after line end");
      if (end[1] < 0)
        throw new RangeError("selection ends at negative column");
      const endCol = Math.max(markerWidth, row === end[0] ? end[1] : lineLength);
      if (endCol > lineLength)
        throw new RangeError("selection ends after line end");
      if (startCol > endCol)
        throw new RangeError("selection ends before it starts");
      return [startCol, endCol];
    },
    /**
     * Sets attributes on a range, by line
     * @param row the row where range is
     * @param startCol column where range starts
     * @param endCol column where range ends (one past the last selected column)
     * @param attribs an array of attributes
     */
    _setAttributesOnRangeByLine(row, startCol, endCol, attribs) {
      const builder = Changeset2.builder(this.rep.lines.totalWidth());
      ChangesetUtils2.buildKeepToStartOfRange(this.rep, builder, [row, startCol]);
      ChangesetUtils2.buildKeepRange(
        this.rep,
        builder,
        [row, startCol],
        [row, endCol],
        attribs,
        this.rep.apool
      );
      return builder;
    },
    /*
      Returns if the line already has a line marker
      @param lineNum: the number of the line
    */
    lineHasMarker(lineNum) {
      return lineAttributes.find(
        (attribute) => this.getAttributeOnLine(lineNum, attribute) !== ""
      ) !== void 0;
    },
    /*
      Gets a specified attribute on a line
      @param lineNum: the number of the line to set the attribute for
      @param attributeKey: the name of the attribute to get, e.g. list
    */
    getAttributeOnLine(lineNum, attributeName) {
      const aline = this.rep.alines[lineNum];
      if (!aline)
        return "";
      const [op] = Changeset2.deserializeOps(aline);
      if (op == null)
        return "";
      return AttributeMap.fromString(op.attribs, this.rep.apool).get(attributeName) || "";
    },
    /*
      Gets all attributes on a line
      @param lineNum: the number of the line to get the attribute for
    */
    getAttributesOnLine(lineNum) {
      const aline = this.rep.alines[lineNum];
      if (!aline)
        return [];
      const [op] = Changeset2.deserializeOps(aline);
      if (op == null)
        return [];
      return [...attributes2.attribsFromString(op.attribs, this.rep.apool)];
    },
    /*
      Gets a given attribute on a selection
      @param attributeName
      @param prevChar
      returns true or false if an attribute is visible in range
    */
    getAttributeOnSelection(attributeName, prevChar) {
      const rep = this.rep;
      if (!(rep.selStart && rep.selEnd))
        return;
      const isNotSelection = rep.selStart[0] === rep.selEnd[0] && rep.selEnd[1] === rep.selStart[1];
      if (isNotSelection) {
        if (prevChar) {
          if (rep.selStart[1] !== 0) {
            rep.selStart[1]--;
          }
        }
      }
      const withIt = new AttributeMap(rep.apool).set(attributeName, "true").toString();
      const withItRegex = new RegExp(`${withIt.replace(/\*/g, "\\*")}(\\*|$)`);
      const hasIt = (attribs) => withItRegex.test(attribs);
      const rangeHasAttrib = (selStart, selEnd) => {
        if (selStart[1] === selEnd[1] && selStart[0] === selEnd[0])
          return false;
        if (selStart[0] !== selEnd[0]) {
          let hasAttrib2 = rangeHasAttrib(
            selStart,
            [selStart[0], rep.lines.atIndex(selStart[0]).text.length]
          );
          for (let n = selStart[0] + 1; n < selEnd[0]; n++) {
            hasAttrib2 = hasAttrib2 && rangeHasAttrib([n, 0], [n, rep.lines.atIndex(n).text.length]);
          }
          hasAttrib2 = hasAttrib2 && rangeHasAttrib([selEnd[0], 0], [selEnd[0], selEnd[1]]);
          return hasAttrib2;
        }
        const lineNum = selStart[0];
        const start = selStart[1];
        const end = selEnd[1];
        let hasAttrib = true;
        let indexIntoLine = 0;
        for (const op of Changeset2.deserializeOps(rep.alines[lineNum])) {
          const opStartInLine = indexIntoLine;
          const opEndInLine = opStartInLine + op.chars;
          if (!hasIt(op.attribs)) {
            if (!(opEndInLine <= start || opStartInLine >= end)) {
              hasAttrib = false;
              break;
            }
          }
          indexIntoLine = opEndInLine;
        }
        return hasAttrib;
      };
      return rangeHasAttrib(rep.selStart, rep.selEnd);
    },
    /*
      Gets all attributes at a position containing line number and column
      @param lineNumber starting with zero
      @param column starting with zero
      returns a list of attributes in the format
      [ ["key","value"], ["key","value"], ...  ]
    */
    getAttributesOnPosition(lineNumber, column) {
      const aline = this.rep.alines[lineNumber];
      if (!aline) {
        return [];
      }
      let currentPointer = 0;
      for (const currentOperation of Changeset2.deserializeOps(aline)) {
        currentPointer += currentOperation.chars;
        if (currentPointer <= column)
          continue;
        return [...attributes2.attribsFromString(currentOperation.attribs, this.rep.apool)];
      }
      return [];
    },
    /*
      Gets all attributes at caret position
      if the user selected a range, the start of the selection is taken
      returns a list of attributes in the format
      [ ["key","value"], ["key","value"], ...  ]
    */
    getAttributesOnCaret() {
      return this.getAttributesOnPosition(this.rep.selStart[0], this.rep.selStart[1]);
    },
    /*
    	    Sets a specified attribute on a line
    	    @param lineNum: the number of the line to set the attribute for
    	    @param attributeKey: the name of the attribute to set, e.g. list
    	    @param attributeValue: an optional parameter to pass to the attribute (e.g. indention level)
    
    	  */
    setAttributeOnLine(lineNum, attributeName, attributeValue) {
      let loc = [0, 0];
      const builder = Changeset2.builder(this.rep.lines.totalWidth());
      const hasMarker = this.lineHasMarker(lineNum);
      ChangesetUtils2.buildKeepRange(this.rep, builder, loc, loc = [lineNum, 0]);
      if (hasMarker) {
        ChangesetUtils2.buildKeepRange(this.rep, builder, loc, loc = [lineNum, 1], [
          [attributeName, attributeValue]
        ], this.rep.apool);
      } else {
        builder.insert("*", [
          ["author", this.author],
          ["insertorder", "first"],
          [lineMarkerAttribute, "1"],
          [attributeName, attributeValue]
        ], this.rep.apool);
      }
      return this.applyChangeset(builder);
    },
    /**
     * Removes a specified attribute on a line
     *  @param lineNum the number of the affected line
     *  @param attributeName the name of the attribute to remove, e.g. list
     *  @param attributeValue if given only attributes with equal value will be removed
     */
    removeAttributeOnLine(lineNum, attributeName, attributeValue) {
      const builder = Changeset2.builder(this.rep.lines.totalWidth());
      const hasMarker = this.lineHasMarker(lineNum);
      let found = false;
      const attribs = this.getAttributesOnLine(lineNum).map((attrib) => {
        if (attrib[0] === attributeName && (!attributeValue || attrib[0] === attributeValue)) {
          found = true;
          return [attrib[0], ""];
        } else if (attrib[0] === "author") {
          return [attrib[0], this.author];
        }
        return attrib;
      });
      if (!found) {
        return;
      }
      ChangesetUtils2.buildKeepToStartOfRange(this.rep, builder, [lineNum, 0]);
      const countAttribsWithMarker = underscore2.chain(attribs).filter((a) => !!a[1]).map((a) => a[0]).difference(DEFAULT_LINE_ATTRIBUTES).size().value();
      if (hasMarker && !countAttribsWithMarker) {
        ChangesetUtils2.buildRemoveRange(this.rep, builder, [lineNum, 0], [lineNum, 1]);
      } else {
        ChangesetUtils2.buildKeepRange(
          this.rep,
          builder,
          [lineNum, 0],
          [lineNum, 1],
          attribs,
          this.rep.apool
        );
      }
      return this.applyChangeset(builder);
    },
    /*
       Toggles a line attribute for the specified line number
       If a line attribute with the specified name exists with any value it will be removed
       Otherwise it will be set to the given value
       @param lineNum: the number of the line to toggle the attribute for
       @param attributeKey: the name of the attribute to toggle, e.g. list
       @param attributeValue: the value to pass to the attribute (e.g. indention level)
    */
    toggleAttributeOnLine(lineNum, attributeName, attributeValue) {
      return this.getAttributeOnLine(lineNum, attributeName) ? this.removeAttributeOnLine(lineNum, attributeName) : this.setAttributeOnLine(lineNum, attributeName, attributeValue);
    },
    hasAttributeOnSelectionOrCaretPosition(attributeName) {
      const hasSelection = this.rep.selStart[0] !== this.rep.selEnd[0] || this.rep.selEnd[1] !== this.rep.selStart[1];
      let hasAttrib;
      if (hasSelection) {
        hasAttrib = this.getAttributeOnSelection(attributeName);
      } else {
        const attributesOnCaretPosition = this.getAttributesOnCaret();
        const allAttribs = [].concat(...attributesOnCaretPosition);
        hasAttrib = allAttribs.includes(attributeName);
      }
      return hasAttrib;
    }
  });
  AttributeManager_1 = AttributeManager;
  return AttributeManager_1;
}
var hasRequiredLinestylefilter;
function requireLinestylefilter() {
  if (hasRequiredLinestylefilter)
    return linestylefilter;
  hasRequiredLinestylefilter = 1;
  const Changeset2 = requireChangeset();
  const attributes2 = requireAttributes();
  const hooks$1 = hooks;
  const linestylefilter$1 = {};
  const AttributeManager = requireAttributeManager();
  const padutils = requirePad_utils().padutils;
  linestylefilter$1.ATTRIB_CLASSES = {
    bold: "tag:b",
    italic: "tag:i",
    underline: "tag:u",
    strikethrough: "tag:s"
  };
  const lineAttributeMarker = "lineAttribMarker";
  linestylefilter.lineAttributeMarker = lineAttributeMarker;
  linestylefilter$1.getAuthorClassName = (author) => `author-${author.replace(/[^a-y0-9]/g, (c) => {
    if (c === ".")
      return "-";
    return `z${c.charCodeAt(0)}z`;
  })}`;
  linestylefilter$1.getLineStyleFilter = (lineLength, aline, textAndClassFunc, apool) => {
    for (const attribClasses of hooks$1.callAll("aceAttribClasses", linestylefilter$1.ATTRIB_CLASSES)) {
      Object.assign(linestylefilter$1.ATTRIB_CLASSES, attribClasses);
    }
    if (lineLength === 0)
      return textAndClassFunc;
    const nextAfterAuthorColors = textAndClassFunc;
    const authorColorFunc = (() => {
      const lineEnd = lineLength;
      let curIndex = 0;
      let extraClasses;
      let leftInAuthor;
      const attribsToClasses = (attribs) => {
        let classes = "";
        let isLineAttribMarker = false;
        for (const [key, value] of attributes2.attribsFromString(attribs, apool)) {
          if (!key || !value)
            continue;
          if (!isLineAttribMarker && AttributeManager.lineAttributes.indexOf(key) >= 0) {
            isLineAttribMarker = true;
          }
          if (key === "author") {
            classes += ` ${linestylefilter$1.getAuthorClassName(value)}`;
          } else if (key === "list") {
            classes += ` list:${value}`;
          } else if (key === "start") {
            classes += ` start:${value}`;
          } else if (linestylefilter$1.ATTRIB_CLASSES[key]) {
            classes += ` ${linestylefilter$1.ATTRIB_CLASSES[key]}`;
          } else {
            const results = hooks$1.callAll("aceAttribsToClasses", { linestylefilter: linestylefilter$1, key, value });
            classes += ` ${results.join(" ")}`;
          }
        }
        if (isLineAttribMarker)
          classes += ` ${lineAttributeMarker}`;
        return classes.substring(1);
      };
      const attrOps = Changeset2.deserializeOps(aline);
      let attrOpsNext = attrOps.next();
      let nextOp, nextOpClasses;
      const goNextOp = () => {
        nextOp = attrOpsNext.done ? new Changeset2.Op() : attrOpsNext.value;
        if (!attrOpsNext.done)
          attrOpsNext = attrOps.next();
        nextOpClasses = nextOp.opcode && attribsToClasses(nextOp.attribs);
      };
      goNextOp();
      const nextClasses = () => {
        if (curIndex < lineEnd) {
          extraClasses = nextOpClasses;
          leftInAuthor = nextOp.chars;
          goNextOp();
          while (nextOp.opcode && nextOpClasses === extraClasses) {
            leftInAuthor += nextOp.chars;
            goNextOp();
          }
        }
      };
      nextClasses();
      return (txt, cls) => {
        const disableAuthColorForThisLine = hooks$1.callAll("disableAuthorColorsForThisLine", {
          linestylefilter: linestylefilter$1,
          text: txt,
          class: cls
        });
        const disableAuthors = disableAuthColorForThisLine == null || disableAuthColorForThisLine.length === 0 ? false : disableAuthColorForThisLine[0];
        while (txt.length > 0) {
          if (leftInAuthor <= 0 || disableAuthors) {
            return nextAfterAuthorColors(txt, cls);
          }
          let spanSize = txt.length;
          if (spanSize > leftInAuthor) {
            spanSize = leftInAuthor;
          }
          const curTxt = txt.substring(0, spanSize);
          txt = txt.substring(spanSize);
          nextAfterAuthorColors(curTxt, (cls && `${cls} `) + extraClasses);
          curIndex += spanSize;
          leftInAuthor -= spanSize;
          if (leftInAuthor === 0) {
            nextClasses();
          }
        }
      };
    })();
    return authorColorFunc;
  };
  linestylefilter$1.getAtSignSplitterFilter = (lineText, textAndClassFunc) => {
    const at = /@/g;
    at.lastIndex = 0;
    let splitPoints = null;
    let execResult;
    while (execResult = at.exec(lineText)) {
      if (!splitPoints) {
        splitPoints = [];
      }
      splitPoints.push(execResult.index);
    }
    if (!splitPoints)
      return textAndClassFunc;
    return linestylefilter$1.textAndClassFuncSplitter(textAndClassFunc, splitPoints);
  };
  linestylefilter$1.getRegexpFilter = (regExp, tag) => (lineText, textAndClassFunc) => {
    regExp.lastIndex = 0;
    let regExpMatchs = null;
    let splitPoints = null;
    let execResult;
    while (execResult = regExp.exec(lineText)) {
      if (!regExpMatchs) {
        regExpMatchs = [];
        splitPoints = [];
      }
      const startIndex = execResult.index;
      const regExpMatch = execResult[0];
      regExpMatchs.push([startIndex, regExpMatch]);
      splitPoints.push(startIndex, startIndex + regExpMatch.length);
    }
    if (!regExpMatchs)
      return textAndClassFunc;
    const regExpMatchForIndex = (idx) => {
      for (let k = 0; k < regExpMatchs.length; k++) {
        const u = regExpMatchs[k];
        if (idx >= u[0] && idx < u[0] + u[1].length) {
          return u[1];
        }
      }
      return false;
    };
    const handleRegExpMatchsAfterSplit = /* @__PURE__ */ (() => {
      let curIndex = 0;
      return (txt, cls) => {
        const txtlen = txt.length;
        let newCls = cls;
        const regExpMatch = regExpMatchForIndex(curIndex);
        if (regExpMatch) {
          newCls += ` ${tag}:${regExpMatch}`;
        }
        textAndClassFunc(txt, newCls);
        curIndex += txtlen;
      };
    })();
    return linestylefilter$1.textAndClassFuncSplitter(handleRegExpMatchsAfterSplit, splitPoints);
  };
  linestylefilter$1.getURLFilter = linestylefilter$1.getRegexpFilter(padutils.urlRegex, "url");
  linestylefilter$1.textAndClassFuncSplitter = (func, splitPointsOpt) => {
    let nextPointIndex = 0;
    let idx = 0;
    while (splitPointsOpt && nextPointIndex < splitPointsOpt.length && splitPointsOpt[nextPointIndex] === 0) {
      nextPointIndex++;
    }
    const spanHandler = (txt, cls) => {
      if (!splitPointsOpt || nextPointIndex >= splitPointsOpt.length) {
        func(txt, cls);
        idx += txt.length;
      } else {
        const splitPoints = splitPointsOpt;
        const pointLocInSpan = splitPoints[nextPointIndex] - idx;
        const txtlen = txt.length;
        if (pointLocInSpan >= txtlen) {
          func(txt, cls);
          idx += txt.length;
          if (pointLocInSpan === txtlen) {
            nextPointIndex++;
          }
        } else {
          if (pointLocInSpan > 0) {
            func(txt.substring(0, pointLocInSpan), cls);
            idx += pointLocInSpan;
          }
          nextPointIndex++;
          spanHandler(txt.substring(pointLocInSpan), cls);
        }
      }
    };
    return spanHandler;
  };
  linestylefilter$1.getFilterStack = (lineText, textAndClassFunc, abrowser) => {
    let func = linestylefilter$1.getURLFilter(lineText, textAndClassFunc);
    const hookFilters = hooks$1.callAll("aceGetFilterStack", {
      linestylefilter: linestylefilter$1,
      browser: abrowser
    });
    hookFilters.map((hookFilter) => {
      func = hookFilter(lineText, func);
    });
    return func;
  };
  linestylefilter$1.populateDomLine = (textLine, aline, apool, domLineObj) => {
    let text = textLine;
    if (text.slice(-1) === "\n") {
      text = text.substring(0, text.length - 1);
    }
    const textAndClassFunc = (tokenText, tokenClass) => {
      domLineObj.appendSpan(tokenText, tokenClass);
    };
    let func = linestylefilter$1.getFilterStack(text, textAndClassFunc);
    func = linestylefilter$1.getLineStyleFilter(text.length, aline, func, apool);
    func(text, "");
  };
  linestylefilter.linestylefilter = linestylefilter$1;
  return linestylefilter;
}
var hasRequiredDomline;
function requireDomline() {
  if (hasRequiredDomline)
    return domline;
  hasRequiredDomline = 1;
  const Security = requireSecurity();
  const hooks$1 = hooks;
  const _2 = requireUnderscore();
  const lineAttributeMarker = requireLinestylefilter().lineAttributeMarker;
  const noop2 = () => {
  };
  const domline$1 = {};
  domline$1.addToLineClass = (lineClass, cls) => {
    cls.replace(/\S+/g, (c) => {
      if (c.indexOf("line:") === 0) {
        lineClass = (lineClass ? `${lineClass} ` : "") + c.substring(5);
      }
    });
    return lineClass;
  };
  domline$1.createDomLine = (nonEmpty, doesWrap, optBrowser, optDocument) => {
    const result2 = {
      node: null,
      appendSpan: noop2,
      prepareForAdd: noop2,
      notifyAdded: noop2,
      clearSpans: noop2,
      finishUpdate: noop2,
      lineMarker: 0
    };
    const document2 = optDocument;
    if (document2) {
      result2.node = document2.createElement("div");
      result2.node.setAttribute("aria-live", "assertive");
    } else {
      result2.node = {
        innerHTML: "",
        className: ""
      };
    }
    let html = [];
    let preHtml = "";
    let postHtml = "";
    let curHTML = null;
    const processSpaces = (s) => domline$1.processSpaces(s, doesWrap);
    const perTextNodeProcess = doesWrap ? _2.identity : processSpaces;
    const perHtmlLineProcess = doesWrap ? processSpaces : _2.identity;
    let lineClass = "ace-line";
    result2.appendSpan = (txt, cls) => {
      let processedMarker = false;
      if (cls.indexOf(lineAttributeMarker) >= 0) {
        let listType = /(?:^| )list:(\S+)/.exec(cls);
        const start = /(?:^| )start:(\S+)/.exec(cls);
        _2.map(hooks$1.callAll("aceDomLinePreProcessLineAttributes", {
          domline: domline$1,
          cls
        }), (modifier) => {
          preHtml += modifier.preHtml;
          postHtml += modifier.postHtml;
          processedMarker |= modifier.processedMarker;
        });
        if (listType) {
          listType = listType[1];
          if (listType) {
            if (listType.indexOf("number") < 0) {
              preHtml += `<ul class="list-${Security.escapeHTMLAttribute(listType)}"><li>`;
              postHtml = `</li></ul>${postHtml}`;
            } else {
              if (start) {
                if (Number.parseInt(start[1]) === 1) {
                  lineClass = `${lineClass} list-start-${listType}`;
                }
                preHtml += `<ol start=${start[1]} class="list-${Security.escapeHTMLAttribute(listType)}"><li>`;
              } else {
                preHtml += `<ol class="list-${Security.escapeHTMLAttribute(listType)}"><li>`;
              }
              postHtml += "</li></ol>";
            }
          }
          processedMarker = true;
        }
        _2.map(hooks$1.callAll("aceDomLineProcessLineAttributes", {
          domline: domline$1,
          cls
        }), (modifier) => {
          preHtml += modifier.preHtml;
          postHtml += modifier.postHtml;
          processedMarker |= modifier.processedMarker;
        });
        if (processedMarker) {
          result2.lineMarker += txt.length;
          return;
        }
      }
      let href = null;
      let simpleTags = null;
      if (cls.indexOf("url") >= 0) {
        cls = cls.replace(/(^| )url:(\S+)/g, (x0, space, url2) => {
          href = url2;
          return `${space}url`;
        });
      }
      if (cls.indexOf("tag") >= 0) {
        cls = cls.replace(/(^| )tag:(\S+)/g, (x0, space, tag) => {
          if (!simpleTags)
            simpleTags = [];
          simpleTags.push(tag.toLowerCase());
          return space + tag;
        });
      }
      let extraOpenTags = "";
      let extraCloseTags = "";
      _2.map(hooks$1.callAll("aceCreateDomLine", {
        domline: domline$1,
        cls
      }), (modifier) => {
        cls = modifier.cls;
        extraOpenTags += modifier.extraOpenTags;
        extraCloseTags = modifier.extraCloseTags + extraCloseTags;
      });
      if (!txt && cls) {
        lineClass = domline$1.addToLineClass(lineClass, cls);
      } else if (txt) {
        if (href) {
          const urn_schemes = new RegExp("^(about|geo|mailto|tel):");
          if (!~href.indexOf("://") && !urn_schemes.test(href)) {
            href = `http://${href}`;
          }
          const escapedHref = Security.escapeHTMLAttribute(href);
          extraOpenTags = `${extraOpenTags}<a href="${escapedHref}" rel="noreferrer noopener">`;
          extraCloseTags = `</a>${extraCloseTags}`;
        }
        if (simpleTags) {
          simpleTags.sort();
          extraOpenTags = `${extraOpenTags}<${simpleTags.join("><")}>`;
          simpleTags.reverse();
          extraCloseTags = `</${simpleTags.join("></")}>${extraCloseTags}`;
        }
        html.push(
          '<span class="',
          Security.escapeHTMLAttribute(cls || ""),
          '">',
          extraOpenTags,
          perTextNodeProcess(Security.escapeHTML(txt)),
          extraCloseTags,
          "</span>"
        );
      }
    };
    result2.clearSpans = () => {
      html = [];
      lineClass = "ace-line";
      result2.lineMarker = 0;
    };
    const writeHTML = () => {
      let newHTML = perHtmlLineProcess(html.join(""));
      if (!newHTML) {
        if (!document2 || !optBrowser) {
          newHTML += "&nbsp;";
        } else {
          newHTML += "<br/>";
        }
      }
      if (nonEmpty) {
        newHTML = (preHtml || "") + newHTML + (postHtml || "");
      }
      html = preHtml = postHtml = "";
      if (newHTML !== curHTML) {
        curHTML = newHTML;
        result2.node.innerHTML = curHTML;
      }
      if (lineClass != null)
        result2.node.className = lineClass;
      hooks$1.callAll("acePostWriteDomLineHTML", {
        node: result2.node
      });
    };
    result2.prepareForAdd = writeHTML;
    result2.finishUpdate = writeHTML;
    return result2;
  };
  domline$1.processSpaces = (s, doesWrap) => {
    if (s.indexOf("<") < 0 && !doesWrap) {
      return s.replace(/ /g, "&nbsp;");
    }
    const parts = [];
    s.replace(/<[^>]*>?| |[^ <]+/g, (m) => {
      parts.push(m);
    });
    if (doesWrap) {
      let endOfLine = true;
      let beforeSpace = false;
      for (let i = parts.length - 1; i >= 0; i--) {
        const p = parts[i];
        if (p === " ") {
          if (endOfLine || beforeSpace)
            parts[i] = "&nbsp;";
          endOfLine = false;
          beforeSpace = true;
        } else if (p.charAt(0) !== "<") {
          endOfLine = false;
          beforeSpace = false;
        }
      }
      for (let i = 0; i < parts.length; i++) {
        const p = parts[i];
        if (p === " ") {
          parts[i] = "&nbsp;";
          break;
        } else if (p.charAt(0) !== "<") {
          break;
        }
      }
    } else {
      for (let i = 0; i < parts.length; i++) {
        const p = parts[i];
        if (p === " ") {
          parts[i] = "&nbsp;";
        }
      }
    }
    return parts.join("");
  };
  domline.domline = domline$1;
  return domline;
}
var skiplist;
var hasRequiredSkiplist;
function requireSkiplist() {
  if (hasRequiredSkiplist)
    return skiplist;
  hasRequiredSkiplist = 1;
  const _entryWidth = (e) => e && e.width || 0;
  class Node {
    constructor(entry, levels = 0, downSkips = 1, downSkipWidths = 0) {
      this.key = entry != null ? entry.key : null;
      this.entry = entry;
      this.levels = levels;
      this.upPtrs = Array(levels).fill(null);
      this.downPtrs = Array(levels).fill(null);
      this.downSkips = Array(levels).fill(downSkips);
      this.downSkipWidths = Array(levels).fill(downSkipWidths);
    }
    propagateWidthChange() {
      const oldWidth = this.downSkipWidths[0];
      const newWidth = _entryWidth(this.entry);
      const widthChange = newWidth - oldWidth;
      let n = this;
      let lvl = 0;
      while (lvl < n.levels) {
        n.downSkipWidths[lvl] += widthChange;
        lvl++;
        while (lvl >= n.levels && n.upPtrs[lvl - 1]) {
          n = n.upPtrs[lvl - 1];
        }
      }
      return widthChange;
    }
  }
  class Point {
    constructor(skipList, loc) {
      this._skipList = skipList;
      this.loc = loc;
      const numLevels = this._skipList._start.levels;
      let lvl = numLevels - 1;
      let i = -1;
      let ws = 0;
      const nodes = new Array(numLevels);
      const idxs = new Array(numLevels);
      const widthSkips = new Array(numLevels);
      nodes[lvl] = this._skipList._start;
      idxs[lvl] = -1;
      widthSkips[lvl] = 0;
      while (lvl >= 0) {
        let n = nodes[lvl];
        while (n.downPtrs[lvl] && i + n.downSkips[lvl] < this.loc) {
          i += n.downSkips[lvl];
          ws += n.downSkipWidths[lvl];
          n = n.downPtrs[lvl];
        }
        nodes[lvl] = n;
        idxs[lvl] = i;
        widthSkips[lvl] = ws;
        lvl--;
        if (lvl >= 0) {
          nodes[lvl] = n;
        }
      }
      this.idxs = idxs;
      this.nodes = nodes;
      this.widthSkips = widthSkips;
    }
    toString() {
      return `Point(${this.loc})`;
    }
    insert(entry) {
      if (entry.key == null)
        throw new Error("entry.key must not be null");
      if (this._skipList.containsKey(entry.key)) {
        throw new Error(`an entry with key ${entry.key} already exists`);
      }
      const newNode = new Node(entry);
      const pNodes = this.nodes;
      const pIdxs = this.idxs;
      const pLoc = this.loc;
      const widthLoc = this.widthSkips[0] + this.nodes[0].downSkipWidths[0];
      const newWidth = _entryWidth(entry);
      while (newNode.levels === 0 || Math.random() < 0.01) {
        const lvl = newNode.levels;
        newNode.levels++;
        if (lvl === pNodes.length) {
          pNodes[lvl] = this._skipList._start;
          pIdxs[lvl] = -1;
          this._skipList._start.levels++;
          this._skipList._end.levels++;
          this._skipList._start.downPtrs[lvl] = this._skipList._end;
          this._skipList._end.upPtrs[lvl] = this._skipList._start;
          this._skipList._start.downSkips[lvl] = this._skipList._keyToNodeMap.size + 1;
          this._skipList._start.downSkipWidths[lvl] = this._skipList._totalWidth;
          this.widthSkips[lvl] = 0;
        }
        const me = newNode;
        const up = pNodes[lvl];
        const down = up.downPtrs[lvl];
        const skip1 = pLoc - pIdxs[lvl];
        const skip2 = up.downSkips[lvl] + 1 - skip1;
        up.downSkips[lvl] = skip1;
        up.downPtrs[lvl] = me;
        me.downSkips[lvl] = skip2;
        me.upPtrs[lvl] = up;
        me.downPtrs[lvl] = down;
        down.upPtrs[lvl] = me;
        const widthSkip1 = widthLoc - this.widthSkips[lvl];
        const widthSkip2 = up.downSkipWidths[lvl] + newWidth - widthSkip1;
        up.downSkipWidths[lvl] = widthSkip1;
        me.downSkipWidths[lvl] = widthSkip2;
      }
      for (let lvl = newNode.levels; lvl < pNodes.length; lvl++) {
        const up = pNodes[lvl];
        up.downSkips[lvl]++;
        up.downSkipWidths[lvl] += newWidth;
      }
      this._skipList._keyToNodeMap.set(newNode.key, newNode);
      this._skipList._totalWidth += newWidth;
    }
    delete() {
      const elem = this.nodes[0].downPtrs[0];
      const elemWidth = _entryWidth(elem.entry);
      for (let i = 0; i < this.nodes.length; i++) {
        if (i < elem.levels) {
          const up = elem.upPtrs[i];
          const down = elem.downPtrs[i];
          const totalSkip = up.downSkips[i] + elem.downSkips[i] - 1;
          up.downPtrs[i] = down;
          down.upPtrs[i] = up;
          up.downSkips[i] = totalSkip;
          const totalWidthSkip = up.downSkipWidths[i] + elem.downSkipWidths[i] - elemWidth;
          up.downSkipWidths[i] = totalWidthSkip;
        } else {
          const up = this.nodes[i];
          up.downSkips[i]--;
          up.downSkipWidths[i] -= elemWidth;
        }
      }
      this._skipList._keyToNodeMap.delete(elem.key);
      this._skipList._totalWidth -= elemWidth;
    }
    getNode() {
      return this.nodes[0].downPtrs[0];
    }
  }
  class SkipList {
    constructor() {
      this._start = new Node(null, 1);
      this._end = new Node(null, 1, null, null);
      this._totalWidth = 0;
      this._keyToNodeMap = /* @__PURE__ */ new Map();
      this._start.downPtrs[0] = this._end;
      this._end.upPtrs[0] = this._start;
    }
    _getNodeAtOffset(targetOffset) {
      let i = 0;
      let n = this._start;
      let lvl = this._start.levels - 1;
      while (lvl >= 0 && n.downPtrs[lvl]) {
        while (n.downPtrs[lvl] && i + n.downSkipWidths[lvl] <= targetOffset) {
          i += n.downSkipWidths[lvl];
          n = n.downPtrs[lvl];
        }
        lvl--;
      }
      if (n === this._start)
        return this._start.downPtrs[0] || null;
      if (n === this._end) {
        return targetOffset === this._totalWidth ? this._end.upPtrs[0] || null : null;
      }
      return n;
    }
    _getNodeIndex(node, byWidth) {
      let dist = byWidth ? 0 : -1;
      let n = node;
      while (n !== this._start) {
        const lvl = n.levels - 1;
        n = n.upPtrs[lvl];
        if (byWidth)
          dist += n.downSkipWidths[lvl];
        else
          dist += n.downSkips[lvl];
      }
      return dist;
    }
    // Returns index of first entry such that entryFunc(entry) is truthy,
    // or length() if no such entry.  Assumes all falsy entries come before
    // all truthy entries.
    search(entryFunc) {
      let low = this._start;
      let lvl = this._start.levels - 1;
      let lowIndex = -1;
      const f = (node) => {
        if (node === this._start)
          return false;
        else if (node === this._end)
          return true;
        else
          return entryFunc(node.entry);
      };
      while (lvl >= 0) {
        let nextLow = low.downPtrs[lvl];
        while (!f(nextLow)) {
          lowIndex += low.downSkips[lvl];
          low = nextLow;
          nextLow = low.downPtrs[lvl];
        }
        lvl--;
      }
      return lowIndex + 1;
    }
    length() {
      return this._keyToNodeMap.size;
    }
    atIndex(i) {
      if (i < 0)
        console.warn(`atIndex(${i})`);
      if (i >= this._keyToNodeMap.size)
        console.warn(`atIndex(${i}>=${this._keyToNodeMap.size})`);
      return new Point(this, i).getNode().entry;
    }
    // differs from Array.splice() in that new elements are in an array, not varargs
    splice(start, deleteCount, newEntryArray) {
      if (start < 0)
        console.warn(`splice(${start}, ...)`);
      if (start + deleteCount > this._keyToNodeMap.size) {
        console.warn(`splice(${start}, ${deleteCount}, ...), N=${this._keyToNodeMap.size}`);
        console.warn("%s %s %s", typeof start, typeof deleteCount, typeof this._keyToNodeMap.size);
        console.trace();
      }
      if (!newEntryArray)
        newEntryArray = [];
      const pt = new Point(this, start);
      for (let i = 0; i < deleteCount; i++)
        pt.delete();
      for (let i = newEntryArray.length - 1; i >= 0; i--) {
        const entry = newEntryArray[i];
        pt.insert(entry);
      }
    }
    next(entry) {
      return this._keyToNodeMap.get(entry.key).downPtrs[0].entry || null;
    }
    prev(entry) {
      return this._keyToNodeMap.get(entry.key).upPtrs[0].entry || null;
    }
    push(entry) {
      this.splice(this._keyToNodeMap.size, 0, [entry]);
    }
    slice(start, end) {
      if (start === void 0)
        start = 0;
      else if (start < 0)
        start += this._keyToNodeMap.size;
      if (end === void 0)
        end = this._keyToNodeMap.size;
      else if (end < 0)
        end += this._keyToNodeMap.size;
      if (start < 0)
        start = 0;
      if (start > this._keyToNodeMap.size)
        start = this._keyToNodeMap.size;
      if (end < 0)
        end = 0;
      if (end > this._keyToNodeMap.size)
        end = this._keyToNodeMap.size;
      if (end <= start)
        return [];
      let n = this.atIndex(start);
      const array = [n];
      for (let i = 1; i < end - start; i++) {
        n = this.next(n);
        array.push(n);
      }
      return array;
    }
    atKey(key) {
      return this._keyToNodeMap.get(key).entry;
    }
    indexOfKey(key) {
      return this._getNodeIndex(this._keyToNodeMap.get(key));
    }
    indexOfEntry(entry) {
      return this.indexOfKey(entry.key);
    }
    containsKey(key) {
      return this._keyToNodeMap.has(key);
    }
    // gets the last entry starting at or before the offset
    atOffset(offset) {
      return this._getNodeAtOffset(offset).entry;
    }
    keyAtOffset(offset) {
      return this.atOffset(offset).key;
    }
    offsetOfKey(key) {
      return this._getNodeIndex(this._keyToNodeMap.get(key), true);
    }
    offsetOfEntry(entry) {
      return this.offsetOfKey(entry.key);
    }
    setEntryWidth(entry, width) {
      entry.width = width;
      this._totalWidth += this._keyToNodeMap.get(entry.key).propagateWidthChange();
    }
    totalWidth() {
      return this._totalWidth;
    }
    offsetOfIndex(i) {
      if (i < 0)
        return 0;
      if (i >= this._keyToNodeMap.size)
        return this._totalWidth;
      return this.offsetOfEntry(this.atIndex(i));
    }
    indexOfOffset(offset) {
      if (offset <= 0)
        return 0;
      if (offset >= this._totalWidth)
        return this._keyToNodeMap.size;
      return this.indexOfEntry(this.atOffset(offset));
    }
  }
  skiplist = SkipList;
  return skiplist;
}
var undomodule = {};
var hasRequiredUndomodule;
function requireUndomodule() {
  if (hasRequiredUndomodule)
    return undomodule;
  hasRequiredUndomodule = 1;
  const Changeset2 = requireChangeset();
  const _2 = requireUnderscore();
  const undoModule = (() => {
    const stack = (() => {
      const stackElements = [];
      let numUndoableEvents = 0;
      const UNDOABLE_EVENT = "undoableEvent";
      const EXTERNAL_CHANGE = "externalChange";
      const clearStack = () => {
        stackElements.length = 0;
        stackElements.push(
          {
            elementType: UNDOABLE_EVENT,
            eventType: "bottom"
          }
        );
        numUndoableEvents = 1;
      };
      clearStack();
      const pushEvent = (event) => {
        const e = _2.extend(
          {},
          event
        );
        e.elementType = UNDOABLE_EVENT;
        stackElements.push(e);
        numUndoableEvents++;
      };
      const pushExternalChange = (cs) => {
        const idx = stackElements.length - 1;
        if (stackElements[idx].elementType === EXTERNAL_CHANGE) {
          stackElements[idx].changeset = Changeset2.compose(stackElements[idx].changeset, cs, getAPool());
        } else {
          stackElements.push(
            {
              elementType: EXTERNAL_CHANGE,
              changeset: cs
            }
          );
        }
      };
      const _exposeEvent = (nthFromTop) => {
        const targetIndex = stackElements.length - 1 - nthFromTop;
        let idx = stackElements.length - 1;
        while (idx > targetIndex || stackElements[idx].elementType === EXTERNAL_CHANGE) {
          if (stackElements[idx].elementType === EXTERNAL_CHANGE) {
            const ex = stackElements[idx];
            const un = stackElements[idx - 1];
            if (un.backset) {
              const excs = ex.changeset;
              const unbs = un.backset;
              un.backset = Changeset2.follow(excs, un.backset, false, getAPool());
              ex.changeset = Changeset2.follow(unbs, ex.changeset, true, getAPool());
              if (typeof un.selStart === "number") {
                const newSel = Changeset2.characterRangeFollow(excs, un.selStart, un.selEnd);
                un.selStart = newSel[0];
                un.selEnd = newSel[1];
                if (un.selStart === un.selEnd) {
                  un.selFocusAtStart = false;
                }
              }
            }
            stackElements[idx - 1] = ex;
            stackElements[idx] = un;
            if (idx >= 2 && stackElements[idx - 2].elementType === EXTERNAL_CHANGE) {
              ex.changeset = Changeset2.compose(stackElements[idx - 2].changeset, ex.changeset, getAPool());
              stackElements.splice(idx - 2, 1);
              idx--;
            }
          } else {
            idx--;
          }
        }
      };
      const getNthFromTop = (n) => {
        _exposeEvent(n);
        return stackElements[stackElements.length - 1 - n];
      };
      const numEvents = () => numUndoableEvents;
      const popEvent = () => {
        _exposeEvent(0);
        numUndoableEvents--;
        return stackElements.pop();
      };
      return {
        numEvents,
        popEvent,
        pushEvent,
        pushExternalChange,
        clearStack,
        getNthFromTop
      };
    })();
    let undoPtr = 0;
    const clearHistory = () => {
      stack.clearStack();
      undoPtr = 0;
    };
    const _charOccurrences = (str, c) => {
      let i = 0;
      let count = 0;
      while (i >= 0 && i < str.length) {
        i = str.indexOf(c, i);
        if (i >= 0) {
          count++;
          i++;
        }
      }
      return count;
    };
    const _opcodeOccurrences = (cs, opcode) => _charOccurrences(Changeset2.unpack(cs).ops, opcode);
    const _mergeChangesets = (cs1, cs2) => {
      if (!cs1)
        return cs2;
      if (!cs2)
        return cs1;
      const plusCount1 = _opcodeOccurrences(cs1, "+");
      const plusCount2 = _opcodeOccurrences(cs2, "+");
      const minusCount1 = _opcodeOccurrences(cs1, "-");
      const minusCount2 = _opcodeOccurrences(cs2, "-");
      if (plusCount1 === 1 && plusCount2 === 1 && minusCount1 === 0 && minusCount2 === 0) {
        const merge = Changeset2.compose(cs1, cs2, getAPool());
        const plusCount3 = _opcodeOccurrences(merge, "+");
        const minusCount3 = _opcodeOccurrences(merge, "-");
        if (plusCount3 === 1 && minusCount3 === 0) {
          return merge;
        }
      } else if (plusCount1 === 0 && plusCount2 === 0 && minusCount1 === 1 && minusCount2 === 1) {
        const merge = Changeset2.compose(cs1, cs2, getAPool());
        const plusCount3 = _opcodeOccurrences(merge, "+");
        const minusCount3 = _opcodeOccurrences(merge, "-");
        if (plusCount3 === 0 && minusCount3 === 1) {
          return merge;
        }
      }
      return null;
    };
    const reportEvent = (event) => {
      const topEvent = stack.getNthFromTop(0);
      const applySelectionToTop = () => {
        if (typeof event.selStart === "number") {
          topEvent.selStart = event.selStart;
          topEvent.selEnd = event.selEnd;
          topEvent.selFocusAtStart = event.selFocusAtStart;
        }
      };
      if (!event.backset || Changeset2.isIdentity(event.backset)) {
        applySelectionToTop();
      } else {
        let merged = false;
        if (topEvent.eventType === event.eventType) {
          const merge = _mergeChangesets(event.backset, topEvent.backset);
          if (merge) {
            topEvent.backset = merge;
            applySelectionToTop();
            merged = true;
          }
        }
        if (!merged) {
          if (event && event.eventType !== "clearauthorship") {
            stack.pushEvent(event);
          }
        }
        undoPtr = 0;
      }
    };
    const reportExternalChange = (changeset) => {
      if (changeset && !Changeset2.isIdentity(changeset)) {
        stack.pushExternalChange(changeset);
      }
    };
    const _getSelectionInfo = (event) => {
      if (typeof event.selStart !== "number") {
        return null;
      } else {
        return {
          selStart: event.selStart,
          selEnd: event.selEnd,
          selFocusAtStart: event.selFocusAtStart
        };
      }
    };
    const performUndo = (eventFunc) => {
      if (undoPtr < stack.numEvents() - 1) {
        const backsetEvent = stack.getNthFromTop(undoPtr);
        const selectionEvent = stack.getNthFromTop(undoPtr + 1);
        const undoEvent = eventFunc(backsetEvent.backset, _getSelectionInfo(selectionEvent));
        stack.pushEvent(undoEvent);
        undoPtr += 2;
      } else {
        eventFunc();
      }
    };
    const performRedo = (eventFunc) => {
      if (undoPtr >= 2) {
        const backsetEvent = stack.getNthFromTop(0);
        const selectionEvent = stack.getNthFromTop(1);
        eventFunc(backsetEvent.backset, _getSelectionInfo(selectionEvent));
        stack.popEvent();
        undoPtr -= 2;
      } else {
        eventFunc();
      }
    };
    const getAPool = () => undoModule.apool;
    return {
      clearHistory,
      reportEvent,
      reportExternalChange,
      performUndo,
      performRedo,
      enabled: true,
      apool: null
    };
  })();
  undomodule.undoModule = undoModule;
  return undomodule;
}
var scroll = {};
var caretPosition = {};
var hasRequiredCaretPosition;
function requireCaretPosition() {
  if (hasRequiredCaretPosition)
    return caretPosition;
  hasRequiredCaretPosition = 1;
  caretPosition.getPosition = () => {
    const range2 = getSelectionRange();
    if (!range2 || $(range2.endContainer).closest("body")[0].id !== "innerdocbody")
      return null;
    const clonedRange = createSelectionRange(range2);
    const shadowCaret = $(document.createTextNode("|"));
    clonedRange.insertNode(shadowCaret[0]);
    clonedRange.selectNode(shadowCaret[0]);
    const line = getPositionOfElementOrSelection(clonedRange);
    shadowCaret.remove();
    return line;
  };
  const createSelectionRange = (range2) => {
    const clonedRange = range2.cloneRange();
    clonedRange.setStart(range2.endContainer, range2.endOffset);
    clonedRange.setEnd(range2.endContainer, range2.endOffset);
    return clonedRange;
  };
  const getPositionOfRepLineAtOffset = (node, offset) => {
    if (node.tagName === "BR" || node.tagName === "EMPTY") {
      return getPositionOfElementOrSelection(node);
    }
    while (node.length === 0 && node.nextSibling) {
      node = node.nextSibling;
    }
    const newRange = new Range();
    newRange.setStart(node, offset);
    newRange.setEnd(node, offset);
    const linePosition = getPositionOfElementOrSelection(newRange);
    newRange.detach();
    return linePosition;
  };
  const getPositionOfElementOrSelection = (element) => {
    const rect = element.getBoundingClientRect();
    const linePosition = {
      bottom: rect.bottom,
      height: rect.height,
      top: rect.top
    };
    return linePosition;
  };
  caretPosition.getPositionTopOfPreviousBrowserLine = (caretLinePosition, rep) => {
    let previousLineTop = caretLinePosition.top - caretLinePosition.height;
    const isCaretLineFirstBrowserLine = caretLineIsFirstBrowserLine(caretLinePosition.top, rep);
    if (isCaretLineFirstBrowserLine) {
      const lineBeforeCaretLine = rep.selStart[0] - 1;
      const firstLineVisibleBeforeCaretLine = getPreviousVisibleLine(lineBeforeCaretLine, rep);
      const linePosition = getDimensionOfLastBrowserLineOfRepLine(firstLineVisibleBeforeCaretLine, rep);
      previousLineTop = linePosition.top;
    }
    return previousLineTop;
  };
  const caretLineIsFirstBrowserLine = (caretLineTop, rep) => {
    const caretRepLine = rep.selStart[0];
    const lineNode = rep.lines.atIndex(caretRepLine).lineNode;
    const firstRootNode = getFirstRootChildNode(lineNode);
    const positionOfFirstRootNode = getPositionOfRepLineAtOffset(firstRootNode, 1);
    return positionOfFirstRootNode.top === caretLineTop;
  };
  const getFirstRootChildNode = (node) => {
    if (!node.firstChild) {
      return node;
    } else {
      return getFirstRootChildNode(node.firstChild);
    }
  };
  const getDimensionOfLastBrowserLineOfRepLine = (line, rep) => {
    const lineNode = rep.lines.atIndex(line).lineNode;
    const lastRootChildNode = getLastRootChildNode(lineNode);
    const lastRootChildNodePosition = getPositionOfRepLineAtOffset(lastRootChildNode.node, lastRootChildNode.length);
    return lastRootChildNodePosition;
  };
  const getLastRootChildNode = (node) => {
    if (!node.lastChild) {
      return {
        node,
        length: node.length
      };
    } else {
      return getLastRootChildNode(node.lastChild);
    }
  };
  caretPosition.getBottomOfNextBrowserLine = (caretLinePosition, rep) => {
    let nextLineBottom = caretLinePosition.bottom + caretLinePosition.height;
    const isCaretLineLastBrowserLine = caretLineIsLastBrowserLineOfRepLine(caretLinePosition.top, rep);
    if (isCaretLineLastBrowserLine) {
      const nextLineAfterCaretLine = rep.selStart[0] + 1;
      const firstNextLineVisibleAfterCaretLine = getNextVisibleLine(nextLineAfterCaretLine, rep);
      const linePosition = getDimensionOfFirstBrowserLineOfRepLine(firstNextLineVisibleAfterCaretLine, rep);
      nextLineBottom = linePosition.bottom;
    }
    return nextLineBottom;
  };
  const caretLineIsLastBrowserLineOfRepLine = (caretLineTop, rep) => {
    const caretRepLine = rep.selStart[0];
    const lineNode = rep.lines.atIndex(caretRepLine).lineNode;
    const lastRootChildNode = getLastRootChildNode(lineNode);
    const lastRootChildNodePosition = getPositionOfRepLineAtOffset(lastRootChildNode.node, lastRootChildNode.length);
    return lastRootChildNodePosition.top === caretLineTop;
  };
  const getPreviousVisibleLine = (line, rep) => {
    const firstLineOfPad = 0;
    if (line <= firstLineOfPad) {
      return firstLineOfPad;
    } else if (isLineVisible(line, rep)) {
      return line;
    } else {
      return getPreviousVisibleLine(line - 1, rep);
    }
  };
  caretPosition.getPreviousVisibleLine = getPreviousVisibleLine;
  const getNextVisibleLine = (line, rep) => {
    const lastLineOfThePad = rep.lines.length() - 1;
    if (line >= lastLineOfThePad) {
      return lastLineOfThePad;
    } else if (isLineVisible(line, rep)) {
      return line;
    } else {
      return getNextVisibleLine(line + 1, rep);
    }
  };
  caretPosition.getNextVisibleLine = getNextVisibleLine;
  const isLineVisible = (line, rep) => rep.lines.atIndex(line).lineNode.offsetHeight > 0;
  const getDimensionOfFirstBrowserLineOfRepLine = (line, rep) => {
    const lineNode = rep.lines.atIndex(line).lineNode;
    const firstRootChildNode = getFirstRootChildNode(lineNode);
    const firstRootChildNodePosition = getPositionOfRepLineAtOffset(firstRootChildNode, 1);
    return firstRootChildNodePosition;
  };
  const getSelectionRange = () => {
    if (!window.getSelection) {
      return;
    }
    const selection = window.getSelection();
    if (selection && selection.type !== "None" && selection.rangeCount > 0) {
      return selection.getRangeAt(0);
    } else {
      return null;
    }
  };
  return caretPosition;
}
var hasRequiredScroll;
function requireScroll() {
  if (hasRequiredScroll)
    return scroll;
  hasRequiredScroll = 1;
  const caretPosition2 = requireCaretPosition();
  function Scroll(outerWin) {
    this.scrollSettings = parent.parent.clientVars.scrollWhenFocusLineIsOutOfViewport;
    this.outerWin = outerWin;
    this.doc = this.outerWin.contentDocument;
    this.rootDocument = parent.parent.document;
  }
  Scroll.prototype.scrollWhenCaretIsInTheLastLineOfViewportWhenNecessary = function(rep, isScrollableEvent, innerHeight) {
    const shouldScrollWhenCaretIsAtBottomOfViewport = this.scrollSettings.scrollWhenCaretIsInTheLastLineOfViewport;
    if (shouldScrollWhenCaretIsAtBottomOfViewport) {
      const multipleLinesSelected = rep.selStart[0] !== rep.selEnd[0];
      if (isScrollableEvent && !multipleLinesSelected && this._isCaretAtTheBottomOfViewport(rep)) {
        const pixelsToScroll = this._getPixelsRelativeToPercentageOfViewport(innerHeight);
        this._scrollYPage(pixelsToScroll);
      }
    }
  };
  Scroll.prototype.scrollWhenPressArrowKeys = function(arrowUp, rep, innerHeight) {
    if (this._arrowUpWasPressedInTheFirstLineOfTheViewport(arrowUp, rep)) {
      const pixelsToScroll = this._getPixelsToScrollWhenUserPressesArrowUp(innerHeight);
      this._scrollYPageWithoutAnimation(-pixelsToScroll);
    } else {
      this.scrollNodeVerticallyIntoView(rep, innerHeight);
    }
  };
  Scroll.prototype._isCaretAtTheBottomOfViewport = function(rep) {
    const caretLine = rep.selStart[0];
    const lineAfterCaretLine = caretLine + 1;
    const firstLineVisibleAfterCaretLine = caretPosition2.getNextVisibleLine(lineAfterCaretLine, rep);
    const caretLineIsPartiallyVisibleOnViewport = this._isLinePartiallyVisibleOnViewport(caretLine, rep);
    const lineAfterCaretLineIsPartiallyVisibleOnViewport = this._isLinePartiallyVisibleOnViewport(firstLineVisibleAfterCaretLine, rep);
    if (caretLineIsPartiallyVisibleOnViewport || lineAfterCaretLineIsPartiallyVisibleOnViewport) {
      const caretLinePosition = caretPosition2.getPosition();
      const viewportBottom = this._getViewPortTopBottom().bottom;
      const nextLineBottom = caretPosition2.getBottomOfNextBrowserLine(caretLinePosition, rep);
      const nextLineIsBelowViewportBottom = nextLineBottom > viewportBottom;
      return nextLineIsBelowViewportBottom;
    }
    return false;
  };
  Scroll.prototype._isLinePartiallyVisibleOnViewport = function(lineNumber, rep) {
    const lineNode = rep.lines.atIndex(lineNumber);
    const linePosition = this._getLineEntryTopBottom(lineNode);
    const lineTop = linePosition.top;
    const lineBottom = linePosition.bottom;
    const viewport = this._getViewPortTopBottom();
    const viewportBottom = viewport.bottom;
    const viewportTop = viewport.top;
    const topOfLineIsAboveOfViewportBottom = lineTop < viewportBottom;
    const bottomOfLineIsOnOrBelowOfViewportBottom = lineBottom >= viewportBottom;
    const topOfLineIsBelowViewportTop = lineTop >= viewportTop;
    const topOfLineIsAboveViewportBottom = lineTop <= viewportBottom;
    const bottomOfLineIsAboveViewportBottom = lineBottom <= viewportBottom;
    const bottomOfLineIsBelowViewportTop = lineBottom >= viewportTop;
    return topOfLineIsAboveOfViewportBottom && bottomOfLineIsOnOrBelowOfViewportBottom || topOfLineIsBelowViewportTop && topOfLineIsAboveViewportBottom || bottomOfLineIsAboveViewportBottom && bottomOfLineIsBelowViewportTop;
  };
  Scroll.prototype._getViewPortTopBottom = function() {
    const theTop = this.getScrollY();
    const doc = this.doc;
    const height = doc.documentElement.clientHeight;
    const viewportExtraSpacesAndPosition = this._getEditorPositionTop() + this._getPaddingTopAddedWhenPageViewIsEnable();
    return {
      top: theTop,
      bottom: theTop + height - viewportExtraSpacesAndPosition
    };
  };
  Scroll.prototype._getEditorPositionTop = function() {
    const editor = parent.document.getElementsByTagName("iframe");
    const editorPositionTop = editor[0].offsetTop;
    return editorPositionTop;
  };
  Scroll.prototype._getPaddingTopAddedWhenPageViewIsEnable = function() {
    const aceOuter = this.rootDocument.getElementsByName("ace_outer");
    const aceOuterPaddingTop = parseInt($(aceOuter).css("padding-top"));
    return aceOuterPaddingTop;
  };
  Scroll.prototype._getScrollXY = function() {
    const win = this.outerWin;
    const odoc = this.doc;
    if (typeof win.pageYOffset === "number") {
      return {
        x: win.pageXOffset,
        y: win.pageYOffset
      };
    }
    const docel = odoc.documentElement;
    if (docel && typeof docel.scrollTop === "number") {
      return {
        x: docel.scrollLeft,
        y: docel.scrollTop
      };
    }
  };
  Scroll.prototype.getScrollX = function() {
    return this._getScrollXY().x;
  };
  Scroll.prototype.getScrollY = function() {
    return this._getScrollXY().y;
  };
  Scroll.prototype.setScrollX = function(x) {
    this.outerWin.scrollTo(x, this.getScrollY());
  };
  Scroll.prototype.setScrollY = function(y) {
    this.outerWin.scrollTo(this.getScrollX(), y);
  };
  Scroll.prototype.setScrollXY = function(x, y) {
    this.outerWin.scrollTo(x, y);
  };
  Scroll.prototype._isCaretAtTheTopOfViewport = function(rep) {
    const caretLine = rep.selStart[0];
    const linePrevCaretLine = caretLine - 1;
    const firstLineVisibleBeforeCaretLine = caretPosition2.getPreviousVisibleLine(linePrevCaretLine, rep);
    const caretLineIsPartiallyVisibleOnViewport = this._isLinePartiallyVisibleOnViewport(caretLine, rep);
    const lineBeforeCaretLineIsPartiallyVisibleOnViewport = this._isLinePartiallyVisibleOnViewport(firstLineVisibleBeforeCaretLine, rep);
    if (caretLineIsPartiallyVisibleOnViewport || lineBeforeCaretLineIsPartiallyVisibleOnViewport) {
      const caretLinePosition = caretPosition2.getPosition();
      const viewportPosition = this._getViewPortTopBottom();
      const viewportTop = viewportPosition.top;
      const viewportBottom = viewportPosition.bottom;
      const caretLineIsBelowViewportTop = caretLinePosition.bottom >= viewportTop;
      const caretLineIsAboveViewportBottom = caretLinePosition.top < viewportBottom;
      const caretLineIsInsideOfViewport = caretLineIsBelowViewportTop && caretLineIsAboveViewportBottom;
      if (caretLineIsInsideOfViewport) {
        const prevLineTop = caretPosition2.getPositionTopOfPreviousBrowserLine(caretLinePosition, rep);
        const previousLineIsAboveViewportTop = prevLineTop < viewportTop;
        return previousLineIsAboveViewportTop;
      }
    }
    return false;
  };
  Scroll.prototype._getPixelsRelativeToPercentageOfViewport = function(innerHeight, aboveOfViewport) {
    let pixels = 0;
    const scrollPercentageRelativeToViewport = this._getPercentageToScroll(aboveOfViewport);
    if (scrollPercentageRelativeToViewport > 0 && scrollPercentageRelativeToViewport <= 1) {
      pixels = parseInt(innerHeight * scrollPercentageRelativeToViewport);
    }
    return pixels;
  };
  Scroll.prototype._getPercentageToScroll = function(aboveOfViewport) {
    let percentageToScroll = this.scrollSettings.percentage.editionBelowViewport;
    if (aboveOfViewport) {
      percentageToScroll = this.scrollSettings.percentage.editionAboveViewport;
    }
    return percentageToScroll;
  };
  Scroll.prototype._getPixelsToScrollWhenUserPressesArrowUp = function(innerHeight) {
    let pixels = 0;
    const percentageToScrollUp = this.scrollSettings.percentageToScrollWhenUserPressesArrowUp;
    if (percentageToScrollUp > 0 && percentageToScrollUp <= 1) {
      pixels = parseInt(innerHeight * percentageToScrollUp);
    }
    return pixels;
  };
  Scroll.prototype._scrollYPage = function(pixelsToScroll) {
    const durationOfAnimationToShowFocusline = this.scrollSettings.duration;
    if (durationOfAnimationToShowFocusline) {
      this._scrollYPageWithAnimation(pixelsToScroll, durationOfAnimationToShowFocusline);
    } else {
      this._scrollYPageWithoutAnimation(pixelsToScroll);
    }
  };
  Scroll.prototype._scrollYPageWithoutAnimation = function(pixelsToScroll) {
    this.outerWin.scrollBy(0, pixelsToScroll);
  };
  Scroll.prototype._scrollYPageWithAnimation = function(pixelsToScroll, durationOfAnimationToShowFocusline) {
    const outerDocBody = this.doc.getElementById("outerdocbody");
    const $outerDocBody = $(outerDocBody);
    this._triggerScrollWithAnimation(
      $outerDocBody,
      pixelsToScroll,
      durationOfAnimationToShowFocusline
    );
    const $outerDocBodyParent = $outerDocBody.parent();
    this._triggerScrollWithAnimation(
      $outerDocBodyParent,
      pixelsToScroll,
      durationOfAnimationToShowFocusline
    );
  };
  Scroll.prototype._triggerScrollWithAnimation = function($elem, pixelsToScroll, durationOfAnimationToShowFocusline) {
    $elem.stop("scrollanimation");
    $elem.animate({
      scrollTop: `+=${pixelsToScroll}`
    }, {
      duration: durationOfAnimationToShowFocusline,
      queue: "scrollanimation"
    }).dequeue("scrollanimation");
  };
  Scroll.prototype.scrollNodeVerticallyIntoView = function(rep, innerHeight) {
    const viewport = this._getViewPortTopBottom();
    const linePosition = caretPosition2.getPosition();
    if (linePosition) {
      const distanceOfTopOfViewport = linePosition.top - viewport.top;
      const distanceOfBottomOfViewport = viewport.bottom - linePosition.bottom - linePosition.height;
      const caretIsAboveOfViewport = distanceOfTopOfViewport < 0;
      const caretIsBelowOfViewport = distanceOfBottomOfViewport < 0;
      if (caretIsAboveOfViewport) {
        const pixelsToScroll = distanceOfTopOfViewport - this._getPixelsRelativeToPercentageOfViewport(innerHeight, true);
        this._scrollYPage(pixelsToScroll);
      } else if (caretIsBelowOfViewport) {
        setTimeout(() => {
          const outer = window.parent;
          outer.scrollTo(0, outer[0].innerHeight);
        }, 150);
      }
    }
  };
  Scroll.prototype._partOfRepLineIsOutOfViewport = function(viewportPosition, rep) {
    const focusLine = rep.selFocusAtStart ? rep.selStart[0] : rep.selEnd[0];
    const line = rep.lines.atIndex(focusLine);
    const linePosition = this._getLineEntryTopBottom(line);
    const lineIsAboveOfViewport = linePosition.top < viewportPosition.top;
    const lineIsBelowOfViewport = linePosition.bottom > viewportPosition.bottom;
    return lineIsBelowOfViewport || lineIsAboveOfViewport;
  };
  Scroll.prototype._getLineEntryTopBottom = function(entry, destObj) {
    const dom = entry.lineNode;
    const top = dom.offsetTop;
    const height = dom.offsetHeight;
    const obj = destObj || {};
    obj.top = top;
    obj.bottom = top + height;
    return obj;
  };
  Scroll.prototype._arrowUpWasPressedInTheFirstLineOfTheViewport = function(arrowUp, rep) {
    const percentageScrollArrowUp = this.scrollSettings.percentageToScrollWhenUserPressesArrowUp;
    return percentageScrollArrowUp && arrowUp && this._isCaretAtTheTopOfViewport(rep);
  };
  Scroll.prototype.getVisibleLineRange = function(rep) {
    const viewport = this._getViewPortTopBottom();
    const obj = {};
    const self2 = this;
    const start = rep.lines.search((e) => self2._getLineEntryTopBottom(e, obj).bottom > viewport.top);
    let end = rep.lines.search((e) => self2._getLineEntryTopBottom(e, obj).top >= viewport.bottom);
    if (end < start)
      end = start;
    return [start, end - 1];
  };
  Scroll.prototype.getVisibleCharRange = function(rep) {
    const lineRange = this.getVisibleLineRange(rep);
    return [rep.lines.offsetOfIndex(lineRange[0]), rep.lines.offsetOfIndex(lineRange[1])];
  };
  scroll.init = (outerWin) => new Scroll(outerWin);
  return scroll;
}
var hasRequiredAce2_inner;
function requireAce2_inner() {
  if (hasRequiredAce2_inner)
    return ace2_inner;
  hasRequiredAce2_inner = 1;
  let documentAttributeManager;
  const AttributeMap = requireAttributeMap();
  const browser2 = browserExports;
  const padutils = requirePad_utils().padutils;
  const Ace2Common = requireAce2_common();
  const $2 = rjquery.$;
  const isNodeText = Ace2Common.isNodeText;
  const getAssoc = Ace2Common.getAssoc;
  const setAssoc = Ace2Common.setAssoc;
  const noop2 = Ace2Common.noop;
  const hooks$1 = hooks;
  function Ace2Inner(editorInfo, cssManagers) {
    const makeChangesetTracker = requireChangesettracker().makeChangesetTracker;
    const colorutils2 = requireColorutils().colorutils;
    const makeContentCollector = requireContentcollector().makeContentCollector;
    const domline2 = requireDomline().domline;
    const AttribPool = requireAttributePool();
    const Changeset2 = requireChangeset();
    const ChangesetUtils2 = requireChangesetUtils();
    const linestylefilter2 = requireLinestylefilter().linestylefilter;
    const SkipList = requireSkiplist();
    const undoModule = requireUndomodule().undoModule;
    const AttributeManager = requireAttributeManager();
    const Scroll = requireScroll();
    const DEBUG = false;
    const THE_TAB = "    ";
    const MAX_LIST_LEVEL = 16;
    const FORMATTING_STYLES = ["bold", "italic", "underline", "strikethrough"];
    const SELECT_BUTTON_CLASS = "selected";
    let thisAuthor = "";
    const outerWin = document.getElementsByName("ace_outer")[0];
    const targetDoc = outerWin.contentWindow.document.getElementsByName("ace_inner")[0].contentWindow.document;
    const targetBody = targetDoc.body;
    let disposed = false;
    const focus = () => {
      window.focus();
    };
    const outerDoc = outerWin.contentWindow.document;
    const sideDiv = outerDoc.getElementById("sidediv");
    const lineMetricsDiv = outerDoc.getElementById("linemetricsdiv");
    const sideDivInner = outerDoc.getElementById("sidedivinner");
    const appendNewSideDivLine = () => {
      const lineDiv = outerDoc.createElement("div");
      sideDivInner.appendChild(lineDiv);
      const lineSpan = outerDoc.createElement("span");
      lineSpan.classList.add("line-number");
      lineSpan.appendChild(outerDoc.createTextNode(sideDivInner.children.length));
      lineDiv.appendChild(lineSpan);
    };
    appendNewSideDivLine();
    const scroll2 = Scroll.init(outerWin);
    let outsideKeyDown = noop2;
    let outsideKeyPress = (e) => true;
    let outsideNotifyDirty = noop2;
    const rep = {
      /**
       * The contents of the document. Each entry in this skip list is an object representing a
       * line (actually paragraph) of text. The line objects are created by createDomLineEntry().
       */
      lines: new SkipList(),
      /**
       * Start of the selection. Represented as an array of two non-negative numbers that point to the
       * first character of the selection: [zeroBasedLineNumber, zeroBasedColumnNumber]. Notes:
       *   - There is an implicit newline character (not actually stored) at the end of every line.
       *     Because of this, a selection that starts at the end of a line (column number equals the
       *     number of characters in the line, not including the implicit newline) is not equivalent
       *     to a selection that starts at the beginning of the next line. The same goes for the
       *     selection end.
       *   - If there are N lines, [N, 0] is valid for the start of the selection. [N, 0] indicates
       *     that the selection starts just after the implicit newline at the end of the document's
       *     last line (if the document has any lines). The same goes for the end of the selection.
       *   - If a line starts with a line marker, a selection that starts at the beginning of the line
       *     may start either immediately before (column = 0) or immediately after (column = 1) the
       *     line marker, and the two are considered to be semantically equivalent. For safety, all
       *     code should be written to accept either but only produce selections that start after the
       *     line marker (the column number should be 1, not 0, when there is a line marker). The same
       *     goes for the end of the selection.
       */
      selStart: null,
      /**
       * End of the selection. Represented as an array of two non-negative numbers that point to the
       * character just after the end of the selection: [zeroBasedLineNumber, zeroBasedColumnNumber].
       * See the above notes for selStart.
       */
      selEnd: null,
      /**
       * Whether the selection extends "backwards", so that the focus point (controlled with the arrow
       * keys) is at the beginning. This is not supported in IE, though native IE selections have that
       * behavior (which we try not to interfere with). Must be false if selection is collapsed!
       */
      selFocusAtStart: false,
      alltext: "",
      alines: [],
      apool: new AttribPool()
    };
    if (undoModule.enabled) {
      undoModule.apool = rep.apool;
    }
    let isEditable = true;
    let doesWrap = true;
    let hasLineNumbers = true;
    let isStyled = true;
    let console2 = DEBUG;
    if (!window.console) {
      const names = [
        "log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "group",
        "groupEnd",
        "time",
        "timeEnd",
        "count",
        "trace",
        "profile",
        "profileEnd"
      ];
      console2 = {};
      for (const name of names)
        console2[name] = noop2;
    }
    const scheduler = parent;
    const performDocumentReplaceRange = (start, end, newText) => {
      if (start === void 0)
        start = rep.selStart;
      if (end === void 0)
        end = rep.selEnd;
      const builder = Changeset2.builder(rep.lines.totalWidth());
      ChangesetUtils2.buildKeepToStartOfRange(rep, builder, start);
      ChangesetUtils2.buildRemoveRange(rep, builder, start, end);
      builder.insert(newText, [
        ["author", thisAuthor]
      ], rep.apool);
      const cs = builder.toString();
      performDocumentApplyChangeset(cs);
    };
    const changesetTracker = makeChangesetTracker(scheduler, rep.apool, {
      withCallbacks: (operationName, f) => {
        inCallStackIfNecessary(operationName, () => {
          fastIncorp();
          f(
            {
              setDocumentAttributedText: (atext) => {
                setDocAText(atext);
              },
              applyChangesetToDocument: (changeset, preferInsertionAfterCaret) => {
                const oldEventType = currentCallStack.editEvent.eventType;
                currentCallStack.startNewEvent("nonundoable");
                performDocumentApplyChangeset(changeset, preferInsertionAfterCaret);
                currentCallStack.startNewEvent(oldEventType);
              }
            }
          );
        });
      }
    });
    const authorInfos = {};
    const getAuthorInfos = () => authorInfos;
    editorInfo.ace_getAuthorInfos = getAuthorInfos;
    const setAuthorStyle = (author, info) => {
      const authorSelector = getAuthorColorClassSelector(getAuthorClassName(author));
      const authorStyleSet = hooks$1.callAll("aceSetAuthorStyle", {
        dynamicCSS: cssManagers.inner,
        outerDynamicCSS: cssManagers.outer,
        parentDynamicCSS: cssManagers.parent,
        info,
        author,
        authorSelector
      });
      if (authorStyleSet.some((it) => it)) {
        return;
      }
      if (!info) {
        cssManagers.inner.removeSelectorStyle(authorSelector);
        cssManagers.parent.removeSelectorStyle(authorSelector);
      } else if (info.bgcolor) {
        let bgcolor = info.bgcolor;
        if (typeof info.fade === "number") {
          bgcolor = fadeColor(bgcolor, info.fade);
        }
        const textColor = colorutils2.textColorFromBackgroundColor(bgcolor, parent.parent.clientVars.skinName);
        const styles = [
          cssManagers.inner.selectorStyle(authorSelector),
          cssManagers.parent.selectorStyle(authorSelector)
        ];
        for (const style of styles) {
          style.backgroundColor = bgcolor;
          style.color = textColor;
          style["padding-top"] = "3px";
          style["padding-bottom"] = "4px";
        }
      }
    };
    const setAuthorInfo = (author, info) => {
      if (!author)
        return;
      if (typeof author !== "string") {
        throw new Error(`setAuthorInfo: author (${author}) is not a string`);
      }
      if (!info) {
        delete authorInfos[author];
      } else {
        authorInfos[author] = info;
      }
      setAuthorStyle(author, info);
    };
    const getAuthorClassName = (author) => `author-${author.replace(/[^a-y0-9]/g, (c) => {
      if (c === ".")
        return "-";
      return `z${c.charCodeAt(0)}z`;
    })}`;
    const className2Author = (className) => {
      if (className.substring(0, 7) === "author-") {
        return className.substring(7).replace(/[a-y0-9]+|-|z.+?z/g, (cc) => {
          if (cc === "-") {
            return ".";
          } else if (cc.charAt(0) === "z") {
            return String.fromCharCode(Number(cc.slice(1, -1)));
          } else {
            return cc;
          }
        });
      }
      return null;
    };
    const getAuthorColorClassSelector = (oneClassName) => `.authorColors .${oneClassName}`;
    const fadeColor = (colorCSS, fadeFrac) => {
      let color = colorutils2.css2triple(colorCSS);
      color = colorutils2.blend(color, [1, 1, 1], fadeFrac);
      return colorutils2.triple2css(color);
    };
    editorInfo.ace_getRep = () => rep;
    editorInfo.ace_getAuthor = () => thisAuthor;
    const _nonScrollableEditEvents = {
      applyChangesToBase: 1
    };
    for (const eventType of hooks$1.callAll("aceRegisterNonScrollableEditEvents")) {
      _nonScrollableEditEvents[eventType] = 1;
    }
    const isScrollableEditEvent = (eventType) => !_nonScrollableEditEvents[eventType];
    let currentCallStack = null;
    const inCallStack = (type, action) => {
      if (disposed)
        return;
      const newEditEvent = (eventType) => ({
        eventType,
        backset: null
      });
      const submitOldEvent = (evt) => {
        if (rep.selStart && rep.selEnd) {
          const selStartChar = rep.lines.offsetOfIndex(rep.selStart[0]) + rep.selStart[1];
          const selEndChar = rep.lines.offsetOfIndex(rep.selEnd[0]) + rep.selEnd[1];
          evt.selStart = selStartChar;
          evt.selEnd = selEndChar;
          evt.selFocusAtStart = rep.selFocusAtStart;
        }
        if (undoModule.enabled) {
          let undoWorked = false;
          try {
            if (isPadLoading(evt.eventType)) {
              undoModule.clearHistory();
            } else if (evt.eventType === "nonundoable") {
              if (evt.changeset) {
                undoModule.reportExternalChange(evt.changeset);
              }
            } else {
              undoModule.reportEvent(evt);
            }
            undoWorked = true;
          } finally {
            if (!undoWorked) {
              undoModule.enabled = false;
            }
          }
        }
      };
      const startNewEvent = (eventType, dontSubmitOld) => {
        const oldEvent = currentCallStack.editEvent;
        if (!dontSubmitOld) {
          submitOldEvent(oldEvent);
        }
        currentCallStack.editEvent = newEditEvent(eventType);
        return oldEvent;
      };
      currentCallStack = {
        type,
        docTextChanged: false,
        selectionAffected: false,
        userChangedSelection: false,
        domClean: false,
        isUserChange: false,
        // is this a "user change" type of call-stack
        repChanged: false,
        editEvent: newEditEvent(type),
        startNewEvent
      };
      let cleanExit = false;
      let result2;
      try {
        result2 = action();
        hooks$1.callAll("aceEditEvent", {
          callstack: currentCallStack,
          editorInfo,
          rep,
          documentAttributeManager
        });
        cleanExit = true;
      } finally {
        const cs = currentCallStack;
        if (cleanExit) {
          submitOldEvent(cs.editEvent);
          if (cs.domClean && cs.type !== "setup") {
            if (cs.selectionAffected) {
              updateBrowserSelectionFromRep();
            }
            if ((cs.docTextChanged || cs.userChangedSelection) && isScrollableEditEvent(cs.type)) {
              scrollSelectionIntoView();
            }
            if (cs.docTextChanged && cs.type.indexOf("importText") < 0) {
              outsideNotifyDirty();
            }
          }
        } else if (currentCallStack.type === "idleWorkTimer") {
          idleWorkTimer.atLeast(1e3);
        }
        currentCallStack = null;
      }
      return result2;
    };
    editorInfo.ace_inCallStack = inCallStack;
    const inCallStackIfNecessary = (type, action) => {
      if (!currentCallStack) {
        inCallStack(type, action);
      } else {
        action();
      }
    };
    editorInfo.ace_inCallStackIfNecessary = inCallStackIfNecessary;
    const dispose = () => {
      disposed = true;
      if (idleWorkTimer)
        idleWorkTimer.never();
      teardown();
    };
    const setWraps = (newVal) => {
      doesWrap = newVal;
      targetBody.classList.toggle("doesWrap", doesWrap);
      scheduler.setTimeout(() => {
        inCallStackIfNecessary("setWraps", () => {
          fastIncorp();
          recreateDOM();
          fixView();
        });
      }, 0);
    };
    const setStyled = (newVal) => {
      const oldVal = isStyled;
      isStyled = !!newVal;
      if (newVal !== oldVal) {
        if (!newVal) {
          inCallStackIfNecessary("setStyled", () => {
            fastIncorp();
            const clearStyles = [];
            for (const k of Object.keys(STYLE_ATTRIBS)) {
              clearStyles.push([k, ""]);
            }
            performDocumentApplyAttributesToCharRange(0, rep.alltext.length, clearStyles);
          });
        }
      }
    };
    const setTextFace = (face) => {
      targetBody.style.fontFamily = face;
      lineMetricsDiv.style.fontFamily = face;
    };
    const recreateDOM = () => {
      recolorLinesInRange(0, rep.alltext.length);
    };
    const setEditable = (newVal) => {
      isEditable = newVal;
      targetBody.contentEditable = isEditable ? "true" : "false";
      targetBody.classList.toggle("static", !isEditable);
    };
    const enforceEditability = () => setEditable(isEditable);
    const importText = (text, undoable, dontProcess) => {
      let lines;
      if (dontProcess) {
        if (text.charAt(text.length - 1) !== "\n") {
          throw new Error("new raw text must end with newline");
        }
        if (/[\r\t\xa0]/.exec(text)) {
          throw new Error("new raw text must not contain CR, tab, or nbsp");
        }
        lines = text.substring(0, text.length - 1).split("\n");
      } else {
        lines = text.split("\n").map(textify);
      }
      let newText = "\n";
      if (lines.length > 0) {
        newText = `${lines.join("\n")}
`;
      }
      inCallStackIfNecessary(`importText${undoable ? "Undoable" : ""}`, () => {
        setDocText(newText);
      });
      if (dontProcess && rep.alltext !== text) {
        throw new Error("mismatch error setting raw text in importText");
      }
    };
    const importAText = (atext, apoolJsonObj, undoable) => {
      atext = Changeset2.cloneAText(atext);
      if (apoolJsonObj) {
        const wireApool = new AttribPool().fromJsonable(apoolJsonObj);
        atext.attribs = Changeset2.moveOpsToNewPool(atext.attribs, wireApool, rep.apool);
      }
      inCallStackIfNecessary(`importText${undoable ? "Undoable" : ""}`, () => {
        setDocAText(atext);
      });
    };
    const setDocAText = (atext) => {
      if (atext.text === "") {
        atext.text = "\n";
      }
      fastIncorp();
      window.console.log(rep);
      const oldLen = rep.lines.totalWidth();
      const numLines = rep.lines.length();
      const upToLastLine = rep.lines.offsetOfIndex(numLines - 1);
      const lastLineLength = rep.lines.atIndex(numLines - 1).text.length;
      const assem = Changeset2.smartOpAssembler();
      const o = new Changeset2.Op("-");
      o.chars = upToLastLine;
      o.lines = numLines - 1;
      assem.append(o);
      o.chars = lastLineLength;
      o.lines = 0;
      assem.append(o);
      for (const op of Changeset2.opsFromAText(atext))
        assem.append(op);
      const newLen = oldLen + assem.getLengthChange();
      const changeset = Changeset2.checkRep(
        Changeset2.pack(oldLen, newLen, assem.toString(), atext.text.slice(0, -1))
      );
      performDocumentApplyChangeset(changeset);
      performSelectionChange(
        [0, rep.lines.atIndex(0).lineMarker],
        [0, rep.lines.atIndex(0).lineMarker]
      );
      idleWorkTimer.atMost(100);
      if (rep.alltext !== atext.text) {
        throw new Error("mismatch error setting raw text in setDocAText");
      }
    };
    const setDocText = (text) => {
      setDocAText(Changeset2.makeAText(text));
    };
    const getDocText = () => {
      const alltext = rep.alltext;
      let len = alltext.length;
      if (len > 0)
        len--;
      return alltext.substring(0, len);
    };
    const exportText = () => {
      if (currentCallStack && !currentCallStack.domClean) {
        inCallStackIfNecessary("exportText", () => {
          fastIncorp();
        });
      }
      return getDocText();
    };
    const editorChangedSize = () => fixView();
    const setOnKeyPress = (handler) => {
      outsideKeyPress = handler;
    };
    const setOnKeyDown = (handler) => {
      outsideKeyDown = handler;
    };
    const setNotifyDirty = (handler) => {
      outsideNotifyDirty = handler;
    };
    const CMDS = {
      clearauthorship: (prompt) => {
        if (!(rep.selStart && rep.selEnd) || isCaret()) {
          if (prompt) {
            prompt();
          } else {
            performDocumentApplyAttributesToCharRange(0, rep.alltext.length, [
              ["author", ""]
            ]);
          }
        } else {
          setAttributeOnSelection("author", "");
        }
      }
    };
    const execCommand = (cmd, ...args) => {
      cmd = cmd.toLowerCase();
      if (CMDS[cmd]) {
        inCallStackIfNecessary(cmd, () => {
          fastIncorp();
          CMDS[cmd](...args);
        });
      }
    };
    const replaceRange = (start, end, text) => {
      inCallStackIfNecessary("replaceRange", () => {
        fastIncorp();
        performDocumentReplaceRange(start, end, text);
      });
    };
    editorInfo.ace_callWithAce = (fn, callStack, normalize) => {
      let wrapper = () => fn(editorInfo);
      if (normalize !== void 0) {
        const wrapper1 = wrapper;
        wrapper = () => {
          editorInfo.ace_fastIncorp(9);
          wrapper1();
        };
      }
      if (callStack !== void 0) {
        return editorInfo.ace_inCallStack(callStack, wrapper);
      } else {
        return wrapper();
      }
    };
    editorInfo.ace_setProperty = (key, value) => {
      const setters = {
        wraps: setWraps,
        showsauthorcolors: (val) => targetBody.classList.toggle("authorColors", !!val),
        showsuserselections: (val) => targetBody.classList.toggle("userSelections", !!val),
        showslinenumbers: (value2) => {
          hasLineNumbers = !!value2;
          sideDiv.parentNode.classList.toggle("line-numbers-hidden", !hasLineNumbers);
          fixView();
        },
        userauthor: (value2) => {
          thisAuthor = String(value2);
          documentAttributeManager.author = thisAuthor;
        },
        styled: setStyled,
        textface: setTextFace,
        rtlistrue: (value2) => {
          targetBody.classList.toggle("rtl", value2);
          targetBody.classList.toggle("ltr", !value2);
          document.documentElement.dir = value2 ? "rtl" : "ltr";
        }
      };
      const setter = setters[key.toLowerCase()];
      if (setter !== void 0) {
        setter(value);
      }
    };
    editorInfo.ace_setBaseText = (txt) => {
      changesetTracker.setBaseText(txt);
    };
    editorInfo.ace_setBaseAttributedText = (atxt, apoolJsonObj) => {
      changesetTracker.setBaseAttributedText(atxt, apoolJsonObj);
    };
    editorInfo.ace_applyChangesToBase = (c, optAuthor, apoolJsonObj) => {
      changesetTracker.applyChangesToBase(c, optAuthor, apoolJsonObj);
    };
    editorInfo.ace_prepareUserChangeset = () => changesetTracker.prepareUserChangeset();
    editorInfo.ace_applyPreparedChangesetToBase = () => {
      changesetTracker.applyPreparedChangesetToBase();
    };
    editorInfo.ace_setUserChangeNotificationCallback = (f) => {
      changesetTracker.setUserChangeNotificationCallback(f);
    };
    editorInfo.ace_setAuthorInfo = (author, info) => {
      setAuthorInfo(author, info);
    };
    editorInfo.ace_getDocument = () => document;
    const now2 = () => Date.now();
    const newTimeLimit = (ms2) => {
      const startTime = now2();
      let exceededAlready = false;
      const isTimeUp = () => {
        if (exceededAlready) {
          return true;
        }
        const elapsed = now2() - startTime;
        if (elapsed > ms2) {
          exceededAlready = true;
          return true;
        } else {
          return false;
        }
      };
      isTimeUp.elapsed = () => now2() - startTime;
      return isTimeUp;
    };
    const makeIdleAction = (func) => {
      let scheduledTimeout = null;
      let scheduledTime = 0;
      const unschedule = () => {
        if (scheduledTimeout) {
          scheduler.clearTimeout(scheduledTimeout);
          scheduledTimeout = null;
        }
      };
      const reschedule = (time) => {
        unschedule();
        scheduledTime = time;
        let delay2 = time - now2();
        if (delay2 < 0)
          delay2 = 0;
        scheduledTimeout = scheduler.setTimeout(callback, delay2);
      };
      const callback = () => {
        scheduledTimeout = null;
        func();
      };
      return {
        atMost: (ms2) => {
          const latestTime = now2() + ms2;
          if (!scheduledTimeout || scheduledTime > latestTime) {
            reschedule(latestTime);
          }
        },
        // atLeast(ms) will schedule the action if not scheduled yet.
        // In other words, "infinity" is replaced by ms, even though
        // it is technically larger.
        atLeast: (ms2) => {
          const earliestTime = now2() + ms2;
          if (!scheduledTimeout || scheduledTime < earliestTime) {
            reschedule(earliestTime);
          }
        },
        never: () => {
          unschedule();
        }
      };
    };
    const fastIncorp = (n) => {
      incorporateUserChanges();
    };
    editorInfo.ace_fastIncorp = fastIncorp;
    const idleWorkTimer = makeIdleAction(() => {
      if (inInternationalComposition) {
        idleWorkTimer.atLeast(500);
        return;
      }
      inCallStackIfNecessary("idleWorkTimer", () => {
        const isTimeUp = newTimeLimit(250);
        let finishedImportantWork = false;
        let finishedWork = false;
        try {
          incorporateUserChanges();
          if (isTimeUp())
            return;
          updateLineNumbers();
          if (isTimeUp())
            return;
          finishedImportantWork = true;
          finishedWork = true;
        } finally {
          if (finishedWork) {
            idleWorkTimer.atMost(1e3);
          } else if (finishedImportantWork) {
            idleWorkTimer.atMost(500);
          } else {
            let timeToWait = Math.round(isTimeUp.elapsed() / 2);
            if (timeToWait < 100)
              timeToWait = 100;
            idleWorkTimer.atMost(timeToWait);
          }
        }
      });
    });
    let _nextId = 1;
    const uniqueId2 = (n) => {
      const nid = n.id;
      if (nid)
        return nid;
      return n.id = `magicdomid${_nextId++}`;
    };
    const recolorLinesInRange = (startChar, endChar) => {
      if (endChar <= startChar)
        return;
      if (startChar >= rep.lines.totalWidth())
        return;
      let lineEntry = rep.lines.atOffset(startChar);
      let lineStart = rep.lines.offsetOfEntry(lineEntry);
      let lineIndex = rep.lines.indexOfEntry(lineEntry);
      let selectionNeedsResetting = false;
      const tokenFunc = (tokenText, tokenClass) => {
        lineEntry.domInfo.appendSpan(tokenText, tokenClass);
      };
      while (lineEntry && lineStart < endChar) {
        const lineEnd = lineStart + lineEntry.width;
        lineEntry.domInfo.clearSpans();
        getSpansForLine(lineEntry, tokenFunc, lineStart);
        lineEntry.domInfo.finishUpdate();
        markNodeClean(lineEntry.lineNode);
        if (rep.selStart && rep.selStart[0] === lineIndex || rep.selEnd && rep.selEnd[0] === lineIndex) {
          selectionNeedsResetting = true;
        }
        lineStart = lineEnd;
        lineEntry = rep.lines.next(lineEntry);
        lineIndex++;
      }
      if (selectionNeedsResetting) {
        currentCallStack.selectionAffected = true;
      }
    };
    const getSpansForLine = (lineEntry, textAndClassFunc, lineEntryOffsetHint) => {
      let lineEntryOffset = lineEntryOffsetHint;
      if (typeof lineEntryOffset !== "number") {
        lineEntryOffset = rep.lines.offsetOfEntry(lineEntry);
      }
      const text = lineEntry.text;
      if (text.length === 0) {
        const func = linestylefilter2.getLineStyleFilter(
          0,
          "",
          textAndClassFunc,
          rep.apool
        );
        func("", "");
      } else {
        let filteredFunc = linestylefilter2.getFilterStack(text, textAndClassFunc, browser2);
        const lineNum = rep.lines.indexOfEntry(lineEntry);
        const aline = rep.alines[lineNum];
        filteredFunc = linestylefilter2.getLineStyleFilter(
          text.length,
          aline,
          filteredFunc,
          rep.apool
        );
        filteredFunc(text, "");
      }
    };
    let observedChanges;
    const clearObservedChanges = () => {
      observedChanges = {
        cleanNodesNearChanges: {}
      };
    };
    clearObservedChanges();
    const getCleanNodeByKey = (key) => {
      let n = targetDoc.getElementById(key);
      while (n && isNodeDirty(n)) {
        n.id = "";
        n = targetDoc.getElementById(key);
      }
      return n;
    };
    const observeChangesAroundNode = (node) => {
      let cleanNode;
      let hasAdjacentDirtyness;
      if (!isNodeDirty(node)) {
        cleanNode = node;
        const prevSib = cleanNode.previousSibling;
        const nextSib = cleanNode.nextSibling;
        hasAdjacentDirtyness = prevSib && isNodeDirty(prevSib) || nextSib && isNodeDirty(nextSib);
      } else {
        let upNode = node.previousSibling;
        while (upNode && isNodeDirty(upNode)) {
          upNode = upNode.previousSibling;
        }
        if (upNode) {
          cleanNode = upNode;
        } else {
          let downNode = node.nextSibling;
          while (downNode && isNodeDirty(downNode)) {
            downNode = downNode.nextSibling;
          }
          if (downNode) {
            cleanNode = downNode;
          }
        }
        if (!cleanNode) {
          return;
        }
        hasAdjacentDirtyness = true;
      }
      if (hasAdjacentDirtyness) {
        observedChanges.cleanNodesNearChanges[`$${uniqueId2(cleanNode)}`] = true;
      } else {
        const lineKey = uniqueId2(cleanNode);
        const prevSib = cleanNode.previousSibling;
        const nextSib = cleanNode.nextSibling;
        const actualPrevKey = prevSib && uniqueId2(prevSib) || null;
        const actualNextKey = nextSib && uniqueId2(nextSib) || null;
        const repPrevEntry = rep.lines.prev(rep.lines.atKey(lineKey));
        const repNextEntry = rep.lines.next(rep.lines.atKey(lineKey));
        const repPrevKey = repPrevEntry && repPrevEntry.key || null;
        const repNextKey = repNextEntry && repNextEntry.key || null;
        if (actualPrevKey !== repPrevKey || actualNextKey !== repNextKey) {
          observedChanges.cleanNodesNearChanges[`$${uniqueId2(cleanNode)}`] = true;
        }
      }
    };
    const observeChangesAroundSelection = () => {
      if (currentCallStack.observedSelection)
        return;
      currentCallStack.observedSelection = true;
      const selection = getSelection();
      if (selection) {
        const node1 = topLevel(selection.startPoint.node);
        const node2 = topLevel(selection.endPoint.node);
        if (node1)
          observeChangesAroundNode(node1);
        if (node2 && node1 !== node2) {
          observeChangesAroundNode(node2);
        }
      }
    };
    const observeSuspiciousNodes = () => {
      if (targetBody.getElementsByTagName) {
        const elts = targetBody.getElementsByTagName("style");
        for (const elt of elts) {
          const n = topLevel(elt);
          if (n && n.parentNode === targetBody) {
            observeChangesAroundNode(n);
          }
        }
      }
    };
    const incorporateUserChanges = () => {
      if (currentCallStack.domClean)
        return false;
      currentCallStack.isUserChange = true;
      if (window.DEBUG_DONT_INCORP)
        return false;
      if (!targetBody.firstChild) {
        targetBody.innerHTML = "<div><!-- --></div>";
      }
      observeChangesAroundSelection();
      observeSuspiciousNodes();
      let dirtyRanges = getDirtyRanges();
      let dirtyRangesCheckOut = true;
      let j = 0;
      let a, b;
      let scrollToTheLeftNeeded = false;
      while (j < dirtyRanges.length) {
        a = dirtyRanges[j][0];
        b = dirtyRanges[j][1];
        if (!((a === 0 || getCleanNodeByKey(rep.lines.atIndex(a - 1).key)) && (b === rep.lines.length() || getCleanNodeByKey(rep.lines.atIndex(b).key)))) {
          dirtyRangesCheckOut = false;
          break;
        }
        j++;
      }
      if (!dirtyRangesCheckOut) {
        for (const bodyNode of targetBody.childNodes) {
          if (bodyNode.tagName && (!bodyNode.id || !rep.lines.containsKey(bodyNode.id))) {
            observeChangesAroundNode(bodyNode);
          }
        }
        dirtyRanges = getDirtyRanges();
      }
      clearObservedChanges();
      const selection = getSelection();
      let selStart, selEnd;
      let i = 0;
      const splicesToDo = [];
      let netNumLinesChangeSoFar = 0;
      const toDeleteAtEnd = [];
      const domInsertsNeeded = [];
      while (i < dirtyRanges.length) {
        const range2 = dirtyRanges[i];
        a = range2[0];
        b = range2[1];
        let firstDirtyNode = a === 0 && targetBody.firstChild || getCleanNodeByKey(rep.lines.atIndex(a - 1).key).nextSibling;
        firstDirtyNode = firstDirtyNode && isNodeDirty(firstDirtyNode) && firstDirtyNode;
        let lastDirtyNode = b === rep.lines.length() && targetBody.lastChild || getCleanNodeByKey(rep.lines.atIndex(b).key).previousSibling;
        lastDirtyNode = lastDirtyNode && isNodeDirty(lastDirtyNode) && lastDirtyNode;
        if (firstDirtyNode && lastDirtyNode) {
          const cc = makeContentCollector(isStyled, browser2, rep.apool, className2Author);
          cc.notifySelection(selection);
          const dirtyNodes = [];
          for (let n = firstDirtyNode; n && !(n.previousSibling && n.previousSibling === lastDirtyNode); n = n.nextSibling) {
            cc.collectContent(n);
            dirtyNodes.push(n);
          }
          cc.notifyNextNode(lastDirtyNode.nextSibling);
          let lines = cc.getLines();
          if ((lines.length <= 1 || lines[lines.length - 1] !== "") && lastDirtyNode.nextSibling) {
            b++;
            const cleanLine = lastDirtyNode.nextSibling;
            cc.collectContent(cleanLine);
            toDeleteAtEnd.push(cleanLine);
            cc.notifyNextNode(cleanLine.nextSibling);
          }
          const ccData = cc.finish();
          const ss = ccData.selStart;
          const se = ccData.selEnd;
          lines = ccData.lines;
          const lineAttribs = ccData.lineAttribs;
          const linesWrapped = ccData.linesWrapped;
          if (linesWrapped > 0) {
            scrollToTheLeftNeeded = true;
          }
          if (ss[0] >= 0)
            selStart = [ss[0] + a + netNumLinesChangeSoFar, ss[1]];
          if (se[0] >= 0)
            selEnd = [se[0] + a + netNumLinesChangeSoFar, se[1]];
          const entries = [];
          const nodeToAddAfter = lastDirtyNode;
          const lineNodeInfos = [];
          for (const lineString of lines) {
            const newEntry = createDomLineEntry(lineString);
            entries.push(newEntry);
            lineNodeInfos.push(newEntry.domInfo);
          }
          domInsertsNeeded.push([nodeToAddAfter, lineNodeInfos]);
          for (const n of dirtyNodes)
            toDeleteAtEnd.push(n);
          const spliceHints = {};
          if (selStart)
            spliceHints.selStart = selStart;
          if (selEnd)
            spliceHints.selEnd = selEnd;
          splicesToDo.push([a + netNumLinesChangeSoFar, b - a, entries, lineAttribs, spliceHints]);
          netNumLinesChangeSoFar += lines.length - (b - a);
        } else if (b > a) {
          splicesToDo.push([a + netNumLinesChangeSoFar, b - a, [], []]);
        }
        i++;
      }
      const domChanges = splicesToDo.length > 0;
      for (const splice of splicesToDo)
        doIncorpLineSplice(...splice);
      for (const ins of domInsertsNeeded)
        insertDomLines(...ins);
      for (const n of toDeleteAtEnd)
        n.remove();
      if (scrollToTheLeftNeeded) {
        $2("#innerdocbody").scrollLeft(0);
      }
      if (selection && !selStart) {
        const selStartFromHook = hooks$1.callAll("aceStartLineAndCharForPoint", {
          callstack: currentCallStack,
          editorInfo,
          rep,
          root: targetBody,
          point: selection.startPoint,
          documentAttributeManager
        });
        selStart = selStartFromHook == null || selStartFromHook.length === 0 ? getLineAndCharForPoint(selection.startPoint) : selStartFromHook;
      }
      if (selection && !selEnd) {
        const selEndFromHook = hooks$1.callAll("aceEndLineAndCharForPoint", {
          callstack: currentCallStack,
          editorInfo,
          rep,
          root: targetBody,
          point: selection.endPoint,
          documentAttributeManager
        });
        selEnd = selEndFromHook == null || selEndFromHook.length === 0 ? getLineAndCharForPoint(selection.endPoint) : selEndFromHook;
      }
      const numLines = rep.lines.length();
      if (selStart && selStart[0] >= numLines) {
        selStart[0] = numLines - 1;
        selStart[1] = rep.lines.atIndex(selStart[0]).text.length;
      }
      if (selEnd && selEnd[0] >= numLines) {
        selEnd[0] = numLines - 1;
        selEnd[1] = rep.lines.atIndex(selEnd[0]).text.length;
      }
      if (selection)
        repSelectionChange(selStart, selEnd, selection && selection.focusAtStart);
      if (selection && (domChanges || isCaret())) {
        currentCallStack.selectionAffected = true;
      }
      currentCallStack.domClean = true;
      fixView();
      return domChanges;
    };
    const STYLE_ATTRIBS = {
      bold: true,
      italic: true,
      underline: true,
      strikethrough: true,
      list: true
    };
    const isStyleAttribute = (aname) => !!STYLE_ATTRIBS[aname];
    const isDefaultLineAttribute = (aname) => AttributeManager.DEFAULT_LINE_ATTRIBUTES.indexOf(aname) !== -1;
    const insertDomLines = (nodeToAddAfter, infoStructs) => {
      let lastEntry;
      let lineStartOffset;
      for (const info of infoStructs) {
        const node = info.node;
        const key = uniqueId2(node);
        let entry;
        if (lastEntry) {
          const next = rep.lines.next(lastEntry);
          if (next && next.key === key) {
            entry = next;
            lineStartOffset += lastEntry.width;
          }
        }
        if (!entry) {
          entry = rep.lines.atKey(key);
          lineStartOffset = rep.lines.offsetOfKey(key);
        }
        lastEntry = entry;
        getSpansForLine(entry, (tokenText, tokenClass) => {
          info.appendSpan(tokenText, tokenClass);
        }, lineStartOffset);
        info.prepareForAdd();
        entry.lineMarker = info.lineMarker;
        if (!nodeToAddAfter) {
          targetBody.insertBefore(node, targetBody.firstChild);
        } else {
          targetBody.insertBefore(node, nodeToAddAfter.nextSibling);
        }
        nodeToAddAfter = node;
        info.notifyAdded();
        markNodeClean(node);
      }
    };
    const isCaret = () => rep.selStart && rep.selEnd && rep.selStart[0] === rep.selEnd[0] && rep.selStart[1] === rep.selEnd[1];
    editorInfo.ace_isCaret = isCaret;
    const caretLine = () => rep.selStart[0];
    editorInfo.ace_caretLine = caretLine;
    const caretColumn = () => rep.selStart[1];
    editorInfo.ace_caretColumn = caretColumn;
    const caretDocChar = () => rep.lines.offsetOfIndex(caretLine()) + caretColumn();
    editorInfo.ace_caretDocChar = caretDocChar;
    const handleReturnIndentation = () => {
      if (isCaret() && caretColumn() === 0 && caretLine() > 0) {
        const lineNum = caretLine();
        const thisLine = rep.lines.atIndex(lineNum);
        const prevLine = rep.lines.prev(thisLine);
        const prevLineText = prevLine.text;
        let theIndent = /^ *(?:)/.exec(prevLineText)[0];
        const shouldIndent = parent.parent.clientVars.indentationOnNewLine;
        if (shouldIndent && /[[(:{]\s*$/.exec(prevLineText)) {
          theIndent += THE_TAB;
        }
        const cs = Changeset2.builder(rep.lines.totalWidth()).keep(
          rep.lines.offsetOfIndex(lineNum),
          lineNum
        ).insert(
          theIndent,
          [
            ["author", thisAuthor]
          ],
          rep.apool
        ).toString();
        performDocumentApplyChangeset(cs);
        performSelectionChange([lineNum, theIndent.length], [lineNum, theIndent.length]);
      }
    };
    const getPointForLineAndChar = (lineAndChar) => {
      const line = lineAndChar[0];
      let charsLeft = lineAndChar[1];
      const lineEntry = rep.lines.atIndex(line);
      charsLeft -= lineEntry.lineMarker;
      if (charsLeft < 0) {
        charsLeft = 0;
      }
      const lineNode = lineEntry.lineNode;
      let n = lineNode;
      let after2 = false;
      if (charsLeft === 0) {
        return {
          node: lineNode,
          index: 0,
          maxIndex: 1
        };
      }
      while (!(n === lineNode && after2)) {
        if (after2) {
          if (n.nextSibling) {
            n = n.nextSibling;
            after2 = false;
          } else {
            n = n.parentNode;
          }
        } else if (isNodeText(n)) {
          const len = n.nodeValue.length;
          if (charsLeft <= len) {
            return {
              node: n,
              index: charsLeft,
              maxIndex: len
            };
          }
          charsLeft -= len;
          after2 = true;
        } else if (n.firstChild) {
          n = n.firstChild;
        } else {
          after2 = true;
        }
      }
      return {
        node: lineNode,
        index: 1,
        maxIndex: 1
      };
    };
    const nodeText = (n) => n.textContent || n.nodeValue || "";
    const getLineAndCharForPoint = (point) => {
      if (point.node === targetBody) {
        if (point.index === 0) {
          return [0, 0];
        } else {
          const N = rep.lines.length();
          const ln = rep.lines.atIndex(N - 1);
          return [N - 1, ln.text.length];
        }
      } else {
        let n = point.node;
        let col = 0;
        if (isNodeText(n)) {
          col = point.index;
        } else if (point.index > 0) {
          col = nodeText(n).length;
        }
        let parNode, prevSib;
        while ((parNode = n.parentNode) !== targetBody) {
          if (prevSib = n.previousSibling) {
            n = prevSib;
            col += nodeText(n).length;
          } else {
            n = parNode;
          }
        }
        if (n.firstChild && isBlockElement(n.firstChild)) {
          col += 1;
        }
        const lineEntry = rep.lines.atKey(n.id);
        const lineNum = rep.lines.indexOfEntry(lineEntry);
        return [lineNum, col];
      }
    };
    editorInfo.ace_getLineAndCharForPoint = getLineAndCharForPoint;
    const createDomLineEntry = (lineString) => {
      const info = doCreateDomLine(lineString.length > 0);
      const newNode = info.node;
      return {
        key: uniqueId2(newNode),
        text: lineString,
        lineNode: newNode,
        domInfo: info,
        lineMarker: 0
      };
    };
    const performDocumentApplyChangeset = (changes, insertsAfterSelection) => {
      const domAndRepSplice = (startLine, deleteCount, newLineStrings) => {
        const keysToDelete = [];
        if (deleteCount > 0) {
          let entryToDelete = rep.lines.atIndex(startLine);
          for (let i = 0; i < deleteCount; i++) {
            keysToDelete.push(entryToDelete.key);
            entryToDelete = rep.lines.next(entryToDelete);
          }
        }
        const lineEntries = newLineStrings.map(createDomLineEntry);
        doRepLineSplice(startLine, deleteCount, lineEntries);
        let nodeToAddAfter;
        if (startLine > 0) {
          nodeToAddAfter = getCleanNodeByKey(rep.lines.atIndex(startLine - 1).key);
        } else {
          nodeToAddAfter = null;
        }
        insertDomLines(nodeToAddAfter, lineEntries.map((entry) => entry.domInfo));
        for (const k of keysToDelete) {
          const n = targetDoc.getElementById(k);
          n.parentNode.removeChild(n);
        }
        if (rep.selStart && rep.selStart[0] >= startLine && rep.selStart[0] <= startLine + deleteCount || rep.selEnd && rep.selEnd[0] >= startLine && rep.selEnd[0] <= startLine + deleteCount) {
          currentCallStack.selectionAffected = true;
        }
      };
      doRepApplyChangeset(changes);
      let requiredSelectionSetting = null;
      if (rep.selStart && rep.selEnd) {
        const selStartChar = rep.lines.offsetOfIndex(rep.selStart[0]) + rep.selStart[1];
        const selEndChar = rep.lines.offsetOfIndex(rep.selEnd[0]) + rep.selEnd[1];
        const result2 = Changeset2.characterRangeFollow(changes, selStartChar, selEndChar, insertsAfterSelection);
        requiredSelectionSetting = [result2[0], result2[1], rep.selFocusAtStart];
      }
      const linesMutatee = {
        splice: (start, numRemoved, ...args) => {
          domAndRepSplice(start, numRemoved, args.map((s) => s.slice(0, -1)));
        },
        get: (i) => `${rep.lines.atIndex(i).text}
`,
        length: () => rep.lines.length()
      };
      Changeset2.mutateTextLines(changes, linesMutatee);
      if (requiredSelectionSetting) {
        performSelectionChange(
          lineAndColumnFromChar(requiredSelectionSetting[0]),
          lineAndColumnFromChar(requiredSelectionSetting[1]),
          requiredSelectionSetting[2]
        );
      }
    };
    const doRepApplyChangeset = (changes, insertsAfterSelection) => {
      Changeset2.checkRep(changes);
      if (Changeset2.oldLen(changes) !== rep.alltext.length) {
        const errMsg = `${Changeset2.oldLen(changes)}/${rep.alltext.length}`;
        throw new Error(`doRepApplyChangeset length mismatch: ${errMsg}`);
      }
      const editEvent = currentCallStack.editEvent;
      if (editEvent.eventType === "nonundoable") {
        if (!editEvent.changeset) {
          editEvent.changeset = changes;
        } else {
          editEvent.changeset = Changeset2.compose(editEvent.changeset, changes, rep.apool);
        }
      } else {
        const inverseChangeset = Changeset2.inverse(changes, {
          get: (i) => `${rep.lines.atIndex(i).text}
`,
          length: () => rep.lines.length()
        }, rep.alines, rep.apool);
        if (!editEvent.backset) {
          editEvent.backset = inverseChangeset;
        } else {
          editEvent.backset = Changeset2.compose(inverseChangeset, editEvent.backset, rep.apool);
        }
      }
      Changeset2.mutateAttributionLines(changes, rep.alines, rep.apool);
      if (changesetTracker.isTracking()) {
        changesetTracker.composeUserChangeset(changes);
      }
    };
    const lineAndColumnFromChar = (x) => {
      const lineEntry = rep.lines.atOffset(x);
      const lineStart = rep.lines.offsetOfEntry(lineEntry);
      const lineNum = rep.lines.indexOfEntry(lineEntry);
      return [lineNum, x - lineStart];
    };
    const performDocumentReplaceCharRange = (startChar, endChar, newText) => {
      if (startChar === endChar && newText.length === 0) {
        return;
      }
      if (endChar === rep.alltext.length) {
        if (startChar === endChar) {
          startChar--;
          endChar--;
          newText = `
${newText.substring(0, newText.length - 1)}`;
        } else if (newText.length === 0) {
          startChar--;
          endChar--;
        } else {
          endChar--;
          newText = newText.substring(0, newText.length - 1);
        }
      }
      performDocumentReplaceRange(
        lineAndColumnFromChar(startChar),
        lineAndColumnFromChar(endChar),
        newText
      );
    };
    const performDocumentApplyAttributesToCharRange = (start, end, attribs) => {
      end = Math.min(end, rep.alltext.length - 1);
      documentAttributeManager.setAttributesOnRange(
        lineAndColumnFromChar(start),
        lineAndColumnFromChar(end),
        attribs
      );
    };
    editorInfo.ace_performDocumentApplyAttributesToCharRange = performDocumentApplyAttributesToCharRange;
    const setAttributeOnSelection = (attributeName, attributeValue) => {
      if (!(rep.selStart && rep.selEnd))
        return;
      documentAttributeManager.setAttributesOnRange(rep.selStart, rep.selEnd, [
        [attributeName, attributeValue]
      ]);
    };
    editorInfo.ace_setAttributeOnSelection = setAttributeOnSelection;
    const getAttributeOnSelection = (attributeName, prevChar) => {
      if (!(rep.selStart && rep.selEnd))
        return;
      const isNotSelection = rep.selStart[0] === rep.selEnd[0] && rep.selEnd[1] === rep.selStart[1];
      if (isNotSelection) {
        if (prevChar) {
          if (rep.selStart[1] !== 0) {
            rep.selStart[1]--;
          }
        }
      }
      const withIt = new AttributeMap(rep.apool).set(attributeName, "true").toString();
      const withItRegex = new RegExp(`${withIt.replace(/\*/g, "\\*")}(\\*|$)`);
      const hasIt = (attribs) => withItRegex.test(attribs);
      const rangeHasAttrib = (selStart, selEnd) => {
        if (selStart[1] === selEnd[1] && selStart[0] === selEnd[0])
          return false;
        if (selStart[0] !== selEnd[0]) {
          let hasAttrib2 = true;
          hasAttrib2 = hasAttrib2 && rangeHasAttrib(selStart, [selStart[0], rep.lines.atIndex(selStart[0]).text.length]);
          for (let n = selStart[0] + 1; n < selEnd[0]; n++) {
            hasAttrib2 = hasAttrib2 && rangeHasAttrib([n, 0], [n, rep.lines.atIndex(n).text.length]);
          }
          hasAttrib2 = hasAttrib2 && rangeHasAttrib([selEnd[0], 0], [selEnd[0], selEnd[1]]);
          return hasAttrib2;
        }
        const lineNum = selStart[0];
        const start = selStart[1];
        const end = selEnd[1];
        let hasAttrib = true;
        let indexIntoLine = 0;
        for (const op of Changeset2.deserializeOps(rep.alines[lineNum])) {
          const opStartInLine = indexIntoLine;
          const opEndInLine = opStartInLine + op.chars;
          if (!hasIt(op.attribs)) {
            if (!(opEndInLine <= start || opStartInLine >= end)) {
              hasAttrib = false;
              break;
            }
          }
          indexIntoLine = opEndInLine;
        }
        return hasAttrib;
      };
      return rangeHasAttrib(rep.selStart, rep.selEnd);
    };
    editorInfo.ace_getAttributeOnSelection = getAttributeOnSelection;
    const toggleAttributeOnSelection = (attributeName) => {
      if (!(rep.selStart && rep.selEnd))
        return;
      let selectionAllHasIt = true;
      const withIt = new AttributeMap(rep.apool).set(attributeName, "true").toString();
      const withItRegex = new RegExp(`${withIt.replace(/\*/g, "\\*")}(\\*|$)`);
      const hasIt = (attribs) => withItRegex.test(attribs);
      const selStartLine = rep.selStart[0];
      const selEndLine = rep.selEnd[0];
      for (let n = selStartLine; n <= selEndLine; n++) {
        let indexIntoLine = 0;
        let selectionStartInLine = 0;
        if (documentAttributeManager.lineHasMarker(n)) {
          selectionStartInLine = 1;
        }
        let selectionEndInLine = rep.lines.atIndex(n).text.length;
        if (n === selStartLine) {
          selectionStartInLine = rep.selStart[1];
        }
        if (n === selEndLine) {
          selectionEndInLine = rep.selEnd[1];
        }
        for (const op of Changeset2.deserializeOps(rep.alines[n])) {
          const opStartInLine = indexIntoLine;
          const opEndInLine = opStartInLine + op.chars;
          if (!hasIt(op.attribs)) {
            if (!(opEndInLine <= selectionStartInLine || opStartInLine >= selectionEndInLine)) {
              selectionAllHasIt = false;
              break;
            }
          }
          indexIntoLine = opEndInLine;
        }
        if (!selectionAllHasIt) {
          break;
        }
      }
      const attributeValue = selectionAllHasIt ? "" : "true";
      documentAttributeManager.setAttributesOnRange(
        rep.selStart,
        rep.selEnd,
        [[attributeName, attributeValue]]
      );
      if (attribIsFormattingStyle(attributeName)) {
        updateStyleButtonState(attributeName, !selectionAllHasIt);
      }
    };
    editorInfo.ace_toggleAttributeOnSelection = toggleAttributeOnSelection;
    const performDocumentReplaceSelection = (newText) => {
      if (!(rep.selStart && rep.selEnd))
        return;
      performDocumentReplaceRange(rep.selStart, rep.selEnd, newText);
    };
    const doRepLineSplice = (startLine, deleteCount, newLineEntries) => {
      for (const entry of newLineEntries)
        entry.width = entry.text.length + 1;
      const startOldChar = rep.lines.offsetOfIndex(startLine);
      const endOldChar = rep.lines.offsetOfIndex(startLine + deleteCount);
      rep.lines.splice(startLine, deleteCount, newLineEntries);
      currentCallStack.docTextChanged = true;
      currentCallStack.repChanged = true;
      const newText = newLineEntries.map((e) => `${e.text}
`).join("");
      rep.alltext = rep.alltext.substring(0, startOldChar) + newText + rep.alltext.substring(endOldChar, rep.alltext.length);
    };
    const doIncorpLineSplice = (startLine, deleteCount, newLineEntries, lineAttribs, hints) => {
      const startOldChar = rep.lines.offsetOfIndex(startLine);
      const endOldChar = rep.lines.offsetOfIndex(startLine + deleteCount);
      const oldRegionStart = rep.lines.offsetOfIndex(startLine);
      let selStartHintChar, selEndHintChar;
      if (hints && hints.selStart) {
        selStartHintChar = rep.lines.offsetOfIndex(hints.selStart[0]) + hints.selStart[1] - oldRegionStart;
      }
      if (hints && hints.selEnd) {
        selEndHintChar = rep.lines.offsetOfIndex(hints.selEnd[0]) + hints.selEnd[1] - oldRegionStart;
      }
      const newText = newLineEntries.map((e) => `${e.text}
`).join("");
      const oldText = rep.alltext.substring(startOldChar, endOldChar);
      const oldAttribs = rep.alines.slice(startLine, startLine + deleteCount).join("");
      const newAttribs = `${lineAttribs.join("|1+1")}|1+1`;
      const analysis = analyzeChange(oldText, newText, oldAttribs, newAttribs, selStartHintChar, selEndHintChar);
      const commonStart = analysis[0];
      let commonEnd = analysis[1];
      let shortOldText = oldText.substring(commonStart, oldText.length - commonEnd);
      let shortNewText = newText.substring(commonStart, newText.length - commonEnd);
      let spliceStart = startOldChar + commonStart;
      let spliceEnd = endOldChar - commonEnd;
      let shiftFinalNewlineToBeforeNewText = false;
      if (shortOldText.charAt(shortOldText.length - 1) === "\n" && shortNewText.charAt(shortNewText.length - 1) === "\n") {
        shortOldText = shortOldText.slice(0, -1);
        shortNewText = shortNewText.slice(0, -1);
        spliceEnd--;
        commonEnd++;
      }
      if (shortOldText.length === 0 && spliceStart === rep.alltext.length && shortNewText.length > 0) {
        spliceStart--;
        spliceEnd--;
        shortNewText = `
${shortNewText.slice(0, -1)}`;
        shiftFinalNewlineToBeforeNewText = true;
      }
      if (spliceEnd === rep.alltext.length && shortOldText.length > 0 && shortNewText.length === 0) {
        if (rep.alltext.charAt(spliceStart - 1) === "\n") {
          spliceStart--;
          spliceEnd--;
        }
      }
      if (!(shortOldText.length === 0 && shortNewText.length === 0)) {
        const oldDocText = rep.alltext;
        const oldLen = oldDocText.length;
        const spliceStartLine = rep.lines.indexOfOffset(spliceStart);
        const spliceStartLineStart = rep.lines.offsetOfIndex(spliceStartLine);
        const startBuilder = () => {
          const builder = Changeset2.builder(oldLen);
          builder.keep(spliceStartLineStart, spliceStartLine);
          builder.keep(spliceStart - spliceStartLineStart);
          return builder;
        };
        const eachAttribRun = (attribs, func) => {
          let textIndex = 0;
          const newTextStart = commonStart;
          const newTextEnd = newText.length - commonEnd - (shiftFinalNewlineToBeforeNewText ? 1 : 0);
          for (const op of Changeset2.deserializeOps(attribs)) {
            const nextIndex = textIndex + op.chars;
            if (!(nextIndex <= newTextStart || textIndex >= newTextEnd)) {
              func(Math.max(newTextStart, textIndex), Math.min(newTextEnd, nextIndex), op.attribs);
            }
            textIndex = nextIndex;
          }
        };
        const justApplyStyles = shortNewText === shortOldText;
        let theChangeset;
        if (justApplyStyles) {
          const incorpedAttribClearer = cachedStrFunc(
            (oldAtts) => Changeset2.mapAttribNumbers(oldAtts, (n) => {
              const k = rep.apool.getAttribKey(n);
              if (isStyleAttribute(k)) {
                return rep.apool.putAttrib([k, ""]);
              }
              return false;
            })
          );
          const builder1 = startBuilder();
          if (shiftFinalNewlineToBeforeNewText) {
            builder1.keep(1, 1);
          }
          eachAttribRun(oldAttribs, (start, end, attribs) => {
            builder1.keepText(newText.substring(start, end), incorpedAttribClearer(attribs));
          });
          const clearer = builder1.toString();
          const builder2 = startBuilder();
          if (shiftFinalNewlineToBeforeNewText) {
            builder2.keep(1, 1);
          }
          eachAttribRun(newAttribs, (start, end, attribs) => {
            builder2.keepText(newText.substring(start, end), attribs);
          });
          const styler = builder2.toString();
          theChangeset = Changeset2.compose(clearer, styler, rep.apool);
        } else {
          const builder = startBuilder();
          const spliceEndLine = rep.lines.indexOfOffset(spliceEnd);
          const spliceEndLineStart = rep.lines.offsetOfIndex(spliceEndLine);
          if (spliceEndLineStart > spliceStart) {
            builder.remove(spliceEndLineStart - spliceStart, spliceEndLine - spliceStartLine);
            builder.remove(spliceEnd - spliceEndLineStart);
          } else {
            builder.remove(spliceEnd - spliceStart);
          }
          let isNewTextMultiauthor = false;
          const authorizer = cachedStrFunc((oldAtts) => {
            const attribs = AttributeMap.fromString(oldAtts, rep.apool);
            if (!isNewTextMultiauthor || !attribs.has("author"))
              attribs.set("author", thisAuthor);
            return attribs.toString();
          });
          let foundDomAuthor = "";
          eachAttribRun(newAttribs, (start, end, attribs) => {
            const a = AttributeMap.fromString(attribs, rep.apool).get("author");
            if (a && a !== foundDomAuthor) {
              if (!foundDomAuthor) {
                foundDomAuthor = a;
              } else {
                isNewTextMultiauthor = true;
              }
            }
          });
          if (shiftFinalNewlineToBeforeNewText) {
            builder.insert("\n", authorizer(""));
          }
          eachAttribRun(newAttribs, (start, end, attribs) => {
            builder.insert(newText.substring(start, end), authorizer(attribs));
          });
          theChangeset = builder.toString();
        }
        doRepApplyChangeset(theChangeset);
      }
      doRepLineSplice(startLine, deleteCount, newLineEntries);
    };
    const cachedStrFunc = (func) => {
      const cache = {};
      return (s) => {
        if (!cache[s]) {
          cache[s] = func(s);
        }
        return cache[s];
      };
    };
    const analyzeChange = (oldText, newText, oldAttribs, newAttribs, optSelStartHint, optSelEndHint) => {
      const incorpedAttribFilter = (anum) => !isDefaultLineAttribute(rep.apool.getAttribKey(anum));
      const attribRuns = (attribs) => {
        const lengs = [];
        const atts = [];
        for (const op of Changeset2.deserializeOps(attribs)) {
          lengs.push(op.chars);
          atts.push(op.attribs);
        }
        return [lengs, atts];
      };
      const attribIterator = (runs, backward) => {
        const lengs = runs[0];
        const atts = runs[1];
        let i = backward ? lengs.length - 1 : 0;
        let j = 0;
        const next = () => {
          while (j >= lengs[i]) {
            if (backward)
              i--;
            else
              i++;
            j = 0;
          }
          const a = atts[i];
          j++;
          return a;
        };
        return next;
      };
      const oldLen = oldText.length;
      const newLen = newText.length;
      const minLen = Math.min(oldLen, newLen);
      const oldARuns = attribRuns(Changeset2.filterAttribNumbers(oldAttribs, incorpedAttribFilter));
      const newARuns = attribRuns(Changeset2.filterAttribNumbers(newAttribs, incorpedAttribFilter));
      let commonStart = 0;
      const oldStartIter = attribIterator(oldARuns, false);
      const newStartIter = attribIterator(newARuns, false);
      while (commonStart < minLen) {
        if (oldText.charAt(commonStart) === newText.charAt(commonStart) && oldStartIter() === newStartIter()) {
          commonStart++;
        } else {
          break;
        }
      }
      let commonEnd = 0;
      const oldEndIter = attribIterator(oldARuns, true);
      const newEndIter = attribIterator(newARuns, true);
      while (commonEnd < minLen) {
        if (commonEnd === 0) {
          oldEndIter();
          newEndIter();
          commonEnd++;
        } else if (oldText.charAt(oldLen - 1 - commonEnd) === newText.charAt(newLen - 1 - commonEnd) && oldEndIter() === newEndIter()) {
          commonEnd++;
        } else {
          break;
        }
      }
      let hintedCommonEnd = -1;
      if (typeof optSelEndHint === "number") {
        hintedCommonEnd = newLen - optSelEndHint;
      }
      if (commonStart + commonEnd > oldLen) {
        const minCommonEnd = oldLen - commonStart;
        const maxCommonEnd = commonEnd;
        if (hintedCommonEnd >= minCommonEnd && hintedCommonEnd <= maxCommonEnd) {
          commonEnd = hintedCommonEnd;
        } else {
          commonEnd = minCommonEnd;
        }
        commonStart = oldLen - commonEnd;
      }
      if (commonStart + commonEnd > newLen) {
        const minCommonEnd = newLen - commonStart;
        const maxCommonEnd = commonEnd;
        if (hintedCommonEnd >= minCommonEnd && hintedCommonEnd <= maxCommonEnd) {
          commonEnd = hintedCommonEnd;
        } else {
          commonEnd = minCommonEnd;
        }
        commonStart = newLen - commonEnd;
      }
      return [commonStart, commonEnd];
    };
    const equalLineAndChars = (a, b) => {
      if (!a)
        return !b;
      if (!b)
        return !a;
      return a[0] === b[0] && a[1] === b[1];
    };
    const performSelectionChange = (selectStart, selectEnd, focusAtStart) => {
      if (repSelectionChange(selectStart, selectEnd, focusAtStart)) {
        currentCallStack.selectionAffected = true;
      }
    };
    editorInfo.ace_performSelectionChange = performSelectionChange;
    const repSelectionChange = (selectStart, selectEnd, focusAtStart) => {
      focusAtStart = !!focusAtStart;
      const newSelFocusAtStart = focusAtStart && (!selectStart || !selectEnd || selectStart[0] !== selectEnd[0] || selectStart[1] !== selectEnd[1]);
      if (!equalLineAndChars(rep.selStart, selectStart) || !equalLineAndChars(rep.selEnd, selectEnd) || rep.selFocusAtStart !== newSelFocusAtStart) {
        rep.selStart = selectStart;
        rep.selEnd = selectEnd;
        rep.selFocusAtStart = newSelFocusAtStart;
        currentCallStack.repChanged = true;
        selectFormattingButtonIfLineHasStyleApplied();
        hooks$1.callAll("aceSelectionChanged", {
          rep,
          callstack: currentCallStack,
          documentAttributeManager
        });
        const docTextChanged = currentCallStack.docTextChanged;
        if (!docTextChanged) {
          const isScrollableEvent = !isPadLoading(currentCallStack.type) && isScrollableEditEvent(currentCallStack.type);
          const innerHeight = getInnerHeight();
          scroll2.scrollWhenCaretIsInTheLastLineOfViewportWhenNecessary(
            rep,
            isScrollableEvent,
            innerHeight * 2
          );
        }
        return true;
      }
      return false;
    };
    const isPadLoading = (t) => t === "setup" || t === "setBaseText" || t === "importText";
    const updateStyleButtonState = (attribName, hasStyleOnRepSelection) => {
      const $formattingButton = parent.parent.$(`[data-key="${attribName}"]`).find("a");
      $formattingButton.toggleClass(SELECT_BUTTON_CLASS, hasStyleOnRepSelection);
    };
    const attribIsFormattingStyle = (attribName) => FORMATTING_STYLES.indexOf(attribName) !== -1;
    const selectFormattingButtonIfLineHasStyleApplied = (rep2) => {
      for (const style of FORMATTING_STYLES) {
        const hasStyleOnRepSelection = documentAttributeManager.hasAttributeOnSelectionOrCaretPosition(style);
        updateStyleButtonState(style, hasStyleOnRepSelection);
      }
    };
    const doCreateDomLine = (nonEmpty) => domline2.createDomLine(nonEmpty, doesWrap, browser2, document);
    const textify = (str) => str.replace(/[\n\r ]/g, " ").replace(/\xa0/g, " ").replace(/\t/g, "        ");
    const _blockElems = {
      div: 1,
      p: 1,
      pre: 1,
      li: 1,
      ol: 1,
      ul: 1
    };
    for (const element of hooks$1.callAll("aceRegisterBlockElements"))
      _blockElems[element] = 1;
    const isBlockElement = (n) => !!_blockElems[(n.tagName || "").toLowerCase()];
    editorInfo.ace_isBlockElement = isBlockElement;
    const getDirtyRanges = () => {
      const cleanNodeForIndexCache = {};
      const N = rep.lines.length();
      const cleanNodeForIndex = (i) => {
        if (cleanNodeForIndexCache[i] === void 0) {
          let result2;
          if (i < 0 || i >= N) {
            result2 = true;
          } else {
            const key = rep.lines.atIndex(i).key;
            result2 = getCleanNodeByKey(key) || false;
          }
          cleanNodeForIndexCache[i] = result2;
        }
        return cleanNodeForIndexCache[i];
      };
      const isConsecutiveCache = {};
      const isConsecutive = (i) => {
        if (isConsecutiveCache[i] === void 0) {
          isConsecutiveCache[i] = (() => {
            const a = cleanNodeForIndex(i - 1);
            const b = cleanNodeForIndex(i);
            if (!a || !b)
              return false;
            if (a === true && b === true)
              return !targetBody.firstChild;
            if (a === true && b.previousSibling)
              return false;
            if (b === true && a.nextSibling)
              return false;
            if (a === true || b === true)
              return true;
            return a.nextSibling === b;
          })();
        }
        return isConsecutiveCache[i];
      };
      const isClean = (i) => !!cleanNodeForIndex(i);
      const cleanRanges = [
        [-1, N + 1]
      ];
      const rangeForLine = (i) => {
        for (const [idx, r] of cleanRanges.entries()) {
          if (i < r[0])
            return -1;
          if (i < r[1])
            return idx;
        }
        return -1;
      };
      const removeLineFromRange = (rng, line) => {
        const a = cleanRanges[rng][0];
        const b = cleanRanges[rng][1];
        if (a + 1 === b)
          cleanRanges.splice(rng, 1);
        else if (line === a)
          cleanRanges[rng][0]++;
        else if (line === b - 1)
          cleanRanges[rng][1]--;
        else
          cleanRanges.splice(rng, 1, [a, line], [line + 1, b]);
      };
      const splitRange = (rng, pt) => {
        const a = cleanRanges[rng][0];
        const b = cleanRanges[rng][1];
        cleanRanges.splice(rng, 1, [a, pt], [pt, b]);
      };
      const correctedLines = {};
      const correctlyAssignLine = (line) => {
        if (correctedLines[line])
          return true;
        correctedLines[line] = true;
        const rng = rangeForLine(line);
        const lineClean = isClean(line);
        if (rng < 0) {
          return true;
        }
        if (!lineClean) {
          removeLineFromRange(rng, line);
          return false;
        } else {
          const a = cleanRanges[rng][0];
          const b = cleanRanges[rng][1];
          let didSomething = false;
          if (a < line && isClean(line - 1) && !isConsecutive(line)) {
            splitRange(rng, line);
            didSomething = true;
          }
          if (b > line + 1 && isClean(line + 1) && !isConsecutive(line + 1)) {
            splitRange(rng, line + 1);
            didSomething = true;
          }
          return !didSomething;
        }
      };
      const detectChangesAroundLine = (line, reqInARow) => {
        let correctInARow = 0;
        let currentIndex = line;
        while (correctInARow < reqInARow && currentIndex >= 0) {
          if (correctlyAssignLine(currentIndex)) {
            correctInARow++;
          } else {
            correctInARow = 0;
          }
          currentIndex--;
        }
        correctInARow = 0;
        currentIndex = line;
        while (correctInARow < reqInARow && currentIndex < N) {
          if (correctlyAssignLine(currentIndex)) {
            correctInARow++;
          } else {
            correctInARow = 0;
          }
          currentIndex++;
        }
      };
      if (N === 0) {
        if (!isConsecutive(0)) {
          splitRange(0, 0);
        }
      } else {
        detectChangesAroundLine(0, 1);
        detectChangesAroundLine(N - 1, 1);
        for (const k of Object.keys(observedChanges.cleanNodesNearChanges)) {
          const key = k.substring(1);
          if (rep.lines.containsKey(key)) {
            const line = rep.lines.indexOfKey(key);
            detectChangesAroundLine(line, 2);
          }
        }
      }
      const dirtyRanges = [];
      for (let r = 0; r < cleanRanges.length - 1; r++) {
        dirtyRanges.push([cleanRanges[r][1], cleanRanges[r + 1][0]]);
      }
      return dirtyRanges;
    };
    const markNodeClean = (n) => {
      setAssoc(n, "dirtiness", { nodeId: uniqueId2(n), knownHTML: n.innerHTML });
    };
    const isNodeDirty = (n) => {
      if (n.parentNode !== targetBody)
        return true;
      const data = getAssoc(n, "dirtiness");
      if (!data)
        return true;
      if (n.id !== data.nodeId)
        return true;
      if (n.innerHTML !== data.knownHTML)
        return true;
      return false;
    };
    const handleClick = (evt) => {
      inCallStackIfNecessary("handleClick", () => {
        idleWorkTimer.atMost(200);
      });
      const isLink = (n) => (n.tagName || "").toLowerCase() === "a" && n.href;
      if (!evt.ctrlKey && evt.button !== 2 && evt.button !== 3) {
        let n = evt.target;
        while (n && n.parentNode && !isLink(n)) {
          n = n.parentNode;
        }
        if (n && isLink(n)) {
          try {
            window.open(n.href, "_blank", "noopener,noreferrer");
          } catch (e) {
          }
          evt.preventDefault();
        }
      }
      hideEditBarDropdowns();
    };
    const hideEditBarDropdowns = () => {
      window.parent.parent.padeditbar.toggleDropDown("none");
    };
    const renumberList = (lineNum) => {
      let type = getLineListType(lineNum);
      if (!type) {
        return null;
      }
      type = /([a-z]+)[0-9]+/.exec(type);
      if (type[1] === "indent") {
        return null;
      }
      while (lineNum - 1 >= 0 && (type = getLineListType(lineNum - 1))) {
        type = /([a-z]+)[0-9]+/.exec(type);
        if (type[1] === "indent")
          break;
        lineNum--;
      }
      const builder = Changeset2.builder(rep.lines.totalWidth());
      let loc = [0, 0];
      const applyNumberList = (line, level) => {
        let position = 1;
        let curLevel = level;
        let listType;
        while (listType = getLineListType(line)) {
          listType = /([a-z]+)([0-9]+)/.exec(listType);
          curLevel = Number(listType[2]);
          if (isNaN(curLevel) || listType[0] === "indent") {
            return line;
          } else if (curLevel === level) {
            ChangesetUtils2.buildKeepRange(rep, builder, loc, loc = [line, 0]);
            ChangesetUtils2.buildKeepRange(rep, builder, loc, loc = [line, 1], [
              ["start", position]
            ], rep.apool);
            position++;
            line++;
          } else if (curLevel < level) {
            return line;
          } else {
            line = applyNumberList(line, level + 1);
          }
        }
        return line;
      };
      applyNumberList(lineNum, 1);
      const cs = builder.toString();
      if (!Changeset2.isIdentity(cs)) {
        performDocumentApplyChangeset(cs);
      }
    };
    editorInfo.ace_renumberList = renumberList;
    const setLineListType = (lineNum, listType) => {
      if (listType === "") {
        documentAttributeManager.removeAttributeOnLine(lineNum, listAttributeName);
        documentAttributeManager.removeAttributeOnLine(lineNum, "start");
      } else {
        documentAttributeManager.setAttributeOnLine(lineNum, listAttributeName, listType);
      }
      if (renumberList(lineNum + 1) == null) {
        renumberList(lineNum);
      }
    };
    const doReturnKey = () => {
      if (!(rep.selStart && rep.selEnd)) {
        return;
      }
      const lineNum = rep.selStart[0];
      let listType = getLineListType(lineNum);
      if (listType) {
        const text = rep.lines.atIndex(lineNum).text;
        listType = /([a-z]+)([0-9]+)/.exec(listType);
        const type = listType[1];
        const level = Number(listType[2]);
        if (text === "*" && type !== "indent") {
          if (level > 1) {
            setLineListType(lineNum, type + (level - 1));
          } else {
            setLineListType(lineNum, "");
            renumberList(lineNum + 1);
          }
        } else if (lineNum + 1 <= rep.lines.length()) {
          performDocumentReplaceSelection("\n");
          setLineListType(lineNum + 1, type + level);
        }
      } else {
        performDocumentReplaceSelection("\n");
        handleReturnIndentation();
      }
    };
    editorInfo.ace_doReturnKey = doReturnKey;
    const doIndentOutdent = (isOut) => {
      if (!(rep.selStart && rep.selEnd || rep.selStart[0] === rep.selEnd[0] && rep.selStart[1] === rep.selEnd[1] && rep.selEnd[1] > 1) && isOut !== true) {
        return false;
      }
      const firstLine = rep.selStart[0];
      const lastLine = Math.max(firstLine, rep.selEnd[0] - (rep.selEnd[1] === 0 ? 1 : 0));
      const mods = [];
      for (let n = firstLine; n <= lastLine; n++) {
        let listType = getLineListType(n);
        let t = "indent";
        let level = 0;
        if (listType) {
          listType = /([a-z]+)([0-9]+)/.exec(listType);
          if (listType) {
            t = listType[1];
            level = Number(listType[2]);
          }
        }
        const newLevel = Math.max(0, Math.min(MAX_LIST_LEVEL, level + (isOut ? -1 : 1)));
        if (level !== newLevel) {
          mods.push([n, newLevel > 0 ? t + newLevel : ""]);
        }
      }
      for (const mod of mods)
        setLineListType(mod[0], mod[1]);
      return true;
    };
    editorInfo.ace_doIndentOutdent = doIndentOutdent;
    const doTabKey = (shiftDown) => {
      if (!doIndentOutdent(shiftDown)) {
        performDocumentReplaceSelection(THE_TAB);
      }
    };
    const doDeleteKey = (optEvt) => {
      const evt = optEvt || {};
      let handled = false;
      if (rep.selStart) {
        if (isCaret()) {
          const lineNum = caretLine();
          const col = caretColumn();
          const lineEntry = rep.lines.atIndex(lineNum);
          const lineText = lineEntry.text;
          const lineMarker = lineEntry.lineMarker;
          if (evt.metaKey && col > lineMarker) {
            performDocumentReplaceRange([lineNum, lineMarker], [lineNum, col], "");
            handled = true;
          } else if (/^ +$/.exec(lineText.substring(lineMarker, col))) {
            const col2 = col - lineMarker;
            const tabSize = THE_TAB.length;
            const toDelete = (col2 - 1) % tabSize + 1;
            performDocumentReplaceRange([lineNum, col - toDelete], [lineNum, col], "");
            handled = true;
          }
        }
        if (!handled) {
          if (isCaret()) {
            const theLine = caretLine();
            const lineEntry = rep.lines.atIndex(theLine);
            if (caretColumn() <= lineEntry.lineMarker) {
              const prevLineListType = theLine > 0 ? getLineListType(theLine - 1) : "";
              const thisLineListType = getLineListType(theLine);
              const prevLineEntry = theLine > 0 && rep.lines.atIndex(theLine - 1);
              const prevLineBlank = prevLineEntry && prevLineEntry.text.length === prevLineEntry.lineMarker;
              const thisLineHasMarker = documentAttributeManager.lineHasMarker(theLine);
              if (thisLineListType) {
                if (prevLineBlank && !prevLineListType) {
                  performDocumentReplaceRange(
                    [theLine - 1, prevLineEntry.text.length],
                    [theLine, 0],
                    ""
                  );
                } else {
                  performDocumentReplaceRange([theLine, 0], [theLine, lineEntry.lineMarker], "");
                }
              } else if (thisLineHasMarker && prevLineEntry) {
                performDocumentReplaceRange(
                  [theLine - 1, prevLineEntry.text.length],
                  [theLine, lineEntry.lineMarker],
                  ""
                );
              } else if (theLine > 0) {
                performDocumentReplaceRange(
                  [theLine - 1, prevLineEntry.text.length],
                  [theLine, 0],
                  ""
                );
              }
            } else {
              const docChar = caretDocChar();
              if (docChar > 0) {
                if (evt.metaKey || evt.ctrlKey || evt.altKey) {
                  let deleteBackTo = docChar - 1;
                  while (deleteBackTo > lineEntry.lineMarker && isWordChar(rep.alltext.charAt(deleteBackTo - 1))) {
                    deleteBackTo--;
                  }
                  performDocumentReplaceCharRange(deleteBackTo, docChar, "");
                } else {
                  performDocumentReplaceCharRange(docChar - 1, docChar, "");
                }
              }
            }
          } else {
            performDocumentReplaceSelection("");
          }
        }
      }
      const line = caretLine();
      if (line !== -1 && renumberList(line + 1) == null) {
        renumberList(line);
      }
    };
    const isWordChar = (c) => padutils.wordCharRegex.test(c);
    editorInfo.ace_isWordChar = isWordChar;
    const handleKeyEvent = (evt) => {
      if (!isEditable)
        return;
      const { type, charCode, keyCode, which, altKey, shiftKey } = evt;
      const isModKey = !charCode && (type === "keyup" || type === "keydown") && (keyCode === 16 || keyCode === 17 || keyCode === 18 || keyCode === 20 || keyCode === 224 || keyCode === 91);
      if (isModKey)
        return;
      if (keyCode === 13 && browser2.opera && type === "keypress") {
        return;
      }
      const isTypeForSpecialKey = browser2.safari || browser2.chrome || browser2.firefox ? type === "keydown" : type === "keypress";
      const isTypeForCmdKey = browser2.safari || browser2.chrome || browser2.firefox ? type === "keydown" : type === "keypress";
      let stopped = false;
      inCallStackIfNecessary("handleKeyEvent", function() {
        if (type === "keypress" || isTypeForSpecialKey && keyCode === 13) {
          if (!outsideKeyPress(evt)) {
            evt.preventDefault();
            stopped = true;
          }
        } else if (evt.key === "Dead") {
          stopped = true;
          return true;
        } else if (type === "keydown") {
          outsideKeyDown(evt);
        }
        let specialHandled = false;
        if (!stopped) {
          const specialHandledInHook = hooks$1.callAll("aceKeyEvent", {
            callstack: currentCallStack,
            editorInfo,
            rep,
            documentAttributeManager,
            evt
          });
          if (specialHandledInHook) {
            specialHandled = specialHandledInHook.indexOf(true) !== -1;
          }
          const padShortcutEnabled = parent.parent.clientVars.padShortcutEnabled;
          if (!specialHandled && isTypeForSpecialKey && altKey && keyCode === 120 && padShortcutEnabled.altF9) {
            const firstEditbarElement = parent.parent.$("#editbar").children("ul").first().children().first().children().first().children().first();
            $2(this).trigger("blur");
            firstEditbarElement.trigger("focus");
            evt.preventDefault();
          }
          if (!specialHandled && type === "keydown" && altKey && keyCode === 67 && padShortcutEnabled.altC) {
            $2(this).trigger("blur");
            parent.parent.chat.show();
            parent.parent.$("#chatinput").trigger("focus");
            evt.preventDefault();
          }
          if (!specialHandled && type === "keydown" && evt.ctrlKey && shiftKey && keyCode === 50 && padShortcutEnabled.cmdShift2) {
            const lineNumber = rep.selEnd[0];
            const alineAttrs = rep.alines[lineNumber];
            const apool = rep.apool;
            const authorIds = /* @__PURE__ */ new Set();
            if (alineAttrs) {
              for (const op of Changeset2.deserializeOps(alineAttrs)) {
                const authorId = AttributeMap.fromString(op.attribs, apool).get("author");
                if (authorId)
                  authorIds.add(authorId);
              }
            }
            const idToName = new Map(parent.parent.pad.userList().map((a) => [a.userId, a.name]));
            const myId = parent.parent.clientVars.userId;
            const authors = [...authorIds].map((id) => id === myId ? "me" : idToName.get(id) || "unknown");
            parent.parent.$.gritter.add({
              title: "Line Authors",
              text: authors.length === 0 ? "No author information is available" : authors.length === 1 ? `The author of this line is ${authors[0]}` : `The authors of this line are ${authors.join(" & ")}`,
              sticky: false,
              time: "4000"
            });
          }
          if (!specialHandled && isTypeForSpecialKey && keyCode === 8 && padShortcutEnabled.delete) {
            fastIncorp();
            evt.preventDefault();
            doDeleteKey(evt);
            specialHandled = true;
          }
          if (!specialHandled && isTypeForSpecialKey && keyCode === 13 && padShortcutEnabled.return) {
            fastIncorp();
            evt.preventDefault();
            doReturnKey();
            scheduler.setTimeout(() => {
              outerWin.scrollBy(-100, 0);
            }, 0);
            specialHandled = true;
          }
          if (!specialHandled && isTypeForSpecialKey && keyCode === 27 && padShortcutEnabled.esc) {
            fastIncorp();
            evt.preventDefault();
            specialHandled = true;
            parent.parent.$.gritter.removeAll();
          }
          if (!specialHandled && isTypeForCmdKey && /* Do a saved revision on ctrl S */
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "s" && !evt.altKey && padShortcutEnabled.cmdS) {
            evt.preventDefault();
            const originalBackground = parent.parent.$("#revisionlink").css("background");
            parent.parent.$("#revisionlink").css({ background: "lightyellow" });
            scheduler.setTimeout(() => {
              parent.parent.$("#revisionlink").css({ background: originalBackground });
            }, 1e3);
            parent.parent.pad.collabClient.sendMessage({ type: "SAVE_REVISION" });
            specialHandled = true;
          }
          if (!specialHandled && isTypeForSpecialKey && // tab
          keyCode === 9 && !(evt.metaKey || evt.ctrlKey) && padShortcutEnabled.tab) {
            fastIncorp();
            evt.preventDefault();
            doTabKey(evt.shiftKey);
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-Z (undo)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "z" && !evt.altKey && padShortcutEnabled.cmdZ) {
            fastIncorp();
            evt.preventDefault();
            if (evt.shiftKey) {
              doUndoRedo("redo");
            } else {
              doUndoRedo("undo");
            }
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-Y (redo)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "y" && padShortcutEnabled.cmdY) {
            fastIncorp();
            evt.preventDefault();
            doUndoRedo("redo");
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-B (bold)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "b" && padShortcutEnabled.cmdB) {
            fastIncorp();
            evt.preventDefault();
            toggleAttributeOnSelection("bold");
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-I (italic)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "i" && padShortcutEnabled.cmdI) {
            fastIncorp();
            evt.preventDefault();
            toggleAttributeOnSelection("italic");
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-U (underline)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "u" && padShortcutEnabled.cmdU) {
            fastIncorp();
            evt.preventDefault();
            toggleAttributeOnSelection("underline");
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-5 (strikethrough)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "5" && evt.altKey !== true && padShortcutEnabled.cmd5) {
            fastIncorp();
            evt.preventDefault();
            toggleAttributeOnSelection("strikethrough");
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-shift-L (unorderedlist)
          (evt.metaKey || evt.ctrlKey) && String.fromCharCode(which).toLowerCase() === "l" && evt.shiftKey && padShortcutEnabled.cmdShiftL) {
            fastIncorp();
            evt.preventDefault();
            doInsertUnorderedList();
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-shift-N and cmd-shift-1 (orderedlist)
          (evt.metaKey || evt.ctrlKey) && evt.shiftKey && (String.fromCharCode(which).toLowerCase() === "n" && padShortcutEnabled.cmdShiftN || String.fromCharCode(which) === "1" && padShortcutEnabled.cmdShift1)) {
            fastIncorp();
            evt.preventDefault();
            doInsertOrderedList();
            specialHandled = true;
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-shift-C (clearauthorship)
          (evt.metaKey || evt.ctrlKey) && evt.shiftKey && String.fromCharCode(which).toLowerCase() === "c" && padShortcutEnabled.cmdShiftC) {
            fastIncorp();
            evt.preventDefault();
            CMDS.clearauthorship();
          }
          if (!specialHandled && isTypeForCmdKey && // cmd-H (backspace)
          evt.ctrlKey && String.fromCharCode(which).toLowerCase() === "h" && padShortcutEnabled.cmdH) {
            fastIncorp();
            evt.preventDefault();
            doDeleteKey();
            specialHandled = true;
          }
          if (evt.ctrlKey === true && evt.which === 36 && // Control Home send to Y = 0
          padShortcutEnabled.ctrlHome) {
            scroll2.setScrollY(0);
          }
          if ((evt.which === 33 || evt.which === 34) && type === "keydown" && !evt.ctrlKey) {
            evt.preventDefault();
            const oldVisibleLineRange = scroll2.getVisibleLineRange(rep);
            rep.selStart[0] - oldVisibleLineRange[0];
            const isPageDown = evt.which === 34;
            const isPageUp = evt.which === 33;
            scheduler.setTimeout(() => {
              const newVisibleLineRange = scroll2.getVisibleLineRange(rep);
              const linesCount = rep.lines.length();
              const numberOfLinesInViewport = newVisibleLineRange[1] - newVisibleLineRange[0];
              if (isPageUp && padShortcutEnabled.pageUp) {
                rep.selEnd[0] -= numberOfLinesInViewport;
                rep.selStart[0] -= numberOfLinesInViewport;
              }
              if (isPageDown && padShortcutEnabled.pageDown) {
                if (rep.selEnd[0] >= oldVisibleLineRange[0]) {
                  rep.selStart[0] = oldVisibleLineRange[1] - 1;
                  rep.selEnd[0] = oldVisibleLineRange[1] - 1;
                }
              }
              if (rep.selEnd[0] < 0) {
                rep.selEnd[0] = 0;
              }
              if (rep.selStart[0] < 0) {
                rep.selStart[0] = 0;
              }
              if (rep.selEnd[0] >= linesCount) {
                rep.selEnd[0] = linesCount - 1;
              }
              updateBrowserSelectionFromRep();
              const myselection = targetDoc.getSelection();
              let caretOffsetTop = myselection.focusNode.parentNode.offsetTop || myselection.focusNode.offsetTop;
              if (caretOffsetTop === -1)
                caretOffsetTop = myselection.focusNode.offsetTop;
              scroll2.setScrollY(caretOffsetTop);
            }, 200);
          }
        }
        if (type === "keydown") {
          idleWorkTimer.atLeast(500);
        } else if (type === "keypress") {
          if (!specialHandled) {
            idleWorkTimer.atMost(0);
          } else {
            idleWorkTimer.atLeast(500);
          }
        } else if (type === "keyup") {
          const wait = 0;
          idleWorkTimer.atLeast(wait);
          idleWorkTimer.atMost(wait);
        }
        const isFirefoxHalfCharacter = browser2.firefox && evt.altKey && charCode === 0 && keyCode === 0;
        const isSafariHalfCharacter = browser2.safari && evt.altKey && keyCode === 229;
        if (thisKeyDoesntTriggerNormalize || isFirefoxHalfCharacter || isSafariHalfCharacter) {
          idleWorkTimer.atLeast(3e3);
          thisKeyDoesntTriggerNormalize = true;
        }
        if (!specialHandled && !thisKeyDoesntTriggerNormalize && !inInternationalComposition && type !== "keyup") {
          observeChangesAroundSelection();
        }
        if (type === "keyup") {
          thisKeyDoesntTriggerNormalize = false;
        }
      });
    };
    let thisKeyDoesntTriggerNormalize = false;
    const doUndoRedo = (which) => {
      if (undoModule.enabled) {
        let whichMethod;
        if (which === "undo")
          whichMethod = "performUndo";
        if (which === "redo")
          whichMethod = "performRedo";
        if (whichMethod) {
          const oldEventType = currentCallStack.editEvent.eventType;
          currentCallStack.startNewEvent(which);
          undoModule[whichMethod]((backset, selectionInfo) => {
            if (backset) {
              performDocumentApplyChangeset(backset);
            }
            if (selectionInfo) {
              performSelectionChange(
                lineAndColumnFromChar(selectionInfo.selStart),
                lineAndColumnFromChar(selectionInfo.selEnd),
                selectionInfo.selFocusAtStart
              );
            }
            const oldEvent = currentCallStack.startNewEvent(oldEventType, true);
            return oldEvent;
          });
        }
      }
    };
    editorInfo.ace_doUndoRedo = doUndoRedo;
    const setSelection = (selection) => {
      const copyPoint = (pt) => ({
        node: pt.node,
        index: pt.index,
        maxIndex: pt.maxIndex
      });
      let isCollapsed;
      const pointToRangeBound = (pt) => {
        const p = copyPoint(pt);
        if (isCollapsed) {
          const diveDeep = () => {
            while (p.node.childNodes.length > 0) {
              if (p.index === 0) {
                p.node = p.node.firstChild;
                p.maxIndex = nodeMaxIndex(p.node);
              } else if (p.index === p.maxIndex) {
                p.node = p.node.lastChild;
                p.maxIndex = nodeMaxIndex(p.node);
                p.index = p.maxIndex;
              } else {
                break;
              }
            }
          };
          if (isNodeText(p.node) && p.index === p.maxIndex) {
            let n = p.node;
            while (!n.nextSibling && n !== targetBody && n.parentNode !== targetBody) {
              n = n.parentNode;
            }
            if (n.nextSibling && !(typeof n.nextSibling.tagName === "string" && n.nextSibling.tagName.toLowerCase() === "br") && n !== p.node && n !== targetBody && n.parentNode !== targetBody) {
              p.node = n.nextSibling;
              p.maxIndex = nodeMaxIndex(p.node);
              p.index = 0;
              diveDeep();
            }
          }
          if (!isNodeText(p.node)) {
            diveDeep();
          }
        }
        if (isNodeText(p.node)) {
          return {
            container: p.node,
            offset: p.index
          };
        } else {
          return {
            container: p.node.parentNode,
            offset: childIndex(p.node) + p.index
          };
        }
      };
      const browserSelection = window.getSelection();
      if (browserSelection) {
        browserSelection.removeAllRanges();
        if (selection) {
          isCollapsed = selection.startPoint.node === selection.endPoint.node && selection.startPoint.index === selection.endPoint.index;
          const start = pointToRangeBound(selection.startPoint);
          const end = pointToRangeBound(selection.endPoint);
          if (!isCollapsed && selection.focusAtStart && browserSelection.collapse && browserSelection.extend) {
            browserSelection.collapse(end.container, end.offset);
            browserSelection.extend(start.container, start.offset);
          } else {
            const range2 = targetDoc.createRange();
            range2.setStart(start.container, start.offset);
            range2.setEnd(end.container, end.offset);
            browserSelection.removeAllRanges();
            browserSelection.addRange(range2);
          }
        }
      }
    };
    const updateBrowserSelectionFromRep = () => {
      const selStart = rep.selStart;
      const selEnd = rep.selEnd;
      if (!(selStart && selEnd)) {
        setSelection(null);
        return;
      }
      const selection = {};
      const ss = [selStart[0], selStart[1]];
      selection.startPoint = getPointForLineAndChar(ss);
      const se = [selEnd[0], selEnd[1]];
      selection.endPoint = getPointForLineAndChar(se);
      selection.focusAtStart = !!rep.selFocusAtStart;
      setSelection(selection);
    };
    editorInfo.ace_updateBrowserSelectionFromRep = updateBrowserSelectionFromRep;
    editorInfo.ace_focus = focus;
    editorInfo.ace_importText = importText;
    editorInfo.ace_importAText = importAText;
    editorInfo.ace_exportText = exportText;
    editorInfo.ace_editorChangedSize = editorChangedSize;
    editorInfo.ace_setOnKeyPress = setOnKeyPress;
    editorInfo.ace_setOnKeyDown = setOnKeyDown;
    editorInfo.ace_setNotifyDirty = setNotifyDirty;
    editorInfo.ace_dispose = dispose;
    editorInfo.ace_setEditable = setEditable;
    editorInfo.ace_execCommand = execCommand;
    editorInfo.ace_replaceRange = replaceRange;
    editorInfo.ace_getAuthorInfos = getAuthorInfos;
    editorInfo.ace_performDocumentReplaceRange = performDocumentReplaceRange;
    editorInfo.ace_performDocumentReplaceCharRange = performDocumentReplaceCharRange;
    editorInfo.ace_setSelection = setSelection;
    const nodeMaxIndex = (nd) => {
      if (isNodeText(nd))
        return nd.nodeValue.length;
      else
        return 1;
    };
    const getSelection = () => {
      const browserSelection = window.getSelection();
      if (!browserSelection || browserSelection.type === "None" || browserSelection.rangeCount === 0) {
        return null;
      }
      const range2 = browserSelection.getRangeAt(0);
      const isInBody = (n) => {
        while (n && !(n.tagName && n.tagName.toLowerCase() === "body")) {
          n = n.parentNode;
        }
        return !!n;
      };
      const pointFromRangeBound = (container, offset) => {
        if (!isInBody(container)) {
          return {
            node: targetBody,
            index: 0,
            maxIndex: 1
          };
        }
        const n = container;
        const childCount = n.childNodes.length;
        if (isNodeText(n)) {
          return {
            node: n,
            index: offset,
            maxIndex: n.nodeValue.length
          };
        } else if (childCount === 0) {
          return {
            node: n,
            index: 0,
            maxIndex: 1
          };
        } else if (offset === childCount) {
          const nd = n.childNodes.item(childCount - 1);
          const max2 = nodeMaxIndex(nd);
          return {
            node: nd,
            index: max2,
            maxIndex: max2
          };
        } else {
          const nd = n.childNodes.item(offset);
          const max2 = nodeMaxIndex(nd);
          return {
            node: nd,
            index: 0,
            maxIndex: max2
          };
        }
      };
      const selection = {
        startPoint: pointFromRangeBound(range2.startContainer, range2.startOffset),
        endPoint: pointFromRangeBound(range2.endContainer, range2.endOffset),
        focusAtStart: (range2.startContainer !== range2.endContainer || range2.startOffset !== range2.endOffset) && browserSelection.anchorNode && browserSelection.anchorNode === range2.endContainer && browserSelection.anchorOffset === range2.endOffset
      };
      if (selection.startPoint.node.ownerDocument !== window.document) {
        return null;
      }
      return selection;
    };
    const childIndex = (n) => {
      let idx = 0;
      while (n.previousSibling) {
        idx++;
        n = n.previousSibling;
      }
      return idx;
    };
    const fixView = () => {
      if (getInnerWidth() === 0 || getInnerHeight() === 0) {
        return;
      }
      enforceEditability();
      $2(sideDiv).addClass("sidedivdelayed");
    };
    const _teardownActions = [];
    const teardown = () => {
      for (const a of _teardownActions)
        a();
    };
    let inInternationalComposition = null;
    editorInfo.ace_getInInternationalComposition = () => inInternationalComposition;
    const bindTheEventHandlers = () => {
      $2(document).on("keydown", handleKeyEvent);
      $2(document).on("keypress", handleKeyEvent);
      $2(document).on("keyup", handleKeyEvent);
      $2(document).on("click", handleClick);
      $2(outerDoc).on("click", hideEditBarDropdowns);
      let suppressPasteOnLink = null;
      $2(targetBody).on("auxclick", (e) => {
        if (e.originalEvent.button === 1 && (e.target.a || e.target.localName === "a")) {
          suppressPasteOnLink = scheduler.setTimeout(() => {
            suppressPasteOnLink = null;
          }, 0);
        }
      });
      $2(targetBody).on("paste", (e) => {
        if (suppressPasteOnLink != null && (e.target.a || e.target.localName === "a")) {
          scheduler.clearTimeout(suppressPasteOnLink);
          suppressPasteOnLink = null;
          e.preventDefault();
          return;
        }
        hooks$1.callAll("acePaste", {
          editorInfo,
          rep,
          documentAttributeManager,
          e
        });
      });
      $2(document).on("drop", (e) => {
        if (e.target.a || e.target.localName === "a") {
          e.preventDefault();
        }
        const selection = getSelection();
        if (selection) {
          const firstLineSelected = topLevel(selection.startPoint.node);
          const lastLineSelected = topLevel(selection.endPoint.node);
          const lineBeforeSelection = firstLineSelected.previousSibling;
          const lineAfterSelection = lastLineSelected.nextSibling;
          const neighbor = lineBeforeSelection || lineAfterSelection;
          neighbor.appendChild(targetDoc.createElement("style"));
        }
        hooks$1.callAll("aceDrop", {
          editorInfo,
          rep,
          documentAttributeManager,
          e
        });
      });
      $2(document.documentElement).on("compositionstart", () => {
        if (inInternationalComposition)
          return;
        inInternationalComposition = new Promise((resolve) => {
          $2(document.documentElement).one("compositionend", () => {
            inInternationalComposition = null;
            resolve();
          });
        });
      });
    };
    const topLevel = (n) => {
      if (!n || n === targetBody)
        return null;
      while (n.parentNode !== targetBody) {
        n = n.parentNode;
      }
      return n;
    };
    const getSelectionPointX = (point) => {
      const node = point.node;
      const index = point.index;
      const leftOf = (n) => n.offsetLeft;
      const rightOf = (n) => n.offsetLeft + n.offsetWidth;
      if (!isNodeText(node)) {
        if (index === 0)
          return leftOf(node);
        else
          return rightOf(node);
      } else {
        let charsToLeft = index;
        let charsToRight = node.nodeValue.length - index;
        let n;
        for (n = node.previousSibling; n && isNodeText(n); n = n.previousSibling) {
          charsToLeft += n.nodeValue;
        }
        const leftEdge = n ? rightOf(n) : leftOf(node.parentNode);
        for (n = node.nextSibling; n && isNodeText(n); n = n.nextSibling)
          charsToRight += n.nodeValue;
        const rightEdge = n ? leftOf(n) : rightOf(node.parentNode);
        const frac = charsToLeft / (charsToLeft + charsToRight);
        const pixLoc = leftEdge + frac * (rightEdge - leftEdge);
        return Math.round(pixLoc);
      }
    };
    const getInnerHeight = () => {
      const h = browser2.opera ? outerWin.innerHeight : outerDoc.documentElement.clientHeight;
      if (h)
        return h;
      return Number(editorInfo.frame.parentNode.style.height.replace(/[^0-9]/g, "") || 0);
    };
    const getInnerWidth = () => outerDoc.documentElement.clientWidth;
    const scrollXHorizontallyIntoView = (pixelX) => {
      const distInsideLeft = pixelX - outerWin.scrollX;
      const distInsideRight = outerWin.scrollX + getInnerWidth() - pixelX;
      if (distInsideLeft < 0) {
        outerWin.scrollBy(distInsideLeft, 0);
      } else if (distInsideRight < 0) {
        outerWin.scrollBy(-distInsideRight + 1, 0);
      }
    };
    const scrollSelectionIntoView = () => {
      if (!rep.selStart)
        return;
      fixView();
      const innerHeight = getInnerHeight();
      scroll2.scrollNodeVerticallyIntoView(rep, innerHeight);
      if (!doesWrap) {
        const browserSelection = getSelection();
        if (browserSelection) {
          const focusPoint = browserSelection.focusAtStart ? browserSelection.startPoint : browserSelection.endPoint;
          const selectionPointX = getSelectionPointX(focusPoint);
          scrollXHorizontallyIntoView(selectionPointX);
          fixView();
        }
      }
    };
    const listAttributeName = "list";
    const getLineListType = (lineNum) => documentAttributeManager.getAttributeOnLine(lineNum, listAttributeName);
    editorInfo.ace_getLineListType = getLineListType;
    const doInsertList = (type) => {
      if (!(rep.selStart && rep.selEnd)) {
        return;
      }
      const firstLine = rep.selStart[0];
      const lastLine = Math.max(firstLine, rep.selEnd[0] - (rep.selEnd[1] === 0 ? 1 : 0));
      let allLinesAreList = true;
      for (let n = firstLine; n <= lastLine; n++) {
        const listType = getLineListType(n);
        if (!listType || listType.slice(0, type.length) !== type) {
          allLinesAreList = false;
          break;
        }
      }
      const mods = [];
      for (let n = firstLine; n <= lastLine; n++) {
        let level = 0;
        let togglingOn = true;
        const listType = /([a-z]+)([0-9]+)/.exec(getLineListType(n));
        if (allLinesAreList) {
          togglingOn = false;
        }
        if (listType) {
          level = Number(listType[2]);
        }
        const t = getLineListType(n);
        if (t === listType)
          togglingOn = false;
        if (togglingOn) {
          mods.push([n, allLinesAreList ? `indent${level}` : t ? type + level : `${type}1`]);
        } else {
          if (level === 1) {
            setLineListType(n, "");
          }
          if (level > 1) {
            setLineListType(n, "");
            setLineListType(n, `indent${level}`);
          }
        }
      }
      for (const mod of mods)
        setLineListType(mod[0], mod[1]);
    };
    const doInsertUnorderedList = () => {
      doInsertList("bullet");
    };
    const doInsertOrderedList = () => {
      doInsertList("number");
    };
    editorInfo.ace_doInsertUnorderedList = doInsertUnorderedList;
    editorInfo.ace_doInsertOrderedList = doInsertOrderedList;
    const updateLineNumbers = () => {
      const lineOffsets = [];
      const lineHeights = [];
      const innerdocbodyStyles = getComputedStyle(targetBody);
      const defaultLineHeight = parseInt(innerdocbodyStyles["line-height"]);
      for (const docLine of targetBody.children) {
        let h;
        const nextDocLine = docLine.nextElementSibling;
        if (nextDocLine) {
          if (lineOffsets.length === 0) {
            h = nextDocLine.offsetTop - parseInt(
              window.getComputedStyle(targetBody).getPropertyValue("padding-top").split("px")[0]
            );
          } else {
            h = nextDocLine.offsetTop - docLine.offsetTop;
          }
        } else {
          h = docLine.clientHeight || docLine.offsetHeight;
        }
        lineOffsets.push(h);
        if (docLine.clientHeight !== defaultLineHeight) {
          const elementStyle = window.getComputedStyle(docLine.firstChild);
          const lineHeight = parseInt(elementStyle.getPropertyValue("line-height"));
          const marginBottom = parseInt(elementStyle.getPropertyValue("margin-bottom"));
          lineHeights.push(lineHeight + marginBottom);
        } else {
          lineHeights.push(defaultLineHeight);
        }
      }
      let newNumLines = rep.lines.length();
      if (newNumLines < 1)
        newNumLines = 1;
      while (sideDivInner.children.length < newNumLines)
        appendNewSideDivLine();
      while (sideDivInner.children.length > newNumLines)
        sideDivInner.lastElementChild.remove();
      for (const [i, sideDivLine] of Array.prototype.entries.call(sideDivInner.children)) {
        sideDivLine.style.height = `${lineOffsets[i]}px`;
        sideDivLine.style.lineHeight = `${lineHeights[i]}px`;
      }
    };
    documentAttributeManager = new AttributeManager(rep, performDocumentApplyChangeset);
    editorInfo.ace_performDocumentApplyAttributesToRange = (...args) => documentAttributeManager.setAttributesOnRange(...args);
    this.init = async () => {
      await $2.ready;
      inCallStack("setup", () => {
        if (browser2.firefox)
          $2(targetBody).addClass("mozilla");
        if (browser2.safari)
          $2(targetBody).addClass("safari");
        targetBody.classList.toggle("authorColors", true);
        targetBody.classList.toggle("doesWrap", doesWrap);
        enforceEditability();
        while (targetBody.firstChild)
          targetBody.removeChild(targetBody.firstChild);
        const oneEntry = createDomLineEntry("");
        doRepLineSplice(0, rep.lines.length(), [oneEntry]);
        insertDomLines(null, [oneEntry.domInfo]);
        rep.alines = Changeset2.splitAttributionLines(
          Changeset2.makeAttribution("\n"),
          "\n"
        );
        bindTheEventHandlers();
      });
      hooks$1.callAll("aceInitialized", {
        editorInfo,
        rep,
        documentAttributeManager
      });
    };
  }
  ace2_inner.init = async (editorInfo, cssManagers) => {
    const editor = new Ace2Inner(editorInfo, cssManagers);
    await editor.init();
  };
  return ace2_inner;
}
var require2 = (
  /* eslint-disable strict */
  (() => {
    let main = null;
    const modules = {};
    const definitions = {};
    const loadingModules = {};
    const definitionWaiters = {};
    const fetchRequests = [];
    let currentRequests = 0;
    let maximumRequests = 2;
    const deferred = [];
    let deferredScheduled = false;
    let syncLock = void 0;
    let globalKeyPath = void 0;
    let rootURI = void 0;
    let libraryURI = void 0;
    let libraryLookupComponent = void 0;
    const JSONP_TIMEOUT = 60 * 1e3;
    function CircularDependencyError(message) {
      this.name = "CircularDependencyError";
      this.message = message;
    }
    CircularDependencyError.prototype = Error.prototype;
    function ArgumentError(message) {
      this.name = "ArgumentError";
      this.message = message;
    }
    ArgumentError.prototype = Error.prototype;
    const hasOwnProperty2 = (object2, key) => Object.prototype.hasOwnProperty.call(object2, key);
    const defer2 = (...fns) => deferred.push(...fns);
    const _flushDefer = () => {
      try {
        while (deferred.length) {
          const continuation = deferred.shift();
          continuation();
        }
        deferredScheduled = false;
      } finally {
        deferredScheduled = deferred.length > 0;
        deferred.length && setTimeout(_flushDefer, 0);
      }
    };
    const flushDefer = () => {
      if (!deferredScheduled && deferred.length > 0) {
        if (syncLock) {
          deferredScheduled = true;
          setTimeout(_flushDefer, 0);
        } else {
          _flushDefer();
        }
      }
    };
    const flushDeferAfter = (f) => {
      try {
        deferredScheduled = true;
        f();
        deferredScheduled = false;
        flushDefer();
      } finally {
        deferredScheduled = false;
        deferred.length && setTimeout(flushDefer, 0);
      }
    };
    const normalizePath = (path) => {
      const pathComponents1 = path.split("/");
      const pathComponents2 = [];
      let component;
      for (let i = 0, ii = pathComponents1.length; i < ii; i++) {
        component = pathComponents1[i];
        switch (component) {
          case "":
            if (i === 0 || i === ii - 1) {
              pathComponents2.push(component);
            }
            break;
          case ".":
            break;
          case "..":
            if (pathComponents2.length > 1 || pathComponents2.length === 1 && pathComponents2[0] !== "" && pathComponents2[0] !== ".") {
              pathComponents2.pop();
              break;
            }
          default:
            pathComponents2.push(component);
        }
      }
      return pathComponents2.join("/");
    };
    const fullyQualifyPath = (path, basePath) => {
      let fullyQualifiedPath = path;
      if (path.charAt(0) === "." && (path.charAt(1) === "/" || path.charAt(1) === "." && path.charAt(2) === "/")) {
        if (!basePath) {
          basePath = "";
        } else if (basePath.charAt(basePath.length - 1) !== "/") {
          basePath += "/";
        }
        fullyQualifiedPath = basePath + path;
      }
      return fullyQualifiedPath;
    };
    const setRootURI = (URI) => {
      if (!URI) {
        throw new ArgumentError("Invalid root URI.");
      }
      rootURI = URI.charAt(URI.length - 1) === "/" ? URI.slice(0, -1) : URI;
    };
    const setLibraryURI = (URI) => {
      libraryURI = URI.charAt(URI.length - 1) === "/" ? URI : `${URI}/`;
    };
    const setLibraryLookupComponent = (component) => {
      component = component && component.toString();
      if (!component) {
        libraryLookupComponent = void 0;
      } else if (component.match(/\//)) {
        throw new ArgumentError("Invalid path component.");
      } else {
        libraryLookupComponent = component;
      }
    };
    const searchPathsForModulePath = (path, basePath) => {
      path = normalizePath(path);
      if (path.charAt(0) !== "/" && libraryLookupComponent) {
        const paths = [];
        const components = basePath.split("/");
        while (components.length > 1) {
          if (components[components.length - 1] === libraryLookupComponent) {
            components.pop();
          }
          const searchPath = normalizePath(fullyQualifyPath(
            `./${libraryLookupComponent}/${path}`,
            `${components.join("/")}/`
          ));
          paths.push(searchPath);
          components.pop();
        }
        paths.push(path);
        return paths;
      } else {
        return [normalizePath(fullyQualifyPath(path, basePath))];
      }
    };
    const uriForModulePath = (path) => {
      const components = path.split("/");
      for (let i = 0, ii = components.length; i < ii; i++) {
        components[i] = encodeURIComponent(components[i]);
      }
      path = components.join("/");
      if (path.charAt(0) === "/") {
        if (!rootURI) {
          throw new Error(
            `Attempt to retrieve the root module "${path}" but no root URI is defined.`
          );
        }
        return rootURI + path;
      } else {
        if (!libraryURI) {
          throw new Error(
            `Attempt to retrieve the library module "${path}" but no libary URI is defined.`
          );
        }
        return libraryURI + path;
      }
    };
    const stackDecorator = (name) => ({ [name]: (f) => f() })[name];
    const compileFunction = (name, ...args) => {
      const f = Function.bind(null, ...args);
      return stackDecorator(name)(f);
    };
    const setRequestMaximum = (value) => {
      value = parseInt(value);
      if (value > 0) {
        maximumRequests = value;
        checkScheduledfetchDefines();
      } else {
        throw new ArgumentError("Value must be a positive integer.");
      }
    };
    const setGlobalKeyPath = (value) => {
      globalKeyPath = value;
    };
    let randomVersionString = null;
    const getRandomVersionString = () => {
      if (typeof window === "undefined")
        return null;
      for (let win = window; randomVersionString == null; win = win.parent) {
        ({ clientVars: { randomVersionString } = {} } = win);
        if (win === window.top)
          break;
      }
      return randomVersionString;
    };
    const getXHR = (uri, async, callback) => {
      if (getRandomVersionString()) {
        uri += `&v=${getRandomVersionString()}`;
      }
      const request = new XMLHttpRequest();
      const onComplete = (request2) => {
        if (request2.status === 200) {
          callback(void 0, request2.responseText);
        } else {
          callback(true, void 0);
        }
      };
      request.open("GET", uri, !!async);
      if (async) {
        request.onreadystatechange = (event) => {
          if (request.readyState === 4) {
            onComplete(request);
          }
        };
        request.send(null);
      } else {
        request.send(null);
        onComplete(request);
      }
    };
    const fetchDefineXHR = (path, async) => {
      const _globalKeyPath = globalKeyPath;
      const callback = (error, text) => {
        if (error) {
          define(path, null);
        } else if (_globalKeyPath) {
          compileFunction(`(bundle ${path})`, text)();
        } else {
          const def = compileFunction(`(module ${path})`, "require", "exports", "module", text);
          define(path, def);
        }
      };
      let uri = uriForModulePath(path);
      if (_globalKeyPath) {
        uri += `?callback=${encodeURIComponent(`${globalKeyPath}.define`)}`;
      }
      getXHR(uri, async, callback);
    };
    const fetchDefineJSONP = (path) => {
      const head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
      const script = document.createElement("script");
      if (script.async !== void 0) {
        script.async = "true";
      } else {
        script.defer = "true";
      }
      script.type = "application/javascript";
      script.src = `${uriForModulePath(path)}?callback=${encodeURIComponent(globalKeyPath)}.define`;
      if (JSONP_TIMEOUT < Infinity) {
        const timeoutId = setTimeout(() => define(path, null), JSONP_TIMEOUT);
        definitionWaiters[path].unshift(() => clearTimeout(timeoutId));
      }
      head.insertBefore(script, head.firstChild);
    };
    const fetchModule = (path, continuation) => {
      if (hasOwnProperty2(definitionWaiters, path)) {
        definitionWaiters[path].push(continuation);
      } else {
        definitionWaiters[path] = [continuation];
        schedulefetchDefine(path);
      }
    };
    const schedulefetchDefine = (path) => {
      fetchRequests.push(path);
      checkScheduledfetchDefines();
    };
    const checkScheduledfetchDefines = () => {
      if (fetchRequests.length > 0 && currentRequests < maximumRequests) {
        const fetchRequest = fetchRequests.pop();
        currentRequests++;
        definitionWaiters[fetchRequest].unshift(() => {
          currentRequests--;
          checkScheduledfetchDefines();
        });
        if (globalKeyPath && typeof document !== "undefined" && document.readyState && /^loaded|complete$/.test(document.readyState)) {
          fetchDefineJSONP(fetchRequest);
        } else {
          fetchDefineXHR(fetchRequest, true);
        }
      }
    };
    const fetchModuleSync = (path, continuation) => {
      fetchDefineXHR(path, false);
      continuation();
    };
    const moduleIsLoaded = (path) => hasOwnProperty2(modules, path);
    const loadModule = (path, continuation) => {
      if (!moduleIsLoaded(path)) {
        if (hasOwnProperty2(loadingModules, path)) {
          throw new CircularDependencyError("Encountered circular dependency.");
        } else if (!moduleIsDefined(path)) {
          throw new Error("Attempt to load undefined module.");
        } else if (definitions[path] === null) {
          continuation(null);
        } else {
          const definition = definitions[path];
          const _module = { id: path, exports: {} };
          const _require = requireRelativeTo(path);
          if (!main) {
            main = _module;
          }
          try {
            loadingModules[path] = true;
            definition(_require, _module.exports, _module);
            modules[path] = _module;
            delete loadingModules[path];
            continuation(_module);
          } finally {
            delete loadingModules[path];
          }
        }
      } else {
        const module = modules[path];
        continuation(module);
      }
    };
    const _moduleAtPath = (path, fetchFunc, continuation) => {
      const suffixes = path.endsWith(".js") ? [""] : path.endsWith("/") ? ["index.js"] : [".js", "/index.js", ""];
      const ii = suffixes.length;
      const _find = (i) => {
        if (i < ii) {
          const path_ = path + suffixes[i];
          const after2 = () => {
            loadModule(path_, (module) => {
              if (module === null) {
                _find(i + 1);
              } else {
                continuation(module);
              }
            });
          };
          if (!moduleIsDefined(path_)) {
            fetchFunc(path_, after2);
          } else {
            after2();
          }
        } else {
          continuation(null);
        }
      };
      _find(0);
    };
    const moduleAtPath = (path, continuation) => {
      defer2(() => {
        _moduleAtPath(path, fetchModule, continuation);
      });
    };
    const moduleAtPathSync = (path) => {
      let module;
      const oldSyncLock = syncLock;
      syncLock = true;
      if (path === "async") {
        path = "async/lib/async";
      }
      if (path === "underscore") {
        path = "underscore/underscore";
      }
      if (path === "unorm") {
        path = "unorm/lib/unorm";
      }
      try {
        _moduleAtPath(path, fetchModuleSync, (_module) => {
          module = _module;
        });
      } finally {
        syncLock = oldSyncLock;
      }
      return module;
    };
    const moduleIsDefined = (path) => hasOwnProperty2(definitions, path);
    const defineModule = (path, module) => {
      if (typeof path !== "string" || !(typeof module === "function" || module === null)) {
        throw new ArgumentError("Definition must be a (string, function) pair.");
      }
      if (moduleIsDefined(path))
        ;
      else {
        definitions[path] = module;
      }
    };
    const defineModules = (moduleMap) => {
      if (typeof moduleMap !== "object") {
        throw new ArgumentError("Mapping must be an object.");
      }
      for (const path in moduleMap) {
        if (hasOwnProperty2(moduleMap, path)) {
          defineModule(path, moduleMap[path]);
        }
      }
    };
    const define = (...args) => {
      let moduleMap;
      if (args.length === 1) {
        [moduleMap] = args;
        defineModules(moduleMap);
      } else if (args.length === 2) {
        const [path, module] = args;
        defineModule(path, module);
        moduleMap = { [path]: module };
      } else {
        throw new ArgumentError(`Expected 1 or 2 arguments, but got ${args.length}.`);
      }
      for (const path in moduleMap) {
        if (hasOwnProperty2(moduleMap, path) && hasOwnProperty2(definitionWaiters, path)) {
          defer2(...definitionWaiters[path]);
          delete definitionWaiters[path];
        }
      }
      flushDefer();
    };
    const _designatedRequire = (path, continuation, relativeTo) => {
      const paths = searchPathsForModulePath(path, relativeTo);
      if (continuation === void 0) {
        let module;
        for (let i = 0, ii = paths.length; i < ii && !module; i++) {
          const path2 = paths[i];
          module = moduleAtPathSync(path2);
        }
        if (!module) {
          throw new Error(`The module at "${path}" does not exist.`);
        }
        return module.exports;
      } else {
        if (!(typeof continuation === "function")) {
          throw new ArgumentError("Continuation must be a function.");
        }
        flushDeferAfter(() => {
          const search = () => {
            const path2 = paths.shift();
            return moduleAtPath(path2, (module) => {
              if (module || paths.length === 0) {
                continuation(module && module.exports);
              } else {
                search();
              }
            });
          };
          search();
        });
      }
    };
    const designatedRequire = (...args) => (rootRequire._designatedRequire || _designatedRequire)(...args);
    const requireRelative = (basePath, qualifiedPath, continuation) => {
      qualifiedPath = qualifiedPath.toString();
      const path = normalizePath(fullyQualifyPath(qualifiedPath, basePath));
      return designatedRequire(path, continuation, basePath);
    };
    const requireRelativeN = (basePath, qualifiedPaths, continuation) => {
      if (!(typeof continuation === "function")) {
        throw new ArgumentError("Final argument must be a continuation.");
      } else {
        const _qualifiedPaths = qualifiedPaths.map((p) => p.toString());
        const results = [];
        const _require = (result2) => {
          results.push(result2);
          if (qualifiedPaths.length > 0) {
            requireRelative(basePath, qualifiedPaths.shift(), _require);
          } else {
            continuation(...results);
          }
        };
        for (let i = 0; i < qualifiedPaths.length; i++) {
          requireRelative(basePath, _qualifiedPaths[i], _require);
        }
      }
    };
    const requireRelativeTo = (basePath) => {
      basePath = basePath.replace(/[^/]+$/, "");
      const require3 = (...args) => {
        if (args.length > 2) {
          const continuation = args.pop();
          const qualifiedPaths = args;
          return requireRelativeN(basePath, qualifiedPaths, continuation);
        } else {
          const [qualifiedPath, continuation] = args;
          return requireRelative(basePath, qualifiedPath, continuation);
        }
      };
      require3.main = main;
      return require3;
    };
    const rootRequire = requireRelativeTo("/");
    rootRequire._modules = modules;
    rootRequire._definitions = definitions;
    rootRequire._designatedRequire = _designatedRequire;
    rootRequire.define = define;
    rootRequire.setRequestMaximum = setRequestMaximum;
    rootRequire.setGlobalKeyPath = setGlobalKeyPath;
    rootRequire.setRootURI = setRootURI;
    rootRequire.setLibraryURI = setLibraryURI;
    rootRequire.setLibraryLookupComponent = setLibraryLookupComponent;
    return rootRequire;
  })()
);
const requireKernel = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  require: require2
}, Symbol.toStringTag, { value: "Module" }));
var hasRequiredAce;
function requireAce() {
  if (hasRequiredAce)
    return ace;
  hasRequiredAce = 1;
  const hooks$1 = hooks;
  const makeCSSManager = requireCssmanager().makeCSSManager;
  const pluginUtils = shared;
  const Ace2Inner = requireAce2_inner();
  const clientPlugins = client_plugins;
  const requireKernel$1 = requireKernel;
  const debugLog = (...args) => {
    console.log(args);
  };
  const absUrl = (url2) => new URL(url2, window.location.href).href;
  const eventFired = async (obj, event, cleanups = [], predicate = () => true) => {
    if (typeof cleanups === "function") {
      predicate = cleanups;
      cleanups = [];
    }
    await new Promise((resolve, reject2) => {
      let cleanup;
      const successCb = () => {
        if (!predicate())
          return;
        debugLog(`Ace2Editor.init() ${event} event on`, obj);
        cleanup();
        resolve();
      };
      const errorCb = () => {
        const err = new Error(`Ace2Editor.init() error event while waiting for ${event} event`);
        debugLog(`${err} on object`, obj);
        cleanup();
        reject2(err);
      };
      cleanup = () => {
        cleanup = () => {
        };
        obj.removeEventListener(event, successCb);
        obj.removeEventListener("error", errorCb);
      };
      cleanups.push(cleanup);
      obj.addEventListener(event, successCb);
      obj.addEventListener("error", errorCb);
    });
  };
  const frameReady = async (frame) => {
    const doc = () => frame.contentDocument;
    const cleanups = [];
    try {
      await Promise.race([
        eventFired(frame, "load", cleanups),
        eventFired(frame.contentWindow, "load", cleanups),
        eventFired(doc(), "load", cleanups),
        eventFired(doc(), "DOMContentLoaded", cleanups),
        eventFired(doc(), "readystatechange", cleanups, () => doc.readyState === "complete")
      ]);
    } finally {
      for (const cleanup of cleanups)
        cleanup();
    }
  };
  const Ace2Editor = function() {
    let info = { editor: this };
    let loaded = false;
    let actionsPendingInit = [];
    const pendingInit = (func) => function(...args) {
      const action = () => func.apply(this, args);
      if (loaded)
        return action();
      actionsPendingInit.push(action);
    };
    const doActionsPendingInit = () => {
      for (const fn of actionsPendingInit)
        fn();
      actionsPendingInit = [];
    };
    const aceFunctionsPendingInit = [
      "importText",
      "importAText",
      "focus",
      "setEditable",
      "setOnKeyPress",
      "setOnKeyDown",
      "setNotifyDirty",
      "setProperty",
      "setBaseText",
      "setBaseAttributedText",
      "applyChangesToBase",
      "applyPreparedChangesetToBase",
      "setUserChangeNotificationCallback",
      "setAuthorInfo",
      "callWithAce",
      "execCommand",
      "replaceRange"
    ];
    for (const fnName of aceFunctionsPendingInit) {
      this[fnName] = pendingInit(function(...args) {
        info[`ace_${fnName}`].apply(this, args);
      });
    }
    this.exportText = () => loaded ? info.ace_exportText() : "(awaiting init)\n";
    this.getInInternationalComposition = () => loaded ? info.ace_getInInternationalComposition() : null;
    this.prepareUserChangeset = () => loaded ? info.ace_prepareUserChangeset() : null;
    const addStyleTagsFor = (doc, files) => {
      for (const file of files) {
        const link = doc.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.href = absUrl(encodeURI(file));
        doc.head.appendChild(link);
      }
    };
    this.destroy = pendingInit(() => {
      info.ace_dispose();
      info.frame.parentNode.removeChild(info.frame);
      info = null;
    });
    this.init = async function(containerId, initialCode) {
      debugLog("Ace2Editor.init() with", initialCode);
      this.importText(initialCode);
      const includedCSS = [
        `../static/css/iframe_editor.css?v=${clientVars.randomVersionString}`,
        `../static/css/pad.css?v=${clientVars.randomVersionString}`,
        ...hooks$1.callAll("aceEditorCSS").map(
          // Allow urls to external CSS - http(s):// and //some/path.css
          (p) => /\/\//.test(p) ? p : `../static/plugins/${p}`
        ),
        `../static/skins/${clientVars.skinName}/pad.css?v=${clientVars.randomVersionString}`
      ];
      const skinVariants = clientVars.skinVariants.split(" ").filter((x) => x !== "");
      const outerFrame = document.createElement("iframe");
      outerFrame.name = "ace_outer";
      outerFrame.frameBorder = 0;
      outerFrame.title = "Ether";
      outerFrame.src = "../static/empty.html";
      info.frame = outerFrame;
      document.getElementById(containerId).appendChild(outerFrame);
      const outerWindow = outerFrame.contentWindow;
      debugLog("Ace2Editor.init() waiting for outer frame");
      await frameReady(outerFrame);
      debugLog("Ace2Editor.init() outer frame ready");
      const outerDocument = outerWindow.document;
      outerDocument.documentElement.classList.add("outer-editor", "outerdoc", ...skinVariants);
      addStyleTagsFor(outerDocument, includedCSS);
      const outerStyle = outerDocument.createElement("style");
      outerStyle.type = "text/css";
      outerStyle.title = "dynamicsyntax";
      outerDocument.head.appendChild(outerStyle);
      outerDocument.body.id = "outerdocbody";
      outerDocument.body.classList.add("outerdocbody", ...pluginUtils.clientPluginNames());
      const sideDiv = outerDocument.createElement("div");
      sideDiv.id = "sidediv";
      sideDiv.classList.add("sidediv");
      outerDocument.body.appendChild(sideDiv);
      const sideDivInner = outerDocument.createElement("div");
      sideDivInner.id = "sidedivinner";
      sideDivInner.classList.add("sidedivinner");
      sideDiv.appendChild(sideDivInner);
      const lineMetricsDiv = outerDocument.createElement("div");
      lineMetricsDiv.id = "linemetricsdiv";
      lineMetricsDiv.appendChild(outerDocument.createTextNode("x"));
      outerDocument.body.appendChild(lineMetricsDiv);
      const innerFrame = outerDocument.createElement("iframe");
      innerFrame.name = "ace_inner";
      innerFrame.title = "pad";
      innerFrame.scrolling = "no";
      innerFrame.frameBorder = 0;
      innerFrame.allowTransparency = true;
      innerFrame.src = "empty.html";
      outerDocument.body.insertBefore(innerFrame, outerDocument.body.firstChild);
      const innerWindow = innerFrame.contentWindow;
      debugLog("Ace2Editor.init() waiting for inner frame");
      await frameReady(innerFrame);
      debugLog("Ace2Editor.init() inner frame ready");
      const innerDocument = innerWindow.document;
      innerDocument.documentElement.classList.add("inner-editor", ...skinVariants);
      addStyleTagsFor(innerDocument, includedCSS);
      const innerStyle = innerDocument.createElement("style");
      innerStyle.type = "text/css";
      innerStyle.title = "dynamicsyntax";
      innerDocument.head.appendChild(innerStyle);
      const headLines = [];
      hooks$1.callAll("aceInitInnerdocbodyHead", { iframeHTML: headLines });
      innerDocument.head.appendChild(
        innerDocument.createRange().createContextualFragment(headLines.join("\n"))
      );
      innerDocument.body.id = "innerdocbody";
      innerDocument.body.classList.add("innerdocbody");
      innerDocument.body.setAttribute("spellcheck", "false");
      innerDocument.body.appendChild(innerDocument.createTextNode("Â "));
      const require3 = requireKernel$1.require;
      debugLog("Ace2Editor.init() waiting for require kernel load");
      await eventFired({
        addEventListener: (e, a) => {
          console.log("Events are", e, a);
          if (e === "load") {
            a();
          }
        },
        removeEventListener: (e, a) => {
        }
      }, "load");
      debugLog("Ace2Editor.init() require kernel loaded");
      require3.setRootURI(absUrl("../javascripts/src"));
      require3.setLibraryURI(absUrl("../javascripts/lib"));
      require3.setGlobalKeyPath("require");
      innerWindow.Ace2Inner = Ace2Inner;
      innerWindow.plugins = clientPlugins;
      innerWindow.require = require3;
      innerWindow.plugins.adoptPluginsFromAncestorsOf(require3);
      innerWindow.$ = innerWindow.jQuery = window.$;
      debugLog("Ace2Editor.init() waiting for plugins");
      await new Promise((resolve, reject2) => innerWindow.plugins.ensure(
        (err) => err != null ? reject2(err) : resolve()
      ));
      debugLog("Ace2Editor.init() waiting for Ace2Inner.init()");
      const iframe = document.getElementsByName("ace_outer")[0];
      console.log(iframe);
      await innerWindow.Ace2Inner.init(info, {
        inner: makeCSSManager(innerStyle.sheet),
        outer: makeCSSManager(outerStyle.sheet),
        parent: makeCSSManager(iframe.contentWindow.document.querySelector('style[title="dynamicsyntax"]').sheet)
      });
      debugLog("Ace2Editor.init() Ace2Inner.init() returned");
      loaded = true;
      doActionsPendingInit();
      debugLog("Ace2Editor.init() done");
    };
  };
  ace.Ace2Editor = Ace2Editor;
  return ace;
}
var hasRequiredPad_editor;
function requirePad_editor() {
  if (hasRequiredPad_editor)
    return pad_editor;
  hasRequiredPad_editor = 1;
  (function(exports) {
    const Cookies = requirePad_utils().Cookies;
    const padcookie = requirePad_cookie().padcookie;
    const padutils = requirePad_utils().padutils;
    const padeditor = /* @__PURE__ */ (() => {
      let Ace2Editor = void 0;
      let pad2 = void 0;
      let settings = void 0;
      const self2 = {
        ace: null,
        // this is accessed directly from other files
        viewZoom: 100,
        init: async (initialViewOptions, _pad) => {
          Ace2Editor = requireAce().Ace2Editor;
          pad2 = _pad;
          settings = pad2.settings;
          self2.ace = new Ace2Editor();
          await self2.ace.init("editorcontainer", "");
          $("#editorloadingbox").hide();
          const $outerdoc = $('iframe[name="ace_outer"]').contents().find("#outerdocbody");
          $outerdoc.find("#sidedivinner").on("click", "div", function() {
            const targetLineNumber = $(this).index() + 1;
            window.location.hash = `L${targetLineNumber}`;
          });
          exports.focusOnLine(self2.ace);
          self2.ace.setProperty("wraps", true);
          self2.initViewOptions();
          self2.setViewOptions(initialViewOptions);
          $("#viewbarcontents").show();
        },
        initViewOptions: () => {
          padutils.bindCheckboxChange($("#options-linenoscheck"), () => {
            pad2.changeViewOption("showLineNumbers", padutils.getCheckbox($("#options-linenoscheck")));
          });
          padutils.bindCheckboxChange($("#options-colorscheck"), () => {
            padcookie.setPref("showAuthorshipColors", padutils.getCheckbox("#options-colorscheck"));
            pad2.changeViewOption("showAuthorColors", padutils.getCheckbox("#options-colorscheck"));
          });
          padutils.bindCheckboxChange($("#options-rtlcheck"), () => {
            pad2.changeViewOption("rtlIsTrue", padutils.getCheckbox($("#options-rtlcheck")));
          });
          html10n.bind("localized", () => {
            pad2.changeViewOption("rtlIsTrue", "rtl" === html10n.getDirection());
            padutils.setCheckbox($("#options-rtlcheck"), "rtl" === html10n.getDirection());
          });
          $("#viewfontmenu").on("change", () => {
            pad2.changeViewOption("padFontFamily", $("#viewfontmenu").val());
          });
          html10n.bind("localized", () => {
            $("#languagemenu").val(html10n.getLanguage());
            $("input[data-l10n-id]").each((key, input) => {
              input = $(input);
              if (input.hasClass("editempty")) {
                input.val(html10n.get(input.attr("data-l10n-id")));
              }
            });
          });
          $("#languagemenu").val(html10n.getLanguage());
          $("#languagemenu").on("change", () => {
            Cookies.set("language", $("#languagemenu").val());
            window.html10n.localize([$("#languagemenu").val(), "en"]);
            if ($("select").niceSelect) {
              $("select").niceSelect("update");
            }
          });
        },
        setViewOptions: (newOptions) => {
          const getOption = (key, defaultValue) => {
            const value = String(newOptions[key]);
            if (value === "true")
              return true;
            if (value === "false")
              return false;
            return defaultValue;
          };
          let v;
          v = getOption("rtlIsTrue", "rtl" === html10n.getDirection());
          self2.ace.setProperty("rtlIsTrue", v);
          padutils.setCheckbox($("#options-rtlcheck"), v);
          v = getOption("showLineNumbers", true);
          self2.ace.setProperty("showslinenumbers", v);
          padutils.setCheckbox($("#options-linenoscheck"), v);
          v = getOption("showAuthorColors", true);
          self2.ace.setProperty("showsauthorcolors", v);
          $("#chattext").toggleClass("authorColors", v);
          $('iframe[name="ace_outer"]').contents().find("#sidedivinner").toggleClass("authorColors", v);
          padutils.setCheckbox($("#options-colorscheck"), v);
          if (settings.noColors !== false) {
            self2.ace.setProperty("showsauthorcolors", !settings.noColors);
          }
          self2.ace.setProperty("textface", newOptions.padFontFamily || "");
        },
        dispose: () => {
          if (self2.ace) {
            self2.ace.destroy();
            self2.ace = null;
          }
        },
        enable: () => {
          if (self2.ace) {
            self2.ace.setEditable(true);
          }
        },
        disable: () => {
          if (self2.ace) {
            self2.ace.setEditable(false);
          }
        },
        restoreRevisionText: (dataFromServer) => {
          pad2.addHistoricalAuthors(dataFromServer.historicalAuthorData);
          self2.ace.importAText(dataFromServer.atext, dataFromServer.apool, true);
        }
      };
      return self2;
    })();
    exports.padeditor = padeditor;
    exports.focusOnLine = (ace2) => {
      const lineNumber = window.location.hash.substr(1);
      if (lineNumber) {
        if (lineNumber[0] === "L") {
          const $outerdoc = $('iframe[name="ace_outer"]').contents().find("#outerdocbody");
          const lineNumberInt = parseInt(lineNumber.substr(1));
          if (lineNumberInt) {
            const $inner = $('iframe[name="ace_outer"]').contents().find("iframe").contents().find("#innerdocbody");
            const line = $inner.find(`div:nth-child(${lineNumberInt})`);
            if (line.length !== 0) {
              let offsetTop = line.offset().top;
              offsetTop += parseInt($outerdoc.css("padding-top").replace("px", ""));
              const hasMobileLayout = $("body").hasClass("mobile-layout");
              if (!hasMobileLayout) {
                offsetTop += parseInt($inner.css("padding-top").replace("px", ""));
              }
              const $outerdocHTML = $('iframe[name="ace_outer"]').contents().find("#outerdocbody").parent();
              $outerdoc.css({ top: `${offsetTop}px` });
              $outerdocHTML.animate({ scrollTop: offsetTop });
              const node = line[0];
              ace2.callWithAce((ace3) => {
                const selection = {
                  startPoint: {
                    index: 0,
                    focusAtStart: true,
                    maxIndex: 1,
                    node
                  },
                  endPoint: {
                    index: 0,
                    focusAtStart: true,
                    maxIndex: 1,
                    node
                  }
                };
                ace3.ace_setSelection(selection);
              });
            }
          }
        }
      }
    };
  })(pad_editor);
  return pad_editor;
}
var hasRequiredChat;
function requireChat() {
  if (hasRequiredChat)
    return chat;
  hasRequiredChat = 1;
  const ChatMessage = requireChatMessage();
  const padutils = requirePad_utils().padutils;
  const padcookie = requirePad_cookie().padcookie;
  const Tinycon = requireTinycon();
  const hooks$1 = hooks;
  const padeditor = requirePad_editor().padeditor;
  const normalize = (s) => s.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
  chat.chat = /* @__PURE__ */ (() => {
    let isStuck = false;
    let userAndChat = false;
    let chatMentions = 0;
    return {
      show() {
        $("#chaticon").removeClass("visible");
        $("#chatbox").addClass("visible");
        this.scrollDown(true);
        chatMentions = 0;
        Tinycon.setBubble(0);
        $(".chat-gritter-msg").each(function() {
          $.gritter.remove(this.id);
        });
      },
      focus: () => {
        setTimeout(() => {
          $("#chatinput").trigger("focus");
        }, 100);
      },
      // Make chat stick to right hand side of screen
      stickToScreen(fromInitialCall) {
        if ($("#options-stickychat").prop("checked")) {
          $("#options-stickychat").prop("checked", false);
        }
        if (pad.settings.hideChat) {
          return;
        }
        this.show();
        isStuck = !isStuck || fromInitialCall;
        $("#chatbox").hide();
        setTimeout(() => {
          $("#chatbox, .sticky-container").toggleClass("stickyChat", isStuck);
          $("#chatbox").css("display", "flex");
        }, 0);
        padcookie.setPref("chatAlwaysVisible", isStuck);
        $("#options-stickychat").prop("checked", isStuck);
      },
      chatAndUsers(fromInitialCall) {
        const toEnable = $("#options-chatandusers").is(":checked");
        if (toEnable || !userAndChat || fromInitialCall) {
          this.stickToScreen(true);
          $("#options-stickychat").prop("checked", true);
          $("#options-chatandusers").prop("checked", true);
          $("#options-stickychat").prop("disabled", true);
          userAndChat = true;
        } else {
          $("#options-stickychat").prop("disabled", false);
          userAndChat = false;
        }
        padcookie.setPref("chatAndUsers", userAndChat);
        $("#users, .sticky-container").toggleClass("chatAndUsers popup-show stickyUsers", userAndChat);
        $("#chatbox").toggleClass("chatAndUsersChat", userAndChat);
      },
      hide() {
        if ($("#options-stickychat").prop("checked")) {
          this.stickToScreen();
          $("#options-stickychat").prop("checked", false);
        } else {
          $("#chatcounter").text("0");
          $("#chaticon").addClass("visible");
          $("#chatbox").removeClass("visible");
        }
      },
      scrollDown(force) {
        if ($("#chatbox").hasClass("visible")) {
          if (force || !this.lastMessage || !this.lastMessage.position() || this.lastMessage.position().top < $("#chattext").outerHeight() + 20) {
            $("#chattext").animate(
              { scrollTop: $("#chattext")[0].scrollHeight },
              { duration: 400, queue: false }
            );
            this.lastMessage = $("#chattext > p").eq(-1);
          }
        }
      },
      async send() {
        const text = $("#chatinput").val();
        if (text.replace(/\s+/, "").length === 0)
          return;
        const message = new ChatMessage(text);
        await hooks$1.aCallAll("chatSendMessage", Object.freeze({ message }));
        this._pad.collabClient.sendMessage({ type: "CHAT_MESSAGE", message });
        $("#chatinput").val("");
      },
      async addMessage(msg, increment, isHistoryAdd) {
        msg = ChatMessage.fromObject(msg);
        msg.time += this._pad.clientTimeOffset;
        if (!msg.authorId) {
          msg.authorId = "unknown";
          console.warn(
            'The "authorId" field of a chat message coming from the server was not present. Replacing with "unknown". This may be a bug or a database corruption.'
          );
        }
        const authorClass = (authorId) => `author-${authorId.replace(/[^a-y0-9]/g, (c) => {
          if (c === ".")
            return "-";
          return `z${c.charCodeAt(0)}z`;
        })}`;
        const ctx = {
          authorName: msg.displayName != null ? msg.displayName : html10n.get("pad.userlist.unnamed"),
          author: msg.authorId,
          text: padutils.escapeHtmlWithClickableLinks(msg.text, "_blank"),
          message: msg,
          rendered: null,
          sticky: false,
          timestamp: msg.time,
          timeStr: (() => {
            let minutes = `${new Date(msg.time).getMinutes()}`;
            let hours = `${new Date(msg.time).getHours()}`;
            if (minutes.length === 1)
              minutes = `0${minutes}`;
            if (hours.length === 1)
              hours = `0${hours}`;
            return `${hours}:${minutes}`;
          })(),
          duration: 4e3
        };
        const alreadyFocused = $("#chatinput").is(":focus");
        const chatOpen = $("#chatbox").hasClass("visible");
        const wasMentioned = msg.authorId !== window.clientVars.userId && ctx.authorName !== html10n.get("pad.userlist.unnamed") && normalize(ctx.text).includes(normalize(ctx.authorName));
        if (wasMentioned && !alreadyFocused && !isHistoryAdd && !chatOpen) {
          chatMentions++;
          Tinycon.setBubble(chatMentions);
          ctx.sticky = true;
        }
        await hooks$1.aCallAll("chatNewMessage", ctx);
        const cls = authorClass(ctx.author);
        const chatMsg = ctx.rendered != null ? $(ctx.rendered) : $("<p>").attr("data-authorId", ctx.author).addClass(cls).append($("<b>").text(`${ctx.authorName}:`)).append($("<span>").addClass("time").addClass(cls).html(ctx.timeStr)).append(" ").append($("<div>").html(ctx.text).contents());
        if (isHistoryAdd)
          chatMsg.insertAfter("#chatloadmessagesbutton");
        else
          $("#chattext").append(chatMsg);
        chatMsg.each((i, e) => html10n.translateElement(html10n.translations, e));
        if (increment && !isHistoryAdd) {
          let count = Number($("#chatcounter").text());
          count++;
          $("#chatcounter").text(count);
          if (!chatOpen && ctx.duration > 0) {
            const text = $("<p>").append($("<span>").addClass("author-name").text(ctx.authorName)).append($("<div>").html(ctx.text).contents());
            text.each((i, e) => html10n.translateElement(html10n.translations, e));
            $.gritter.add({
              text,
              sticky: ctx.sticky,
              time: ctx.duration,
              position: "bottom",
              class_name: "chat-gritter-msg"
            });
          }
        }
        if (!isHistoryAdd)
          this.scrollDown();
      },
      init(pad2) {
        this._pad = pad2;
        $("#chatinput").on("keydown", (evt) => {
          if (evt.altKey === true && evt.which === 67 || evt.which === 27) {
            $(":focus").trigger("blur");
            padeditor.ace.focus();
            evt.preventDefault();
            return false;
          }
        });
        $("#chatinput").on("click", () => {
          chatMentions = 0;
          Tinycon.setBubble(0);
        });
        const self2 = this;
        $("body:not(#chatinput)").on("keypress", function(evt) {
          if (evt.altKey && evt.which === 67) {
            $(this).trigger("blur");
            self2.show();
            $("#chatinput").trigger("focus");
            evt.preventDefault();
          }
        });
        $("#chatinput").on("keypress", (evt) => {
          if (evt.key === "Enter" && !evt.shiftKey) {
            evt.preventDefault();
            this.send();
          }
        });
        $("#chatcounter").text(0);
        $("#chatloadmessagesbutton").on("click", () => {
          const start = Math.max(this.historyPointer - 20, 0);
          const end = this.historyPointer;
          if (start === end)
            return;
          $("#chatloadmessagesbutton").css("display", "none");
          $("#chatloadmessagesball").css("display", "block");
          pad2.collabClient.sendMessage({ type: "GET_CHAT_MESSAGES", start, end });
          this.historyPointer = start;
        });
      }
    };
  })();
  return chat;
}
var collab_client = {};
var hasRequiredCollab_client;
function requireCollab_client() {
  if (hasRequiredCollab_client)
    return collab_client;
  hasRequiredCollab_client = 1;
  const chat2 = requireChat().chat;
  const hooks$1 = hooks;
  const browser2 = browserExports;
  let pad2 = void 0;
  const getSocket = () => pad2 && pad2.socket;
  const getCollabClient = (ace2editor, serverVars, initialUserInfo, options, _pad) => {
    const editor = ace2editor;
    pad2 = _pad;
    let rev = serverVars.rev;
    let committing = false;
    let stateMessage;
    let channelState = "CONNECTING";
    let lastCommitTime = 0;
    let initialStartConnectTime = 0;
    let commitDelay = 500;
    const userId = initialUserInfo.userId;
    const userSet = {};
    userSet[userId] = initialUserInfo;
    let isPendingRevision = false;
    const callbacks = {
      onUserJoin: () => {
      },
      onUserLeave: () => {
      },
      onUpdateUserInfo: () => {
      },
      onChannelStateChange: () => {
      },
      onClientMessage: () => {
      },
      onInternalAction: () => {
      },
      onConnectionTrouble: () => {
      },
      onServerMessage: () => {
      }
    };
    if (browser2.firefox) {
      $(window).on("keydown", (evt) => {
        if (evt.which === 27) {
          evt.preventDefault();
        }
      });
    }
    const handleUserChanges = () => {
      if (editor.getInInternationalComposition()) {
        return;
      }
      const now2 = Date.now();
      if (!getSocket() || channelState === "CONNECTING") {
        if (channelState === "CONNECTING" && now2 - initialStartConnectTime > 2e4) {
          setChannelState("DISCONNECTED", "initsocketfail");
        } else {
          setTimeout(handleUserChanges, 1e3);
        }
        return;
      }
      if (committing) {
        if (now2 - lastCommitTime > 2e4) {
          setChannelState("DISCONNECTED", "slowcommit");
        } else if (now2 - lastCommitTime > 5e3) {
          callbacks.onConnectionTrouble("SLOW");
        } else {
          setTimeout(handleUserChanges, 3e3);
        }
        return;
      }
      const earliestCommit = lastCommitTime + commitDelay;
      if (now2 < earliestCommit) {
        setTimeout(handleUserChanges, earliestCommit - now2);
        return;
      }
      let sentMessage = false;
      if (!isPendingRevision) {
        const userChangesData = editor.prepareUserChangeset();
        if (userChangesData.changeset) {
          lastCommitTime = now2;
          committing = true;
          stateMessage = {
            type: "USER_CHANGES",
            baseRev: rev,
            changeset: userChangesData.changeset,
            apool: userChangesData.apool
          };
          sendMessage(stateMessage);
          sentMessage = true;
          callbacks.onInternalAction("commitPerformed");
        }
      } else {
        setTimeout(handleUserChanges, 3e3);
      }
      if (sentMessage) {
        setTimeout(handleUserChanges, 3e3);
      }
    };
    const acceptCommit = () => {
      editor.applyPreparedChangesetToBase();
      setStateIdle();
      try {
        callbacks.onInternalAction("commitAcceptedByServer");
        callbacks.onConnectionTrouble("OK");
      } catch (err) {
      }
      handleUserChanges();
    };
    const setUpSocket = () => {
      setChannelState("CONNECTED");
      doDeferredActions();
      initialStartConnectTime = Date.now();
    };
    const sendMessage = (msg) => {
      getSocket().emit(
        "message",
        {
          type: "COLLABROOM",
          component: "pad",
          data: msg
        }
      );
    };
    const serverMessageTaskQueue = new class {
      constructor() {
        this._promiseChain = Promise.resolve();
      }
      async enqueue(fn) {
        const taskPromise = this._promiseChain.then(fn);
        this._promiseChain = taskPromise.catch(() => {
        });
        return await taskPromise;
      }
    }();
    const handleMessageFromServer = (evt) => {
      if (!getSocket())
        return;
      if (!evt.data)
        return;
      const wrapper = evt;
      if (wrapper.type !== "COLLABROOM" && wrapper.type !== "CUSTOM")
        return;
      const msg = wrapper.data;
      if (msg.type === "NEW_CHANGES") {
        serverMessageTaskQueue.enqueue(async () => {
          await editor.getInInternationalComposition();
          const { newRev, changeset, author = "", apool } = msg;
          if (newRev !== rev + 1) {
            window.console.warn(`bad message revision on NEW_CHANGES: ${newRev} not ${rev + 1}`);
            return;
          }
          rev = newRev;
          editor.applyChangesToBase(changeset, author, apool);
        });
      } else if (msg.type === "ACCEPT_COMMIT") {
        serverMessageTaskQueue.enqueue(() => {
          const { newRev } = msg;
          if (![rev, rev + 1].includes(newRev)) {
            window.console.warn(`bad message revision on ACCEPT_COMMIT: ${newRev} not ${rev + 1}`);
            return;
          }
          rev = newRev;
          acceptCommit();
        });
      } else if (msg.type === "CLIENT_RECONNECT") {
        serverMessageTaskQueue.enqueue(() => {
          if (msg.noChanges) {
            setIsPendingRevision(false);
            return;
          }
          const { headRev, newRev, changeset, author = "", apool } = msg;
          if (newRev !== rev + 1) {
            window.console.warn(`bad message revision on CLIENT_RECONNECT: ${newRev} not ${rev + 1}`);
            return;
          }
          rev = newRev;
          if (author === pad2.getUserId()) {
            acceptCommit();
          } else {
            editor.applyChangesToBase(changeset, author, apool);
          }
          if (newRev === headRev) {
            setIsPendingRevision(false);
          }
        });
      } else if (msg.type === "USER_NEWINFO") {
        const userInfo = msg.userInfo;
        const id = userInfo.userId;
        if (userSet[id]) {
          userSet[id] = userInfo;
          callbacks.onUpdateUserInfo(userInfo);
        } else {
          userSet[id] = userInfo;
          callbacks.onUserJoin(userInfo);
        }
        tellAceActiveAuthorInfo(userInfo);
      } else if (msg.type === "USER_LEAVE") {
        const userInfo = msg.userInfo;
        const id = userInfo.userId;
        if (userSet[id]) {
          delete userSet[userInfo.userId];
          fadeAceAuthorInfo(userInfo);
          callbacks.onUserLeave(userInfo);
        }
      } else if (msg.type === "CLIENT_MESSAGE") {
        callbacks.onClientMessage(msg.payload);
      } else if (msg.type === "CHAT_MESSAGE") {
        chat2.addMessage(msg.message, true, false);
      } else if (msg.type === "CHAT_MESSAGES") {
        for (let i = msg.messages.length - 1; i >= 0; i--) {
          chat2.addMessage(msg.messages[i], true, true);
        }
        if (!chat2.gotInitalMessages) {
          chat2.scrollDown();
          chat2.gotInitalMessages = true;
          chat2.historyPointer = clientVars.chatHead - msg.messages.length;
        }
        $("#chatloadmessagesball").css("display", "none");
        if (chat2.historyPointer <= 0) {
          $("#chatloadmessagesbutton").css("display", "none");
        } else {
          $("#chatloadmessagesbutton").css("display", "block");
        }
      }
      if (msg.type.indexOf("USER_") > -1) {
        msg.payload = msg.userInfo;
      }
      if (msg.type === "NEW_CHANGES")
        msg.payload = msg;
      hooks$1.callAll(`handleClientMessage_${msg.type}`, { payload: msg.payload });
    };
    const updateUserInfo = (userInfo) => {
      userInfo.userId = userId;
      userSet[userId] = userInfo;
      tellAceActiveAuthorInfo(userInfo);
      if (!getSocket())
        return;
      sendMessage(
        {
          type: "USERINFO_UPDATE",
          userInfo
        }
      );
    };
    const tellAceActiveAuthorInfo = (userInfo) => {
      tellAceAuthorInfo(userInfo.userId, userInfo.colorId);
    };
    const tellAceAuthorInfo = (userId2, colorId, inactive) => {
      if (typeof colorId === "number") {
        colorId = clientVars.colorPalette[colorId];
      }
      const cssColor = colorId;
      if (inactive) {
        editor.setAuthorInfo(userId2, {
          bgcolor: cssColor,
          fade: 0.5
        });
      } else {
        editor.setAuthorInfo(userId2, {
          bgcolor: cssColor
        });
      }
    };
    const fadeAceAuthorInfo = (userInfo) => {
      tellAceAuthorInfo(userInfo.userId, userInfo.colorId, true);
    };
    const getConnectedUsers = () => valuesArray(userSet);
    const tellAceAboutHistoricalAuthors = (hadata) => {
      for (const [author, data] of Object.entries(hadata)) {
        if (!userSet[author]) {
          tellAceAuthorInfo(author, data.colorId, true);
        }
      }
    };
    const setChannelState = (newChannelState, moreInfo) => {
      if (newChannelState !== channelState) {
        channelState = newChannelState;
        callbacks.onChannelStateChange(channelState, moreInfo);
      }
    };
    const valuesArray = (obj) => {
      const array = [];
      $.each(obj, (k, v) => {
        array.push(v);
      });
      return array;
    };
    let deferredActions = [];
    const defer2 = (func, tag) => function(...args) {
      const action = () => {
        func.call(this, ...args);
      };
      action.tag = tag;
      if (channelState === "CONNECTING") {
        deferredActions.push(action);
      } else {
        action();
      }
    };
    const doDeferredActions = (tag) => {
      const newArray = [];
      for (let i = 0; i < deferredActions.length; i++) {
        const a = deferredActions[i];
        {
          a();
        }
      }
      deferredActions = newArray;
    };
    const sendClientMessage = (msg) => {
      sendMessage(
        {
          type: "CLIENT_MESSAGE",
          payload: msg
        }
      );
    };
    const getCurrentRevisionNumber = () => rev;
    const getMissedChanges = () => {
      const obj = {};
      obj.userInfo = userSet[userId];
      obj.baseRev = rev;
      if (committing && stateMessage) {
        obj.committedChangeset = stateMessage.changeset;
        obj.committedChangesetAPool = stateMessage.apool;
        editor.applyPreparedChangesetToBase();
      }
      const userChangesData = editor.prepareUserChangeset();
      if (userChangesData.changeset) {
        obj.furtherChangeset = userChangesData.changeset;
        obj.furtherChangesetAPool = userChangesData.apool;
      }
      return obj;
    };
    const setStateIdle = () => {
      committing = false;
      callbacks.onInternalAction("newlyIdle");
      schedulePerhapsCallIdleFuncs();
    };
    const setIsPendingRevision = (value) => {
      isPendingRevision = value;
    };
    const idleFuncs = [];
    const callWhenNotCommitting = (func) => {
      idleFuncs.push(func);
      schedulePerhapsCallIdleFuncs();
    };
    const schedulePerhapsCallIdleFuncs = () => {
      setTimeout(() => {
        if (!committing) {
          while (idleFuncs.length > 0) {
            const f = idleFuncs.shift();
            f();
          }
        }
      }, 0);
    };
    const self2 = {
      setOnUserJoin: (cb2) => {
        callbacks.onUserJoin = cb2;
      },
      setOnUserLeave: (cb2) => {
        callbacks.onUserLeave = cb2;
      },
      setOnUpdateUserInfo: (cb2) => {
        callbacks.onUpdateUserInfo = cb2;
      },
      setOnChannelStateChange: (cb2) => {
        callbacks.onChannelStateChange = cb2;
      },
      setOnClientMessage: (cb2) => {
        callbacks.onClientMessage = cb2;
      },
      setOnInternalAction: (cb2) => {
        callbacks.onInternalAction = cb2;
      },
      setOnConnectionTrouble: (cb2) => {
        callbacks.onConnectionTrouble = cb2;
      },
      updateUserInfo: defer2(updateUserInfo),
      handleMessageFromServer,
      getConnectedUsers,
      sendClientMessage,
      sendMessage,
      getCurrentRevisionNumber,
      getMissedChanges,
      callWhenNotCommitting,
      addHistoricalAuthors: tellAceAboutHistoricalAuthors,
      setChannelState,
      setStateIdle,
      setIsPendingRevision,
      set commitDelay(ms2) {
        commitDelay = ms2;
      },
      get commitDelay() {
        return commitDelay;
      }
    };
    tellAceAboutHistoricalAuthors(serverVars.historicalAuthorData);
    tellAceActiveAuthorInfo(initialUserInfo);
    editor.setProperty("userAuthor", userId);
    editor.setBaseAttributedText(serverVars.initialAttributedText, serverVars.apool);
    editor.setUserChangeNotificationCallback(handleUserChanges);
    setUpSocket();
    return self2;
  };
  collab_client.getCollabClient = getCollabClient;
  return collab_client;
}
var pad_connectionstatus = {};
var pad_modals = {};
var pad_editbar = {};
var pad_savedrevs = {};
var hasRequiredPad_savedrevs;
function requirePad_savedrevs() {
  if (hasRequiredPad_savedrevs)
    return pad_savedrevs;
  hasRequiredPad_savedrevs = 1;
  let pad2;
  pad_savedrevs.saveNow = () => {
    pad2.collabClient.sendMessage({ type: "SAVE_REVISION" });
    $.gritter.add({
      // (string | mandatory) the heading of the notification
      title: html10n.get("pad.savedrevs.marked"),
      // (string | mandatory) the text inside the notification
      text: html10n.get("pad.savedrevs.timeslider") || "You can view saved revisions in the timeslider",
      // (bool | optional) if you want it to fade out on its own or just sit there
      sticky: false,
      time: 3e3,
      class_name: "saved-revision"
    });
  };
  pad_savedrevs.init = (_pad) => {
    pad2 = _pad;
  };
  return pad_savedrevs;
}
var niceSelect = {};
var hasRequiredNiceSelect;
function requireNiceSelect() {
  if (hasRequiredNiceSelect)
    return niceSelect;
  hasRequiredNiceSelect = 1;
  const jQuery2 = rjquery.jQuery;
  (function($2) {
    $2.fn.niceSelect = function(method) {
      if (typeof method == "string") {
        if (method == "update") {
          this.each(function() {
            var $select = $2(this);
            var $dropdown = $2(this).next(".nice-select");
            var open = $dropdown.hasClass("open");
            if ($dropdown.length) {
              $dropdown.remove();
              create_nice_select($select);
              if (open) {
                $select.next().trigger("click");
              }
            }
          });
        } else if (method == "destroy") {
          this.each(function() {
            var $select = $2(this);
            var $dropdown = $2(this).next(".nice-select");
            if ($dropdown.length) {
              $dropdown.remove();
              $select.css("display", "");
            }
          });
          if ($2(".nice-select").length == 0) {
            $2(document).off(".nice_select");
          }
        } else {
          console.log('Method "' + method + '" does not exist.');
        }
        return this;
      }
      this.hide();
      this.each(function() {
        var $select = $2(this);
        if (!$select.next().hasClass("nice-select")) {
          create_nice_select($select);
        }
      });
      function create_nice_select($select) {
        $select.after(
          $2("<div></div>").addClass("nice-select").addClass($select.attr("class") || "").addClass($select.attr("disabled") ? "disabled" : "").attr("tabindex", $select.attr("disabled") ? null : "0").html('<span class="current"></span><ul class="list thin-scrollbar"></ul>')
        );
        var $dropdown = $select.next();
        var $options = $select.find("option");
        var $selected = $select.find("option:selected");
        $dropdown.find(".current").html($selected.data("display") || $selected.text());
        $options.each(function(i) {
          var $option = $2(this);
          var display = $option.data("display");
          $dropdown.find("ul").append(
            $2("<li></li>").attr("data-value", $option.val()).attr("data-display", display || null).addClass("option" + ($option.is(":selected") ? " selected" : "") + ($option.is(":disabled") ? " disabled" : "")).html($option.text())
          );
        });
      }
      $2(document).off(".nice_select");
      $2(document).on("click.nice_select", ".nice-select", function(event) {
        var $dropdown = $2(this);
        $2(".nice-select").not($dropdown).removeClass("open");
        $dropdown.toggleClass("open");
        if ($dropdown.hasClass("open")) {
          $dropdown.find(".option");
          $dropdown.find(".focus").removeClass("focus");
          $dropdown.find(".selected").addClass("focus");
          if ($dropdown.closest(".toolbar").length > 0) {
            $dropdown.find(".list").css("left", $dropdown.offset().left);
            $dropdown.find(".list").css("top", $dropdown.offset().top + $dropdown.outerHeight());
            $dropdown.find(".list").css("min-width", $dropdown.outerWidth() + "px");
          }
          $listHeight = $dropdown.find(".list").outerHeight();
          $top = $dropdown.parent().offset().top;
          $bottom = $2("body").height() - $top;
          $maxListHeight = $bottom - $dropdown.outerHeight() - 20;
          if ($maxListHeight < 200) {
            $dropdown.addClass("reverse");
            $maxListHeight = 250;
          } else {
            $dropdown.removeClass("reverse");
          }
          $dropdown.find(".list").css("max-height", $maxListHeight + "px");
        } else {
          $dropdown.trigger("focus");
        }
      });
      $2(document).on("click.nice_select", function(event) {
        if ($2(event.target).closest(".nice-select").length === 0) {
          $2(".nice-select").removeClass("open").find(".option");
        }
      });
      $2(document).on("click.nice_select", ".nice-select .option:not(.disabled)", function(event) {
        var $option = $2(this);
        var $dropdown = $option.closest(".nice-select");
        $dropdown.find(".selected").removeClass("selected");
        $option.addClass("selected");
        var text = $option.data("display") || $option.text();
        $dropdown.find(".current").text(text);
        $dropdown.prev("select").val($option.data("value")).trigger("change");
      });
      $2(document).on("keydown.nice_select", ".nice-select", function(event) {
        var $dropdown = $2(this);
        var $focused_option = $2($dropdown.find(".focus") || $dropdown.find(".list .option.selected"));
        if (event.keyCode == 32 || event.keyCode == 13) {
          if ($dropdown.hasClass("open")) {
            $focused_option.trigger("click");
          } else {
            $dropdown.trigger("click");
          }
          return false;
        } else if (event.keyCode == 40) {
          if (!$dropdown.hasClass("open")) {
            $dropdown.trigger("click");
          } else {
            var $next = $focused_option.nextAll(".option:not(.disabled)").first();
            if ($next.length > 0) {
              $dropdown.find(".focus").removeClass("focus");
              $next.addClass("focus");
            }
          }
          return false;
        } else if (event.keyCode == 38) {
          if (!$dropdown.hasClass("open")) {
            $dropdown.trigger("click");
          } else {
            var $prev = $focused_option.prevAll(".option:not(.disabled)").first();
            if ($prev.length > 0) {
              $dropdown.find(".focus").removeClass("focus");
              $prev.addClass("focus");
            }
          }
          return false;
        } else if (event.keyCode == 27) {
          if ($dropdown.hasClass("open")) {
            $dropdown.trigger("click");
          }
        } else if (event.keyCode == 9) {
          if ($dropdown.hasClass("open")) {
            return false;
          }
        }
      });
      var style = document.createElement("a").style;
      style.cssText = "pointer-events:auto";
      if (style.pointerEvents !== "auto") {
        $2("html").addClass("no-csspointerevents");
      }
      return this;
    };
  })(jQuery2);
  return niceSelect;
}
var hasRequiredPad_editbar;
function requirePad_editbar() {
  if (hasRequiredPad_editbar)
    return pad_editbar;
  hasRequiredPad_editbar = 1;
  const browser2 = browserExports;
  const hooks$1 = hooks;
  const padutils = requirePad_utils().padutils;
  const padeditor = requirePad_editor().padeditor;
  const padsavedrevs = requirePad_savedrevs();
  const _2 = indexAll;
  requireNiceSelect();
  class ToolbarItem {
    constructor(element) {
      this.$el = element;
    }
    getCommand() {
      return this.$el.attr("data-key");
    }
    getValue() {
      if (this.isSelect()) {
        return this.$el.find("select").val();
      }
    }
    setValue(val) {
      if (this.isSelect()) {
        return this.$el.find("select").val(val);
      }
    }
    getType() {
      return this.$el.attr("data-type");
    }
    isSelect() {
      return this.getType() === "select";
    }
    isButton() {
      return this.getType() === "button";
    }
    bind(callback) {
      if (this.isButton()) {
        this.$el.on("click", (event) => {
          $(":focus").trigger("blur");
          callback(this.getCommand(), this);
          event.preventDefault();
        });
      } else if (this.isSelect()) {
        this.$el.find("select").on("change", () => {
          callback(this.getCommand(), this);
        });
      }
    }
  }
  const syncAnimation = (() => {
    const SYNCING = -100;
    const DONE = 100;
    let state = DONE;
    const fps = 25;
    const step = 1 / fps;
    const T_START = -0.5;
    const T_FADE = 1;
    const T_GONE = 1.5;
    const animator = padutils.makeAnimationScheduler(() => {
      if (state === SYNCING || state === DONE) {
        return false;
      } else if (state >= T_GONE) {
        state = DONE;
        $("#syncstatussyncing").css("display", "none");
        $("#syncstatusdone").css("display", "none");
        return false;
      } else if (state < 0) {
        state += step;
        if (state >= 0) {
          $("#syncstatussyncing").css("display", "none");
          $("#syncstatusdone").css("display", "block").css("opacity", 1);
        }
        return true;
      } else {
        state += step;
        if (state >= T_FADE) {
          $("#syncstatusdone").css("opacity", (T_GONE - state) / (T_GONE - T_FADE));
        }
        return true;
      }
    }, step * 1e3);
    return {
      syncing: () => {
        state = SYNCING;
        $("#syncstatussyncing").css("display", "block");
        $("#syncstatusdone").css("display", "none");
      },
      done: () => {
        state = T_START;
        animator.scheduleAnimation();
      }
    };
  })();
  pad_editbar.padeditbar = new class {
    constructor() {
      this._editbarPosition = 0;
      this.commands = {};
      this.dropdowns = [];
    }
    init() {
      $("#editbar .editbarbutton").attr("unselectable", "on");
      this.enable();
      $("#editbar [data-key]").each((i, elt) => {
        $(elt).off("click");
        new ToolbarItem($(elt)).bind((command, item) => {
          this.triggerCommand(command, item);
        });
      });
      $("body:not(#editorcontainerbox)").on("keydown", (evt) => {
        this._bodyKeyEvent(evt);
      });
      $(".show-more-icon-btn").on("click", () => {
        $(".toolbar").toggleClass("full-icons");
      });
      this.checkAllIconsAreDisplayedInToolbar();
      $(window).on("resize", _2.debounce(() => this.checkAllIconsAreDisplayedInToolbar(), 100));
      this._registerDefaultCommands();
      hooks$1.callAll("postToolbarInit", {
        toolbar: this,
        ace: padeditor.ace
      });
      if (!browser2.safari) {
        $("select").niceSelect();
      }
      $('iframe[name="ace_outer"]').contents().on("scroll", (ev) => {
        $("#editbar").toggleClass("editor-scrolled", $(ev.currentTarget).scrollTop() > 2);
      });
    }
    isEnabled() {
      return true;
    }
    disable() {
      $("#editbar").addClass("disabledtoolbar").removeClass("enabledtoolbar");
    }
    enable() {
      $("#editbar").addClass("enabledtoolbar").removeClass("disabledtoolbar");
    }
    registerCommand(cmd, callback) {
      this.commands[cmd] = callback;
      return this;
    }
    registerDropdownCommand(cmd, dropdown) {
      dropdown = dropdown || cmd;
      this.dropdowns.push(dropdown);
      this.registerCommand(cmd, () => {
        this.toggleDropDown(dropdown);
      });
    }
    registerAceCommand(cmd, callback) {
      this.registerCommand(cmd, (cmd2, ace2, item) => {
        ace2.callWithAce((ace3) => {
          callback(cmd2, ace3, item);
        }, cmd2, true);
      });
    }
    triggerCommand(cmd, item) {
      if (this.isEnabled() && this.commands[cmd]) {
        this.commands[cmd](cmd, padeditor.ace, item);
      }
      if (padeditor.ace)
        padeditor.ace.focus();
    }
    // cb is deprecated (this function is synchronous so a callback is unnecessary).
    toggleDropDown(moduleName, cb2 = null) {
      let cbErr = null;
      try {
        if (moduleName === "users" && $("#users").hasClass("stickyUsers")) {
          return;
        }
        $(".nice-select").removeClass("open");
        $(".toolbar-popup").removeClass("popup-show");
        if (moduleName === "none") {
          for (const thisModuleName of this.dropdowns) {
            if (thisModuleName === "users")
              continue;
            const module = $(`#${thisModuleName}`);
            const isAForceReconnectMessage = module.find("button#forcereconnect:visible").length > 0;
            if (isAForceReconnectMessage)
              continue;
            if (module.hasClass("popup-show")) {
              $(`li[data-key=${thisModuleName}] > a`).removeClass("selected");
              module.removeClass("popup-show");
            }
          }
        } else {
          for (const thisModuleName of this.dropdowns) {
            const module = $(`#${thisModuleName}`);
            if (module.hasClass("popup-show")) {
              $(`li[data-key=${thisModuleName}] > a`).removeClass("selected");
              module.removeClass("popup-show");
            } else if (thisModuleName === moduleName) {
              $(`li[data-key=${thisModuleName}] > a`).addClass("selected");
              module.addClass("popup-show");
            }
          }
        }
      } catch (err) {
        cbErr = err || new Error(err);
      } finally {
        if (cb2)
          Promise.resolve().then(() => cb2(cbErr));
      }
    }
    setSyncStatus(status) {
      if (status === "syncing") {
        syncAnimation.syncing();
      } else if (status === "done") {
        syncAnimation.done();
      }
    }
    setEmbedLinks() {
      const padUrl = window.location.href.split("?")[0];
      const params = "?showControls=true&showChat=true&showLineNumbers=true&useMonospaceFont=false";
      const props = 'width="100%" height="600" frameborder="0"';
      if ($("#readonlyinput").is(":checked")) {
        const urlParts = padUrl.split("/");
        urlParts.pop();
        const readonlyLink = `${urlParts.join("/")}/${clientVars.readOnlyId}`;
        $("#embedinput").val(`<iframe name="embed_readonly" src="${readonlyLink}${params}" ${props}></iframe>`);
        $("#linkinput").val(readonlyLink);
      } else {
        $("#embedinput").val(`<iframe name="embed_readwrite" src="${padUrl}${params}" ${props}></iframe>`);
        $("#linkinput").val(padUrl);
      }
    }
    checkAllIconsAreDisplayedInToolbar() {
      $(".toolbar").removeClass("cropped");
      $("body").removeClass("mobile-layout");
      const menuLeft = $(".toolbar .menu_left")[0];
      const menuRightWidth = 280;
      if (menuLeft && menuLeft.scrollWidth > $(".toolbar").width() - menuRightWidth || $(".toolbar").width() < 1e3) {
        $("body").addClass("mobile-layout");
      }
      if (menuLeft && menuLeft.scrollWidth > $(".toolbar").width()) {
        $(".toolbar").addClass("cropped");
      }
    }
    _bodyKeyEvent(evt) {
      if (evt.keyCode === 120 && evt.altKey || evt.keyCode === 27) {
        if ($(":focus").parents(".toolbar").length === 1) {
          this.toggleDropDown("none");
          $(":focus").trigger("blur");
          if (typeof pad === "undefined") {
            $("#editorcontainerbox").trigger("focus");
          } else {
            padeditor.ace.focus();
            evt.preventDefault();
          }
        } else {
          const firstEditbarElement = $("#editbar button").first();
          $(evt.currentTarget).trigger("blur");
          firstEditbarElement.trigger("focus");
          evt.preventDefault();
        }
      }
      if ($(":focus").parents(".toolbar").length === 1) {
        if (evt.keyCode !== 39 && evt.keyCode !== 37)
          return;
        const focusItems = $("#editbar").find("button, select");
        if (evt.keyCode === 37) {
          if ($(".popup").is(":visible") || evt.target.localName === "input")
            return;
          this._editbarPosition--;
          if (this._editbarPosition === -1)
            this._editbarPosition = focusItems.length - 1;
          $(focusItems[this._editbarPosition]).trigger("focus");
        }
        if (evt.keyCode === 39) {
          if ($(".popup").is(":visible") || evt.target.localName === "input")
            return;
          this._editbarPosition++;
          if (this._editbarPosition >= focusItems.length)
            this._editbarPosition = 0;
          $(focusItems[this._editbarPosition]).trigger("focus");
        }
      }
    }
    _registerDefaultCommands() {
      this.registerDropdownCommand("showusers", "users");
      this.registerDropdownCommand("settings");
      this.registerDropdownCommand("connectivity");
      this.registerDropdownCommand("import_export");
      this.registerDropdownCommand("embed");
      this.registerCommand("settings", () => {
        this.toggleDropDown("settings");
        $("#options-stickychat").trigger("focus");
      });
      this.registerCommand("import_export", () => {
        this.toggleDropDown("import_export");
        if ($("#importfileinput").length !== 0) {
          setTimeout(() => {
            $("#importfileinput").trigger("focus");
          }, 100);
        } else {
          $(".exportlink").first().trigger("focus");
        }
      });
      this.registerCommand("showusers", () => {
        this.toggleDropDown("users");
        $("#myusernameedit").trigger("focus");
      });
      this.registerCommand("embed", () => {
        this.setEmbedLinks();
        this.toggleDropDown("embed");
        $("#linkinput").trigger("focus").trigger("select");
      });
      this.registerCommand("savedRevision", () => {
        padsavedrevs.saveNow();
      });
      this.registerCommand("showTimeSlider", () => {
        document.location = `${document.location.pathname}/timeslider`;
      });
      const aceAttributeCommand = (cmd, ace2) => {
        ace2.ace_toggleAttributeOnSelection(cmd);
      };
      this.registerAceCommand("bold", aceAttributeCommand);
      this.registerAceCommand("italic", aceAttributeCommand);
      this.registerAceCommand("underline", aceAttributeCommand);
      this.registerAceCommand("strikethrough", aceAttributeCommand);
      this.registerAceCommand("undo", (cmd, ace2) => {
        ace2.ace_doUndoRedo(cmd);
      });
      this.registerAceCommand("redo", (cmd, ace2) => {
        ace2.ace_doUndoRedo(cmd);
      });
      this.registerAceCommand("insertunorderedlist", (cmd, ace2) => {
        ace2.ace_doInsertUnorderedList();
      });
      this.registerAceCommand("insertorderedlist", (cmd, ace2) => {
        ace2.ace_doInsertOrderedList();
      });
      this.registerAceCommand("indent", (cmd, ace2) => {
        if (!ace2.ace_doIndentOutdent(false)) {
          ace2.ace_doInsertUnorderedList();
        }
      });
      this.registerAceCommand("outdent", (cmd, ace2) => {
        ace2.ace_doIndentOutdent(true);
      });
      this.registerAceCommand("clearauthorship", (cmd, ace2) => {
        const rep = ace2.ace_getRep();
        let doPrompt = false;
        const lastChar = rep.lines.atIndex(rep.lines.length() - 1).width - 1;
        const lastLineIndex = rep.lines.length() - 1;
        if (rep.selStart[0] === 0 && rep.selStart[1] === 0) {
          if (rep.selEnd[0] === lastLineIndex && rep.selEnd[1] === lastChar) {
            doPrompt = true;
          }
        }
        if (!(rep.selStart && rep.selEnd) || ace2.ace_isCaret() || doPrompt) {
          if (window.confirm(html10n.get("pad.editbar.clearcolors"))) {
            ace2.ace_performDocumentApplyAttributesToCharRange(0, ace2.ace_getRep().alltext.length, [
              ["author", ""]
            ]);
          }
        } else {
          ace2.ace_setAttributeOnSelection("author", "");
        }
      });
      this.registerCommand("timeslider_returnToPad", (cmd) => {
        if (document.referrer.length > 0 && document.referrer.substring(
          document.referrer.lastIndexOf("/") - 1,
          document.referrer.lastIndexOf("/")
        ) === "p") {
          document.location = document.referrer;
        } else {
          document.location = document.location.href.substring(0, document.location.href.lastIndexOf("/"));
        }
      });
    }
  }();
  return pad_editbar;
}
var pad_automatic_reconnect = {};
var hasRequiredPad_automatic_reconnect;
function requirePad_automatic_reconnect() {
  if (hasRequiredPad_automatic_reconnect)
    return pad_automatic_reconnect;
  hasRequiredPad_automatic_reconnect = 1;
  pad_automatic_reconnect.showCountDownTimerToReconnectOnModal = ($modal, pad2) => {
    if (clientVars.automaticReconnectionTimeout && $modal.is(".with_reconnect_timer")) {
      createCountDownElementsIfNecessary($modal);
      const timer = createTimerForModal($modal, pad2);
      $modal.find("#cancelreconnect").one("click", () => {
        timer.cancel();
        disableAutomaticReconnection($modal);
      });
      enableAutomaticReconnection($modal);
    }
  };
  const createCountDownElementsIfNecessary = ($modal) => {
    const elementsDoNotExist = $modal.find("#cancelreconnect").length === 0;
    if (elementsDoNotExist) {
      const $defaultMessage = $modal.find("#defaulttext");
      const $reconnectButton = $modal.find("#forcereconnect");
      const $reconnectTimerMessage = $("<p>").addClass("reconnecttimer").append(
        $("<span>").attr("data-l10n-id", "pad.modals.reconnecttimer").text("Trying to reconnect in")
      ).append(" ").append(
        $("<span>").addClass("timetoexpire")
      );
      const $cancelReconnect = $("<button>").attr("id", "cancelreconnect").attr("data-l10n-id", "pad.modals.cancel").text("Cancel");
      localize($reconnectTimerMessage);
      localize($cancelReconnect);
      $reconnectTimerMessage.insertAfter($defaultMessage);
      $cancelReconnect.insertAfter($reconnectButton);
    }
  };
  const localize = ($element) => {
    html10n.translateElement(html10n.translations, $element.get(0));
  };
  const createTimerForModal = ($modal, pad2) => {
    const timeUntilReconnection = clientVars.automaticReconnectionTimeout * reconnectionTries.nextTry();
    const timer = new CountDownTimer(timeUntilReconnection);
    timer.onTick((minutes, seconds) => {
      updateCountDownTimerMessage($modal, minutes, seconds);
    }).onExpire(() => {
      const wasANetworkError = $modal.is(".disconnected");
      if (wasANetworkError) {
        waitUntilClientCanConnectToServerAndThen(() => {
          forceReconnection($modal);
        }, pad2);
      } else {
        forceReconnection($modal);
      }
    }).start();
    return timer;
  };
  const disableAutomaticReconnection = ($modal) => {
    toggleAutomaticReconnectionOption($modal, true);
  };
  const enableAutomaticReconnection = ($modal) => {
    toggleAutomaticReconnectionOption($modal, false);
  };
  const toggleAutomaticReconnectionOption = ($modal, disableAutomaticReconnect) => {
    $modal.find("#cancelreconnect, .reconnecttimer").toggleClass("hidden", disableAutomaticReconnect);
    $modal.find("#defaulttext").toggleClass("hidden", !disableAutomaticReconnect);
  };
  const waitUntilClientCanConnectToServerAndThen = (callback, pad2) => {
    whenConnectionIsRestablishedWithServer(callback, pad2);
    pad2.socket.connect();
  };
  const whenConnectionIsRestablishedWithServer = (callback, pad2) => {
    if (reconnectionTries.counter === 1) {
      pad2.socket.once("connect", callback);
    }
  };
  const forceReconnection = ($modal) => {
    $modal.find("#forcereconnect").trigger("click");
  };
  const updateCountDownTimerMessage = ($modal, minutes, seconds) => {
    minutes = minutes < 10 ? `0${minutes}` : minutes;
    seconds = seconds < 10 ? `0${seconds}` : seconds;
    $modal.find(".timetoexpire").text(`${minutes}:${seconds}`);
  };
  const reconnectionTries = {
    counter: 0,
    nextTry() {
      const nextCounterFactor = 2 ** this.counter;
      this.counter++;
      return nextCounterFactor;
    }
  };
  const CountDownTimer = function(duration, granularity) {
    this.duration = duration;
    this.granularity = granularity || 1e3;
    this.running = false;
    this.onTickCallbacks = [];
    this.onExpireCallbacks = [];
  };
  CountDownTimer.prototype.start = function() {
    if (this.running) {
      return;
    }
    this.running = true;
    const start = Date.now();
    const that = this;
    let diff;
    const timer = () => {
      diff = that.duration - Math.floor((Date.now() - start) / 1e3);
      if (diff > 0) {
        that.timeoutId = setTimeout(timer, that.granularity);
        that.tick(diff);
      } else {
        that.running = false;
        that.tick(0);
        that.expire();
      }
    };
    timer();
  };
  CountDownTimer.prototype.tick = function(diff) {
    const obj = CountDownTimer.parse(diff);
    this.onTickCallbacks.forEach(function(callback) {
      callback.call(this, obj.minutes, obj.seconds);
    }, this);
  };
  CountDownTimer.prototype.expire = function() {
    this.onExpireCallbacks.forEach(function(callback) {
      callback.call(this);
    }, this);
  };
  CountDownTimer.prototype.onTick = function(callback) {
    if (typeof callback === "function") {
      this.onTickCallbacks.push(callback);
    }
    return this;
  };
  CountDownTimer.prototype.onExpire = function(callback) {
    if (typeof callback === "function") {
      this.onExpireCallbacks.push(callback);
    }
    return this;
  };
  CountDownTimer.prototype.cancel = function() {
    this.running = false;
    clearTimeout(this.timeoutId);
    return this;
  };
  CountDownTimer.parse = (seconds) => ({
    minutes: seconds / 60 | 0,
    seconds: seconds % 60 | 0
  });
  return pad_automatic_reconnect;
}
var hasRequiredPad_modals;
function requirePad_modals() {
  if (hasRequiredPad_modals)
    return pad_modals;
  hasRequiredPad_modals = 1;
  const padeditbar = requirePad_editbar().padeditbar;
  const automaticReconnect = requirePad_automatic_reconnect();
  const padmodals = /* @__PURE__ */ (() => {
    let pad2 = void 0;
    const self2 = {
      init: (_pad) => {
        pad2 = _pad;
      },
      showModal: (messageId) => {
        padeditbar.toggleDropDown("none");
        $("#connectivity .visible").removeClass("visible");
        $(`#connectivity .${messageId}`).addClass("visible");
        const $modal = $(`#connectivity .${messageId}`);
        automaticReconnect.showCountDownTimerToReconnectOnModal($modal, pad2);
        padeditbar.toggleDropDown("connectivity");
      },
      showOverlay: () => {
        $("#toolbar-overlay").show();
      },
      hideOverlay: () => {
        $("#toolbar-overlay").hide();
      }
    };
    return self2;
  })();
  pad_modals.padmodals = padmodals;
  return pad_modals;
}
var hasRequiredPad_connectionstatus;
function requirePad_connectionstatus() {
  if (hasRequiredPad_connectionstatus)
    return pad_connectionstatus;
  hasRequiredPad_connectionstatus = 1;
  const padmodals = requirePad_modals().padmodals;
  const padconnectionstatus = /* @__PURE__ */ (() => {
    let status = {
      what: "connecting"
    };
    const self2 = {
      init: () => {
        $("button#forcereconnect").on("click", () => {
          window.location.reload();
        });
      },
      connected: () => {
        status = {
          what: "connected"
        };
        padmodals.showModal("connected");
        padmodals.hideOverlay();
      },
      reconnecting: () => {
        status = {
          what: "reconnecting"
        };
        padmodals.showModal("reconnecting");
        padmodals.showOverlay();
      },
      disconnected: (msg) => {
        if (status.what === "disconnected")
          return;
        status = {
          what: "disconnected",
          why: msg
        };
        const knownReasons = [
          "badChangeset",
          "corruptPad",
          "deleted",
          "disconnected",
          "initsocketfail",
          "looping",
          "rateLimited",
          "rejected",
          "slowcommit",
          "unauth",
          "userdup"
        ];
        let k = String(msg);
        if (knownReasons.indexOf(k) === -1) {
          k = "disconnected";
        }
        padmodals.showModal(k);
        padmodals.showOverlay();
      },
      isFullyConnected: () => status.what === "connected",
      getStatus: () => status
    };
    return self2;
  })();
  pad_connectionstatus.padconnectionstatus = padconnectionstatus;
  return pad_connectionstatus;
}
var pad_impexp = {};
var hasRequiredPad_impexp;
function requirePad_impexp() {
  if (hasRequiredPad_impexp)
    return pad_impexp;
  hasRequiredPad_impexp = 1;
  const padimpexp = /* @__PURE__ */ (() => {
    const addImportFrames = () => {
      $("#import .importframe").remove();
      const iframe = $("<iframe>").css("display", "none").attr("name", "importiframe").addClass("importframe");
      $("#import").append(iframe);
    };
    const fileInputUpdated = () => {
      $("#importsubmitinput").addClass("throbbold");
      $("#importformfilediv").addClass("importformenabled");
      $("#importsubmitinput").prop("disabled", false);
      $("#importmessagefail").fadeOut("fast");
    };
    const fileInputSubmit = function(e) {
      e.preventDefault();
      $("#importmessagefail").fadeOut("fast");
      if (!window.confirm(html10n.get("pad.impexp.confirmimport")))
        return;
      $("#importsubmitinput").attr({ disabled: true }).val(html10n.get("pad.impexp.importing"));
      window.setTimeout(() => $("#importfileinput").attr({ disabled: true }), 0);
      $("#importarrow").stop(true, true).hide();
      $("#importstatusball").show();
      (async () => {
        const { code, message, data: { directDatabaseAccess } = {} } = await $.ajax({
          url: `${window.location.href.split("?")[0].split("#")[0]}/import`,
          method: "POST",
          data: new FormData(this),
          processData: false,
          contentType: false,
          dataType: "json",
          timeout: 25e3
        }).catch((err) => {
          if (err.responseJSON)
            return err.responseJSON;
          return { code: 2, message: "Unknown import error" };
        });
        if (code !== 0) {
          importErrorMessage(message);
        } else {
          $("#import_export").removeClass("popup-show");
          if (directDatabaseAccess)
            window.location.reload();
        }
        $("#importsubmitinput").prop("disabled", false).val(html10n.get("pad.impexp.importbutton"));
        window.setTimeout(() => $("#importfileinput").prop("disabled", false), 0);
        $("#importstatusball").hide();
        addImportFrames();
      })();
    };
    const importErrorMessage = (status) => {
      const known = [
        "convertFailed",
        "uploadFailed",
        "padHasData",
        "maxFileSize",
        "permission"
      ];
      const msg = html10n.get(`pad.impexp.${known.indexOf(status) !== -1 ? status : "copypaste"}`);
      const showError = (fade) => {
        const popup = $("#importmessagefail").empty().append($("<strong>").css("color", "red").text(`${html10n.get("pad.impexp.importfailed")}: `)).append(document.createTextNode(msg));
        popup[fade ? "fadeIn" : "show"]();
      };
      if ($("#importexport .importmessage").is(":visible")) {
        $("#importmessagesuccess").fadeOut("fast");
        $("#importmessagefail").fadeOut("fast", () => showError(true));
      } else {
        showError();
      }
    };
    function cantExport() {
      let type = $(this);
      if (type.hasClass("exporthrefpdf")) {
        type = "PDF";
      } else if (type.hasClass("exporthrefdoc")) {
        type = "Microsoft Word";
      } else if (type.hasClass("exporthrefodt")) {
        type = "OpenDocument";
      } else {
        type = "this file";
      }
      alert(html10n.get("pad.impexp.exportdisabled", { type }));
      return false;
    }
    const self2 = {
      init: (_pad) => {
        const padRootPath = /.*\/p\/[^/]+/.exec(document.location.pathname) || clientVars.padId;
        $("#importsubmitinput").val(html10n.get("pad.impexp.importbutton"));
        html10n.bind("localized", () => {
          $("#importsubmitinput").val(html10n.get("pad.impexp.importbutton"));
        });
        $("#exporthtmla").attr("href", `${padRootPath}/export/html`);
        $("#exportetherpada").attr("href", `${padRootPath}/export/etherpad`);
        $("#exportplaina").attr("href", `${padRootPath}/export/txt`);
        if (clientVars.exportAvailable === "no") {
          $("#exportworda").remove();
          $("#exportpdfa").remove();
          $("#exportopena").remove();
          $("#importmessageabiword").show();
        } else if (clientVars.exportAvailable === "withoutPDF") {
          $("#exportpdfa").remove();
          $("#exportworda").attr("href", `${padRootPath}/export/doc`);
          $("#exportopena").attr("href", `${padRootPath}/export/odt`);
          $("#importexport").css({ height: "142px" });
          $("#importexportline").css({ height: "142px" });
        } else {
          $("#exportworda").attr("href", `${padRootPath}/export/doc`);
          $("#exportpdfa").attr("href", `${padRootPath}/export/pdf`);
          $("#exportopena").attr("href", `${padRootPath}/export/odt`);
        }
        addImportFrames();
        $("#importfileinput").on("change", fileInputUpdated);
        $("#importform").off("submit").on("submit", fileInputSubmit);
        $(".disabledexport").on("click", cantExport);
      },
      disable: () => {
        $("#impexp-disabled-clickcatcher").show();
        $("#import").css("opacity", 0.5);
        $("#impexp-export").css("opacity", 0.5);
      },
      enable: () => {
        $("#impexp-disabled-clickcatcher").hide();
        $("#import").css("opacity", 1);
        $("#impexp-export").css("opacity", 1);
      }
    };
    return self2;
  })();
  pad_impexp.padimpexp = padimpexp;
  return pad_impexp;
}
var pad_userlist = {};
var hasRequiredPad_userlist;
function requirePad_userlist() {
  if (hasRequiredPad_userlist)
    return pad_userlist;
  hasRequiredPad_userlist = 1;
  const padutils = requirePad_utils().padutils;
  const hooks$1 = hooks;
  let myUserInfo = {};
  let colorPickerOpen = false;
  let colorPickerSetup = false;
  const paduserlist = (() => {
    const rowManager = (() => {
      const nextRowId = () => `usertr${nextRowId.counter++}`;
      nextRowId.counter = 1;
      const rowsFadingOut = [];
      const rowsFadingIn = [];
      const rowsPresent = [];
      const ANIMATION_START = -12;
      const ANIMATION_END = 12;
      const animateStep = () => {
        for (let i = rowsFadingIn.length - 1; i >= 0; i--) {
          const row = rowsFadingIn[i];
          const step = ++row.animationStep;
          const animHeight = getAnimationHeight(step, row.animationPower);
          const node = rowNode(row);
          const baseOpacity = row.opacity === void 0 ? 1 : row.opacity;
          if (step <= -OPACITY_STEPS) {
            node.find("td").height(animHeight);
          } else if (step === -OPACITY_STEPS + 1) {
            node.empty().append(createUserRowTds(animHeight, row.data)).find("td").css("opacity", baseOpacity * 1 / OPACITY_STEPS);
          } else if (step < 0) {
            node.find("td").css("opacity", baseOpacity * (OPACITY_STEPS - -step) / OPACITY_STEPS).height(animHeight);
          } else if (step === 0) {
            node.empty().append(createUserRowTds(animHeight, row.data)).find("td").css("opacity", baseOpacity * 1).height(animHeight);
            rowsFadingIn.splice(i, 1);
          }
        }
        for (let i = rowsFadingOut.length - 1; i >= 0; i--) {
          const row = rowsFadingOut[i];
          const step = ++row.animationStep;
          const node = rowNode(row);
          const animHeight = getAnimationHeight(step, row.animationPower);
          const baseOpacity = row.opacity === void 0 ? 1 : row.opacity;
          if (step < OPACITY_STEPS) {
            node.find("td").css("opacity", baseOpacity * (OPACITY_STEPS - step) / OPACITY_STEPS).height(animHeight);
          } else if (step === OPACITY_STEPS) {
            node.empty().append(createEmptyRowTds(animHeight));
          } else if (step <= ANIMATION_END) {
            node.find("td").height(animHeight);
          } else {
            rowsFadingOut.splice(i, 1);
            node.remove();
          }
        }
        handleOtherUserInputs();
        return rowsFadingIn.length > 0 || rowsFadingOut.length > 0;
      };
      const getAnimationHeight = (step, power) => {
        let a = Math.abs(step / 12);
        if (power === 2)
          a **= 2;
        else if (power === 3)
          a **= 3;
        else if (power === 4)
          a **= 4;
        else if (power >= 5)
          a **= 5;
        return Math.round(26 * (1 - a));
      };
      const OPACITY_STEPS = 6;
      const ANIMATION_STEP_TIME = 20;
      const LOWER_FRAMERATE_FACTOR = 2;
      const { scheduleAnimation } = padutils.makeAnimationScheduler(animateStep, ANIMATION_STEP_TIME, LOWER_FRAMERATE_FACTOR);
      const NUMCOLS = 4;
      const createEmptyRowTds = (height) => $("<td>").attr("colspan", NUMCOLS).css("border", 0).css("height", `${height}px`);
      const isNameEditable = (data) => !data.name && data.status !== "Disconnected";
      const replaceUserRowContents = (tr, height, data) => {
        const tds = createUserRowTds(height, data);
        if (isNameEditable(data) && tr.find("td.usertdname input:enabled").length > 0) {
          tds.each((i, td) => {
            const oldTd = $(tr.find("td").get(i));
            if (!oldTd.hasClass("usertdname")) {
              oldTd.replaceWith(td);
            } else {
              $(td).remove();
            }
          });
        } else {
          tr.empty().append(tds);
        }
        return tr;
      };
      const createUserRowTds = (height, data) => {
        let name;
        if (data.name) {
          name = document.createTextNode(data.name);
        } else {
          name = $("<input>").attr("data-l10n-id", "pad.userlist.unnamed").attr("type", "text").addClass("editempty").addClass("newinput").attr("value", html10n.get("pad.userlist.unnamed"));
          if (isNameEditable(data))
            name.attr("disabled", "disabled");
        }
        return $().add($("<td>").css("height", `${height}px`).addClass("usertdswatch").append($("<div>").addClass("swatch").css("background", padutils.escapeHtml(data.color)).html("&nbsp;"))).add($("<td>").css("height", `${height}px`).addClass("usertdname").append(name)).add($("<td>").css("height", `${height}px`).addClass("activity").text(data.activity));
      };
      const createRow = (id, contents, authorId) => $("<tr>").attr("data-authorId", authorId).attr("id", id).append(contents);
      const rowNode = (row) => $(`#${row.domId}`);
      const handleRowData = (row) => {
        if (row.data && row.data.status === "Disconnected") {
          row.opacity = 0.5;
        } else {
          delete row.opacity;
        }
      };
      const handleOtherUserInputs = () => {
        $("#otheruserstable input.newinput").each(function() {
          const input = $(this);
          const tr = input.closest("tr");
          if (tr.length > 0) {
            const index = tr.parent().children().index(tr);
            if (index >= 0) {
              const userId = rowsPresent[index].data.id;
              rowManagerMakeNameEditor($(this), userId);
            }
          }
        }).removeClass("newinput");
      };
      const insertRow = (position, data, animationPower) => {
        position = Math.max(0, Math.min(rowsPresent.length, position));
        animationPower = animationPower === void 0 ? 4 : animationPower;
        const domId = nextRowId();
        const row = {
          data,
          animationStep: ANIMATION_START,
          domId,
          animationPower
        };
        const authorId = data.id;
        handleRowData(row);
        rowsPresent.splice(position, 0, row);
        let tr;
        if (animationPower === 0) {
          tr = createRow(domId, createUserRowTds(getAnimationHeight(0), data), authorId);
          row.animationStep = 0;
        } else {
          rowsFadingIn.push(row);
          tr = createRow(domId, createEmptyRowTds(getAnimationHeight(ANIMATION_START)), authorId);
        }
        $("table#otheruserstable").show();
        if (position === 0) {
          $("table#otheruserstable").prepend(tr);
        } else {
          rowNode(rowsPresent[position - 1]).after(tr);
        }
        if (animationPower !== 0) {
          scheduleAnimation();
        }
        handleOtherUserInputs();
        return row;
      };
      const updateRow = (position, data) => {
        const row = rowsPresent[position];
        if (row) {
          row.data = data;
          handleRowData(row);
          if (row.animationStep === 0) {
            const tr = rowNode(row);
            replaceUserRowContents(tr, getAnimationHeight(0), row.data).find("td").css("opacity", row.opacity === void 0 ? 1 : row.opacity);
            handleOtherUserInputs();
          }
        }
      };
      const removeRow = (position, animationPower) => {
        animationPower = animationPower === void 0 ? 4 : animationPower;
        const row = rowsPresent[position];
        if (row) {
          rowsPresent.splice(position, 1);
          if (animationPower === 0) {
            rowNode(row).remove();
          } else {
            row.animationStep = -row.animationStep;
            row.animationPower = animationPower;
            rowsFadingOut.push(row);
            scheduleAnimation();
          }
        }
        if (rowsPresent.length === 0) {
          $("table#otheruserstable").hide();
        }
      };
      const moveRow = (oldPosition, newPosition, animationPower) => {
        animationPower = animationPower === void 0 ? 1 : animationPower;
        const row = rowsPresent[oldPosition];
        if (row && oldPosition !== newPosition) {
          const rowData = row.data;
          removeRow(oldPosition, animationPower);
          insertRow(newPosition, rowData, animationPower);
        }
      };
      const self3 = {
        insertRow,
        removeRow,
        moveRow,
        updateRow
      };
      return self3;
    })();
    const otherUsersInfo = [];
    const otherUsersData = [];
    const rowManagerMakeNameEditor = (jnode, userId) => {
      setUpEditable(jnode, () => {
        const existingIndex = findExistingIndex(userId);
        if (existingIndex >= 0) {
          return otherUsersInfo[existingIndex].name || "";
        } else {
          return "";
        }
      }, (newName) => {
        if (!newName) {
          jnode.addClass("editempty");
          jnode.val(html10n.get("pad.userlist.unnamed"));
        } else {
          jnode.attr("disabled", "disabled");
          pad2.suggestUserName(userId, newName);
        }
      });
    };
    const findExistingIndex = (userId) => {
      let existingIndex = -1;
      for (let i = 0; i < otherUsersInfo.length; i++) {
        if (otherUsersInfo[i].userId === userId) {
          existingIndex = i;
          break;
        }
      }
      return existingIndex;
    };
    const setUpEditable = (jqueryNode, valueGetter, valueSetter) => {
      jqueryNode.on("focus", (evt) => {
        const oldValue = valueGetter();
        if (jqueryNode.val() !== oldValue) {
          jqueryNode.val(oldValue);
        }
        jqueryNode.addClass("editactive").removeClass("editempty");
      });
      jqueryNode.on("blur", (evt) => {
        const newValue = jqueryNode.removeClass("editactive").val();
        valueSetter(newValue);
      });
      padutils.bindEnterAndEscape(jqueryNode, () => {
        jqueryNode.trigger("blur");
      }, () => {
        jqueryNode.val(valueGetter()).trigger("blur");
      });
      jqueryNode.prop("disabled", false).addClass("editable");
    };
    let pad2 = void 0;
    const self2 = {
      init: (myInitialUserInfo, _pad) => {
        pad2 = _pad;
        self2.setMyUserInfo(myInitialUserInfo);
        if ($("#online_count").length === 0) {
          $("#editbar [data-key=showusers] > a").append('<span id="online_count">1</span>');
        }
        $("#otheruserstable tr").remove();
        $("#myusernameedit").addClass("myusernameedithoverable");
        setUpEditable($("#myusernameedit"), () => myUserInfo.name || "", (newValue) => {
          myUserInfo.name = newValue;
          pad2.notifyChangeName(newValue);
          window.setTimeout(() => {
            self2.renderMyUserInfo();
          }, 0);
        });
        $("#myswatchbox").on("click", showColorPicker);
        $("#mycolorpicker .pickerswatchouter").on("click", function() {
          $("#mycolorpicker .pickerswatchouter").removeClass("picked");
          $(this).addClass("picked");
        });
        $("#mycolorpickersave").on("click", () => {
          closeColorPicker(true);
        });
        $("#mycolorpickercancel").on("click", () => {
          closeColorPicker(false);
        });
      },
      usersOnline: () => {
        const userList = [].concat(otherUsersInfo);
        userList.push(myUserInfo);
        return userList;
      },
      users: () => {
        const userList = self2.usersOnline();
        const historical = clientVars.collab_client_vars.historicalAuthorData;
        for (const [key, { userId }] of Object.entries(historical)) {
          let exists = false;
          userList.forEach((user) => {
            if (user.userId === userId)
              exists = true;
          });
          if (exists === false) {
            userList.push(historical[key]);
          }
        }
        return userList;
      },
      setMyUserInfo: (info) => {
        if (typeof info.colorId === "number") {
          info.colorId = clientVars.colorPalette[info.colorId];
        }
        myUserInfo = $.extend(
          {},
          info
        );
        self2.renderMyUserInfo();
      },
      userJoinOrUpdate: (info) => {
        if (!info.userId || info.userId === myUserInfo.userId) {
          return;
        }
        hooks$1.callAll("userJoinOrUpdate", {
          userInfo: info
        });
        const userData = {};
        userData.color = typeof info.colorId === "number" ? clientVars.colorPalette[info.colorId] : info.colorId;
        userData.name = info.name;
        userData.status = "";
        userData.activity = "";
        userData.id = info.userId;
        const existingIndex = findExistingIndex(info.userId);
        let numUsersBesides = otherUsersInfo.length;
        if (existingIndex >= 0) {
          numUsersBesides--;
        }
        const newIndex = padutils.binarySearch(numUsersBesides, (n) => {
          if (existingIndex >= 0 && n >= existingIndex) {
            n++;
          }
          const infoN = otherUsersInfo[n];
          const nameN = (infoN.name || "").toLowerCase();
          const nameThis = (info.name || "").toLowerCase();
          const idN = infoN.userId;
          const idThis = info.userId;
          return nameN > nameThis || nameN === nameThis && idN > idThis;
        });
        if (existingIndex >= 0) {
          if (existingIndex === newIndex) {
            otherUsersInfo[existingIndex] = info;
            otherUsersData[existingIndex] = userData;
            rowManager.updateRow(existingIndex, userData);
          } else {
            otherUsersInfo.splice(existingIndex, 1);
            otherUsersData.splice(existingIndex, 1);
            otherUsersInfo.splice(newIndex, 0, info);
            otherUsersData.splice(newIndex, 0, userData);
            rowManager.updateRow(existingIndex, userData);
            rowManager.moveRow(existingIndex, newIndex);
          }
        } else {
          otherUsersInfo.splice(newIndex, 0, info);
          otherUsersData.splice(newIndex, 0, userData);
          rowManager.insertRow(newIndex, userData);
        }
        self2.updateNumberOfOnlineUsers();
      },
      updateNumberOfOnlineUsers: () => {
        let online = 1;
        for (let i = 0; i < otherUsersData.length; i++) {
          if (otherUsersData[i].status === "") {
            online++;
          }
        }
        $("#online_count").text(online);
        return online;
      },
      userLeave: (info) => {
        const existingIndex = findExistingIndex(info.userId);
        if (existingIndex >= 0) {
          const userData = otherUsersData[existingIndex];
          userData.status = "Disconnected";
          rowManager.updateRow(existingIndex, userData);
          if (userData.leaveTimer) {
            window.clearTimeout(userData.leaveTimer);
          }
          const thisUserId = info.userId;
          const thisLeaveTimer = window.setTimeout(() => {
            const newExistingIndex = findExistingIndex(thisUserId);
            if (newExistingIndex >= 0) {
              const newUserData = otherUsersData[newExistingIndex];
              if (newUserData.status === "Disconnected" && newUserData.leaveTimer === thisLeaveTimer) {
                otherUsersInfo.splice(newExistingIndex, 1);
                otherUsersData.splice(newExistingIndex, 1);
                rowManager.removeRow(newExistingIndex);
                hooks$1.callAll("userLeave", {
                  userInfo: info
                });
              }
            }
          }, 8e3);
          userData.leaveTimer = thisLeaveTimer;
        }
        self2.updateNumberOfOnlineUsers();
      },
      renderMyUserInfo: () => {
        if (myUserInfo.name) {
          $("#myusernameedit").removeClass("editempty").val(myUserInfo.name);
        } else {
          $("#myusernameedit").attr("placeholder", html10n.get("pad.userlist.entername"));
        }
        if (colorPickerOpen) {
          $("#myswatchbox").addClass("myswatchboxunhoverable").removeClass("myswatchboxhoverable");
        } else {
          $("#myswatchbox").addClass("myswatchboxhoverable").removeClass("myswatchboxunhoverable");
        }
        $("#myswatch").css({ "background-color": myUserInfo.colorId });
        $("li[data-key=showusers] > a").css({ "box-shadow": `inset 0 0 30px ${myUserInfo.colorId}` });
      }
    };
    return self2;
  })();
  const getColorPickerSwatchIndex = (jnode) => $("#colorpickerswatches li").index(jnode);
  const closeColorPicker = (accept) => {
    if (accept) {
      let newColor = $("#mycolorpickerpreview").css("background-color");
      const parts = newColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (parts) {
        delete parts[0];
        for (let i = 1; i <= 3; ++i) {
          parts[i] = parseInt(parts[i]).toString(16);
          if (parts[i].length === 1)
            parts[i] = `0${parts[i]}`;
        }
        newColor = `#${parts.join("")}`;
      }
      myUserInfo.colorId = newColor;
      pad.notifyChangeColor(newColor);
      paduserlist.renderMyUserInfo();
    }
    colorPickerOpen = false;
    $("#mycolorpicker").removeClass("popup-show");
  };
  const showColorPicker = () => {
    $.farbtastic("#colorpicker").setColor(myUserInfo.colorId);
    if (!colorPickerOpen) {
      const palette = pad.getColorPalette();
      if (!colorPickerSetup) {
        const colorsList = $("#colorpickerswatches");
        for (let i = 0; i < palette.length; i++) {
          const li = $("<li>", {
            style: `background: ${palette[i]};`
          });
          li.appendTo(colorsList);
          li.on("click", (event) => {
            $("#colorpickerswatches li").removeClass("picked");
            $(event.target).addClass("picked");
            const newColorId = getColorPickerSwatchIndex($("#colorpickerswatches .picked"));
            pad.notifyChangeColor(newColorId);
          });
        }
        colorPickerSetup = true;
      }
      $("#mycolorpicker").addClass("popup-show");
      colorPickerOpen = true;
      $("#colorpickerswatches li").removeClass("picked");
      $($("#colorpickerswatches li")[myUserInfo.colorId]).addClass("picked");
    }
  };
  pad_userlist.paduserlist = paduserlist;
  return pad_userlist;
}
class SocketIoWrapper {
  constructor() {
    __publicField(this, "socket");
    __publicField(this, "eventCallbacks", {});
    this.socket = new WebSocket("ws://localhost:3000/socket.io/");
    this.socket.onopen = () => {
      console.log("onopen");
      const iID = window.setInterval(() => {
        console.log("check");
        if (this.eventCallbacks["connect"] && this.eventCallbacks["connect"].length == 1) {
          console.log("Handled connect event");
          this.eventCallbacks["connect"].forEach((callback) => {
            callback();
          });
          clearInterval(iID);
        }
      }, 200);
    };
    this.socket.onmessage = (e) => {
      const arr = JSON.parse(e.data);
      this.eventCallbacks[arr[0]].forEach((f) => {
        f(arr[1]);
      });
    };
  }
  connect() {
    console.log("connect");
  }
  once(event, callback) {
    if (this.eventCallbacks[event]) {
      this.eventCallbacks[event].push(callback);
    } else {
      this.eventCallbacks[event] = [callback];
    }
  }
  on(event, callback) {
    console.log(event);
    if (this.eventCallbacks[event]) {
      this.eventCallbacks[event].push(callback);
    } else {
      this.eventCallbacks[event] = [callback];
    }
  }
  emit(event, data) {
    this.socket.send(JSON.stringify({ event, data }));
  }
  off() {
    console.log("Off");
  }
}
const connect = (etherpadBaseUrl, namespace = "/", options = {}) => {
  const baseUrl = new URL(etherpadBaseUrl, window.location);
  const socketioUrl = new URL("socket.io", baseUrl);
  new URL(namespace, new URL("/", baseUrl));
  let socketOptions = {
    path: socketioUrl.pathname,
    upgrade: true,
    transports: ["websocket"]
  };
  Object.assign(options, socketOptions);
  window.socket = new SocketIoWrapper();
  socket.on("connect_error", (error) => {
    console.log("Error connecting to pad", error);
  });
  return socket;
};
const socketio = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  connect
}, Symbol.toStringTag, { value: "Module" }));
var hasRequiredPad;
function requirePad() {
  if (hasRequiredPad)
    return pad$1;
  hasRequiredPad = 1;
  (function(exports) {
    let socket2;
    requireFarbtastic();
    requireGritter();
    const Cookies = requirePad_utils().Cookies;
    const chat2 = requireChat().chat;
    const getCollabClient = requireCollab_client().getCollabClient;
    const padconnectionstatus = requirePad_connectionstatus().padconnectionstatus;
    const padcookie = requirePad_cookie().padcookie;
    const padeditbar = requirePad_editbar().padeditbar;
    const padeditor = requirePad_editor().padeditor;
    const padimpexp = requirePad_impexp().padimpexp;
    const padmodals = requirePad_modals().padmodals;
    const padsavedrevs = requirePad_savedrevs();
    const paduserlist = requirePad_userlist().paduserlist;
    const padutils = requirePad_utils().padutils;
    const colorutils2 = requireColorutils().colorutils;
    const randomString = requirePad_utils().randomString;
    const socketio$1 = socketio;
    const hooks$1 = hooks;
    const getParameters = [
      {
        name: "noColors",
        checkVal: "true",
        callback: (val) => {
          settings.noColors = true;
          $("#clearAuthorship").hide();
        }
      },
      {
        name: "showControls",
        checkVal: "true",
        callback: (val) => {
          $("#editbar").css("display", "flex");
        }
      },
      {
        name: "showChat",
        checkVal: null,
        callback: (val) => {
          if (val === "false") {
            settings.hideChat = true;
            chat2.hide();
            $("#chaticon").hide();
          }
        }
      },
      {
        name: "showLineNumbers",
        checkVal: "false",
        callback: (val) => {
          settings.LineNumbersDisabled = true;
        }
      },
      {
        name: "useMonospaceFont",
        checkVal: "true",
        callback: (val) => {
          settings.useMonospaceFontGlobal = true;
        }
      },
      {
        name: "userName",
        checkVal: null,
        callback: (val) => {
          settings.globalUserName = val;
          clientVars.userName = val;
        }
      },
      {
        name: "userColor",
        checkVal: null,
        callback: (val) => {
          settings.globalUserColor = val;
          clientVars.userColor = val;
        }
      },
      {
        name: "rtl",
        checkVal: "true",
        callback: (val) => {
          settings.rtlIsTrue = true;
        }
      },
      {
        name: "alwaysShowChat",
        checkVal: "true",
        callback: (val) => {
          if (!settings.hideChat)
            chat2.stickToScreen();
        }
      },
      {
        name: "chatAndUsers",
        checkVal: "true",
        callback: (val) => {
          chat2.chatAndUsers();
        }
      },
      {
        name: "lang",
        checkVal: null,
        callback: (val) => {
          window.html10n.localize([val, "en"]);
          Cookies.set("language", val);
        }
      }
    ];
    const getParams = () => {
      for (const setting of getParameters) {
        let value = clientVars.padOptions[setting.name];
        if (value == null)
          continue;
        value = value.toString();
        if (value === setting.checkVal || setting.checkVal == null) {
          setting.callback(value);
        }
      }
      const params = getUrlVars();
      for (const setting of getParameters) {
        const value = params.get(setting.name);
        if (value && (value === setting.checkVal || setting.checkVal == null)) {
          setting.callback(value);
        }
      }
    };
    const getUrlVars = () => new URL(window.location.href).searchParams;
    const sendClientReady = (isReconnect) => {
      let padId = document.location.pathname.substring(document.location.pathname.lastIndexOf("/") + 1);
      padId = decodeURIComponent(padId);
      if (!isReconnect) {
        const titleArray = document.title.split("|");
        const title = titleArray[titleArray.length - 1];
        document.title = `${padId.replace(/_+/g, " ")} | ${title}`;
      }
      let token = Cookies.get("token");
      if (token == null || !padutils.isValidAuthorToken(token)) {
        token = padutils.generateAuthorToken();
        Cookies.set("token", token, { expires: 60 });
      }
      const params = getUrlVars();
      const userInfo = {
        colorId: params.get("userColor"),
        name: params.get("userName")
      };
      const msg = {
        component: "pad",
        type: "CLIENT_READY",
        padId,
        sessionID: Cookies.get("sessionID"),
        token,
        userInfo
      };
      if (isReconnect) {
        msg.client_rev = pad2.collabClient.getCurrentRevisionNumber();
        msg.reconnect = true;
      }
      socket2.emit("message", msg);
    };
    const handshake = async () => {
      let receivedClientVars = false;
      let padId = document.location.pathname.substring(document.location.pathname.lastIndexOf("/") + 1);
      padId = decodeURIComponent(padId);
      socket2 = pad2.socket = socketio$1.connect(exports.baseURL, "/", {
        query: { padId },
        reconnectionAttempts: 5,
        reconnection: true,
        reconnectionDelay: 1e3,
        reconnectionDelayMax: 5e3
      });
      socket2.once("connect", () => {
        sendClientReady(false);
      });
      socket2.on("reconnect", () => {
        if (pad2.collabClient != null) {
          pad2.collabClient.setChannelState("CONNECTED");
        }
        sendClientReady(receivedClientVars);
      });
      const socketReconnecting = () => {
        if (pad2.collabClient != null) {
          pad2.collabClient.setStateIdle();
          pad2.collabClient.setIsPendingRevision(true);
          pad2.collabClient.setChannelState("RECONNECTING");
        }
      };
      socket2.on("disconnect", (reason) => {
        console.log(`Socket disconnected: ${reason}`);
        if (reason !== "io server disconnect" || reason !== "ping timeout")
          return;
        socketReconnecting();
        socket2.connect();
      });
      socket2.on("shout", (obj) => {
        if (obj.type === "COLLABROOM") {
          let date = new Date(obj.data.payload.timestamp);
          $.gritter.add({
            // (string | mandatory) the heading of the notification
            title: "Admin message",
            // (string | mandatory) the text inside the notification
            text: "[" + date.toLocaleTimeString() + "]: " + obj.data.payload.message.message,
            // (bool | optional) if you want it to fade out on its own or just sit there
            sticky: obj.data.payload.message.sticky
          });
        }
      });
      socket2.on("reconnecting", socketReconnecting);
      socket2.on("reconnect_failed", (error) => {
        if (pad2.collabClient != null) {
          pad2.collabClient.setChannelState("DISCONNECTED", "reconnect_timeout");
        } else {
          throw new Error("Reconnect timed out");
        }
      });
      socket2.on("error", (error) => {
        if (pad2.collabClient != null) {
          pad2.collabClient.setStateIdle();
          pad2.collabClient.setIsPendingRevision(true);
        }
      });
      socket2.on("message", (obj) => {
        console.log("Incoming message is", obj);
        if (obj.accessStatus) {
          if (obj.accessStatus === "deny") {
            $("#loading").hide();
            $("#permissionDenied").show();
            if (receivedClientVars) {
              $("#editorcontainer").hide();
              $("#editorloadingbox").show();
            }
          }
        } else if (!receivedClientVars && obj.type === "CLIENT_VARS") {
          console.log("Received client vars");
          receivedClientVars = true;
          window.clientVars = obj.data;
          if (window.clientVars.sessionRefreshInterval) {
            const ping = () => $.ajax("../_extendExpressSessionLifetime", { method: "PUT" }).catch(() => {
            });
            setInterval(ping, window.clientVars.sessionRefreshInterval);
          }
        } else if (obj.disconnect) {
          padconnectionstatus.disconnected(obj.disconnect);
          socket2.disconnect();
          padeditor.disable();
          padeditbar.disable();
          padimpexp.disable();
          return;
        } else {
          pad2._messageQ.enqueue(obj);
        }
      });
      await Promise.all([
        new Promise((resolve) => {
          const h = (obj) => {
            console.log("Incoming message is");
            if (obj.accessStatus || obj.type !== "CLIENT_VARS")
              return;
            socket2.off("message", h);
            resolve();
          };
          socket2.on("message", h);
        }),
        // This hook is only intended to be used by test code. If a plugin would like to use this hook,
        // the hook must first be promoted to officially supported by deleting the leading underscore
        // from the name, adding documentation to `doc/api/hooks_client-side.md`, and deleting this
        // comment.
        hooks$1.aCallAll("_socketCreated", { socket: socket2 })
      ]);
    };
    class MessageQueue {
      constructor() {
        this._q = [];
        this._cc = null;
      }
      setCollabClient(cc) {
        this._cc = cc;
        this.enqueue();
      }
      enqueue(...msgs) {
        if (this._cc == null) {
          this._q.push(...msgs);
        } else {
          while (this._q.length > 0)
            this._cc.handleMessageFromServer(this._q.shift());
          for (const msg of msgs)
            this._cc.handleMessageFromServer(msg);
        }
      }
    }
    const pad2 = {
      // don't access these directly from outside this file, except
      // for debugging
      collabClient: null,
      myUserInfo: null,
      diagnosticInfo: {},
      initTime: 0,
      clientTimeOffset: null,
      padOptions: {},
      _messageQ: new MessageQueue(),
      // these don't require init; clientVars should all go through here
      getPadId: () => clientVars.padId,
      getClientIp: () => clientVars.clientIp,
      getColorPalette: () => clientVars.colorPalette,
      getPrivilege: (name) => clientVars.accountPrivs[name],
      getUserId: () => pad2.myUserInfo.userId,
      getUserName: () => pad2.myUserInfo.name,
      userList: () => paduserlist.users(),
      sendClientMessage: (msg) => {
        pad2.collabClient.sendClientMessage(msg);
      },
      init() {
        padutils.setupGlobalExceptionHandler();
        $(() => (async () => {
          if (window.customStart != null)
            window.customStart();
          $("#colorpicker").farbtastic({ callback: "#mycolorpickerpreview", width: 220 });
          $("#readonlyinput").on("click", () => {
            padeditbar.setEmbedLinks();
          });
          padcookie.init();
          await handshake();
          this._afterHandshake();
        })());
      },
      _afterHandshake() {
        pad2.clientTimeOffset = Date.now() - clientVars.serverTimestamp;
        chat2.init(this);
        getParams();
        padcookie.init();
        pad2.initTime = +/* @__PURE__ */ new Date();
        pad2.padOptions = clientVars.initialOptions;
        pad2.myUserInfo = {
          userId: clientVars.userId,
          name: clientVars.userName,
          ip: pad2.getClientIp(),
          colorId: clientVars.userColor
        };
        const postAceInit = () => {
          padeditbar.init();
          setTimeout(() => {
            padeditor.ace.focus();
          }, 0);
          const optionsStickyChat = $("#options-stickychat");
          optionsStickyChat.on("click", () => {
            chat2.stickToScreen();
          });
          if (padcookie.getPref("chatAlwaysVisible")) {
            chat2.stickToScreen(true);
            optionsStickyChat.prop("checked", true);
          }
          if (padcookie.getPref("chatAndUsers")) {
            chat2.chatAndUsers(true);
            $("#options-chatandusers").prop("checked", true);
          }
          if (padcookie.getPref("showAuthorshipColors") === false) {
            pad2.changeViewOption("showAuthorColors", false);
          }
          if (padcookie.getPref("showLineNumbers") === false) {
            pad2.changeViewOption("showLineNumbers", false);
          }
          if (padcookie.getPref("rtlIsTrue") === true) {
            pad2.changeViewOption("rtlIsTrue", true);
          }
          pad2.changeViewOption("padFontFamily", padcookie.getPref("padFontFamily"));
          $("#viewfontmenu").val(padcookie.getPref("padFontFamily")).niceSelect("update");
          const checkChatAndUsersVisibility = (x) => {
            if (x.matches) {
              $("#options-chatandusers:checked").trigger("click");
              $("#options-stickychat:checked").trigger("click");
            }
          };
          const mobileMatch = window.matchMedia("(max-width: 800px)");
          mobileMatch.addListener(checkChatAndUsersVisibility);
          setTimeout(() => {
            checkChatAndUsersVisibility(mobileMatch);
          }, 0);
          $("#editorcontainer").addClass("initialized");
          hooks$1.aCallAll("postAceInit", { ace: padeditor.ace, clientVars, pad: pad2 });
        };
        padimpexp.init(this);
        padsavedrevs.init(this);
        padeditor.init(pad2.padOptions.view || {}, this).then(postAceInit);
        paduserlist.init(pad2.myUserInfo, this);
        padconnectionstatus.init();
        padmodals.init(this);
        pad2.collabClient = getCollabClient(
          padeditor.ace,
          clientVars.collab_client_vars,
          pad2.myUserInfo,
          { colorPalette: pad2.getColorPalette() },
          pad2
        );
        this._messageQ.setCollabClient(this.collabClient);
        pad2.collabClient.setOnUserJoin(pad2.handleUserJoin);
        pad2.collabClient.setOnUpdateUserInfo(pad2.handleUserUpdate);
        pad2.collabClient.setOnUserLeave(pad2.handleUserLeave);
        pad2.collabClient.setOnClientMessage(pad2.handleClientMessage);
        pad2.collabClient.setOnChannelStateChange(pad2.handleChannelStateChange);
        pad2.collabClient.setOnInternalAction(pad2.handleCollabAction);
        if (clientVars.chatHead !== -1) {
          const chatHead = clientVars.chatHead;
          const start = Math.max(chatHead - 100, 0);
          pad2.collabClient.sendMessage({ type: "GET_CHAT_MESSAGES", start, end: chatHead });
        } else {
          $("#chatloadmessagesbutton").css("display", "none");
        }
        if (window.clientVars.readonly) {
          chat2.hide();
          $("#myusernameedit").attr("disabled", true);
          $("#chatinput").attr("disabled", true);
          $("#chaticon").hide();
          $("#options-chatandusers").parent().hide();
          $("#options-stickychat").parent().hide();
        } else if (!settings.hideChat) {
          $("#chaticon").show();
        }
        $("body").addClass(window.clientVars.readonly ? "readonly" : "readwrite");
        padeditor.ace.callWithAce((ace2) => {
          ace2.ace_setEditable(!window.clientVars.readonly);
        });
        if (settings.LineNumbersDisabled === true) {
          this.changeViewOption("showLineNumbers", false);
        }
        if (settings.noColors === true) {
          this.changeViewOption("noColors", true);
        }
        if (settings.rtlIsTrue === true) {
          this.changeViewOption("rtlIsTrue", true);
        }
        if (settings.useMonospaceFontGlobal === true) {
          this.changeViewOption("padFontFamily", "RobotoMono");
        }
        if (settings.globalUserName !== false) {
          this.notifyChangeName(settings.globalUserName);
          this.myUserInfo.name = settings.globalUserName;
          $("#myusernameedit").val(settings.globalUserName);
        }
        if (settings.globalUserColor !== false && colorutils2.isCssHex(settings.globalUserColor)) {
          this.myUserInfo.globalUserColor = settings.globalUserColor;
          this.notifyChangeColor(settings.globalUserColor);
          paduserlist.setMyUserInfo(this.myUserInfo);
        }
      },
      dispose: () => {
        padeditor.dispose();
      },
      notifyChangeName: (newName) => {
        pad2.myUserInfo.name = newName;
        pad2.collabClient.updateUserInfo(pad2.myUserInfo);
      },
      notifyChangeColor: (newColorId) => {
        pad2.myUserInfo.colorId = newColorId;
        pad2.collabClient.updateUserInfo(pad2.myUserInfo);
      },
      changePadOption: (key, value) => {
        const options = {};
        options[key] = value;
        pad2.handleOptionsChange(options);
        pad2.collabClient.sendClientMessage(
          {
            type: "padoptions",
            options,
            changedBy: pad2.myUserInfo.name || "unnamed"
          }
        );
      },
      changeViewOption: (key, value) => {
        const options = {
          view: {}
        };
        options.view[key] = value;
        pad2.handleOptionsChange(options);
      },
      handleOptionsChange: (opts) => {
        if (opts.view) {
          if (!pad2.padOptions.view) {
            pad2.padOptions.view = {};
          }
          for (const [k, v] of Object.entries(opts.view)) {
            pad2.padOptions.view[k] = v;
            padcookie.setPref(k, v);
          }
          padeditor.setViewOptions(pad2.padOptions.view);
        }
      },
      // caller shouldn't mutate the object
      getPadOptions: () => pad2.padOptions,
      suggestUserName: (userId, name) => {
        pad2.collabClient.sendClientMessage(
          {
            type: "suggestUserName",
            unnamedId: userId,
            newName: name
          }
        );
      },
      handleUserJoin: (userInfo) => {
        paduserlist.userJoinOrUpdate(userInfo);
      },
      handleUserUpdate: (userInfo) => {
        paduserlist.userJoinOrUpdate(userInfo);
      },
      handleUserLeave: (userInfo) => {
        paduserlist.userLeave(userInfo);
      },
      handleClientMessage: (msg) => {
        if (msg.type === "suggestUserName") {
          if (msg.unnamedId === pad2.myUserInfo.userId && msg.newName && !pad2.myUserInfo.name) {
            pad2.notifyChangeName(msg.newName);
            paduserlist.setMyUserInfo(pad2.myUserInfo);
          }
        } else if (msg.type === "newRevisionList") {
          padsavedrevs.newRevisionList(msg.revisionList);
        } else if (msg.type === "revisionLabel") {
          padsavedrevs.newRevisionList(msg.revisionList);
        } else if (msg.type === "padoptions") {
          const opts = msg.options;
          pad2.handleOptionsChange(opts);
        }
      },
      handleChannelStateChange: (newState, message) => {
        const oldFullyConnected = !!padconnectionstatus.isFullyConnected();
        const wasConnecting = padconnectionstatus.getStatus().what === "connecting";
        if (newState === "CONNECTED") {
          padeditor.enable();
          padeditbar.enable();
          padimpexp.enable();
          padconnectionstatus.connected();
        } else if (newState === "RECONNECTING") {
          padeditor.disable();
          padeditbar.disable();
          padimpexp.disable();
          padconnectionstatus.reconnecting();
        } else if (newState === "DISCONNECTED") {
          pad2.diagnosticInfo.disconnectedMessage = message;
          pad2.diagnosticInfo.padId = pad2.getPadId();
          pad2.diagnosticInfo.socket = {};
          for (const [i, value] of Object.entries(socket2.socket || {})) {
            const type = typeof value;
            if (type === "string" || type === "number") {
              pad2.diagnosticInfo.socket[i] = value;
            }
          }
          pad2.asyncSendDiagnosticInfo();
          if (typeof window.ajlog === "string") {
            window.ajlog += `Disconnected: ${message}
`;
          }
          padeditor.disable();
          padeditbar.disable();
          padimpexp.disable();
          padconnectionstatus.disconnected(message);
        }
        const newFullyConnected = !!padconnectionstatus.isFullyConnected();
        if (newFullyConnected !== oldFullyConnected) {
          pad2.handleIsFullyConnected(newFullyConnected, wasConnecting);
        }
      },
      handleIsFullyConnected: (isConnected, isInitialConnect) => {
        pad2.determineChatVisibility(isConnected && !isInitialConnect);
        pad2.determineChatAndUsersVisibility(isConnected && !isInitialConnect);
        pad2.determineAuthorshipColorsVisibility();
        setTimeout(() => {
          padeditbar.toggleDropDown("none");
        }, 1e3);
      },
      determineChatVisibility: (asNowConnectedFeedback) => {
        const chatVisCookie = padcookie.getPref("chatAlwaysVisible");
        if (chatVisCookie) {
          chat2.stickToScreen(true);
          $("#options-stickychat").prop("checked", true);
        } else {
          $("#options-stickychat").prop("checked", false);
        }
      },
      determineChatAndUsersVisibility: (asNowConnectedFeedback) => {
        const chatAUVisCookie = padcookie.getPref("chatAndUsersVisible");
        if (chatAUVisCookie) {
          chat2.chatAndUsers(true);
          $("#options-chatandusers").prop("checked", true);
        } else {
          $("#options-chatandusers").prop("checked", false);
        }
      },
      determineAuthorshipColorsVisibility: () => {
        const authColCookie = padcookie.getPref("showAuthorshipColors");
        if (authColCookie) {
          pad2.changeViewOption("showAuthorColors", true);
          $("#options-colorscheck").prop("checked", true);
        } else {
          $("#options-colorscheck").prop("checked", false);
        }
      },
      handleCollabAction: (action) => {
        if (action === "commitPerformed") {
          padeditbar.setSyncStatus("syncing");
        } else if (action === "newlyIdle") {
          padeditbar.setSyncStatus("done");
        }
      },
      asyncSendDiagnosticInfo: () => {
        window.setTimeout(() => {
          $.ajax(
            {
              type: "post",
              url: "ep/pad/connection-diagnostic-info",
              data: {
                diagnosticInfo: JSON.stringify(pad2.diagnosticInfo)
              },
              success: () => {
              },
              error: () => {
              }
            }
          );
        }, 0);
      },
      forceReconnect: () => {
        $("form#reconnectform input.padId").val(pad2.getPadId());
        pad2.diagnosticInfo.collabDiagnosticInfo = pad2.collabClient.getDiagnosticInfo();
        $("form#reconnectform input.diagnosticInfo").val(JSON.stringify(pad2.diagnosticInfo));
        $("form#reconnectform input.missedChanges").val(JSON.stringify(pad2.collabClient.getMissedChanges()));
        $("form#reconnectform").trigger("submit");
      },
      callWhenNotCommitting: (f) => {
        pad2.collabClient.callWhenNotCommitting(f);
      },
      getCollabRevisionNumber: () => pad2.collabClient.getCurrentRevisionNumber(),
      isFullyConnected: () => padconnectionstatus.isFullyConnected(),
      addHistoricalAuthors: (data) => {
        if (!pad2.collabClient) {
          window.setTimeout(() => {
            pad2.addHistoricalAuthors(data);
          }, 1e3);
        } else {
          pad2.collabClient.addHistoricalAuthors(data);
        }
      }
    };
    const init = () => pad2.init();
    const settings = {
      LineNumbersDisabled: false,
      noColors: false,
      useMonospaceFontGlobal: false,
      globalUserName: false,
      globalUserColor: false,
      rtlIsTrue: false
    };
    pad2.settings = settings;
    exports.baseURL = "";
    exports.settings = settings;
    exports.randomString = randomString;
    exports.getParams = getParams;
    exports.pad = pad2;
    exports.init = init;
  })(pad$1);
  return pad$1;
}
var cjs$3 = { exports: {} };
var url = {};
var cjs$2 = {};
var socket$2 = {};
var transports = {};
var polling = {};
var transport = {};
var cjs$1 = {};
var encodePacket_browser = {};
var commons = {};
var hasRequiredCommons;
function requireCommons() {
  if (hasRequiredCommons)
    return commons;
  hasRequiredCommons = 1;
  Object.defineProperty(commons, "__esModule", { value: true });
  commons.ERROR_PACKET = commons.PACKET_TYPES_REVERSE = commons.PACKET_TYPES = void 0;
  const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
  commons.PACKET_TYPES = PACKET_TYPES;
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
  commons.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  const ERROR_PACKET = { type: "error", data: "parser error" };
  commons.ERROR_PACKET = ERROR_PACKET;
  return commons;
}
var hasRequiredEncodePacket_browser;
function requireEncodePacket_browser() {
  if (hasRequiredEncodePacket_browser)
    return encodePacket_browser;
  hasRequiredEncodePacket_browser = 1;
  Object.defineProperty(encodePacket_browser, "__esModule", { value: true });
  encodePacket_browser.encodePacket = encodePacket_browser.encodePacketToBinary = void 0;
  const commons_js_1 = requireCommons();
  const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    }
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
  };
  encodePacket_browser.encodePacket = encodePacket;
  const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function() {
      const content = fileReader.result.split(",")[1];
      callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
  };
  function toArray2(data) {
    if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    } else {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  let TEXT_ENCODER;
  function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
      return packet.data.arrayBuffer().then(toArray2).then(callback);
    } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
      return callback(toArray2(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
      if (!TEXT_ENCODER) {
        TEXT_ENCODER = new TextEncoder();
      }
      callback(TEXT_ENCODER.encode(encoded));
    });
  }
  encodePacket_browser.encodePacketToBinary = encodePacketToBinary;
  return encodePacket_browser;
}
var decodePacket_browser = {};
var base64Arraybuffer = {};
var hasRequiredBase64Arraybuffer;
function requireBase64Arraybuffer() {
  if (hasRequiredBase64Arraybuffer)
    return base64Arraybuffer;
  hasRequiredBase64Arraybuffer = 1;
  Object.defineProperty(base64Arraybuffer, "__esModule", { value: true });
  base64Arraybuffer.decode = base64Arraybuffer.encode = void 0;
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  base64Arraybuffer.encode = encode;
  const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i + 1)];
      encoded3 = lookup[base64.charCodeAt(i + 2)];
      encoded4 = lookup[base64.charCodeAt(i + 3)];
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
  base64Arraybuffer.decode = decode;
  return base64Arraybuffer;
}
var hasRequiredDecodePacket_browser;
function requireDecodePacket_browser() {
  if (hasRequiredDecodePacket_browser)
    return decodePacket_browser;
  hasRequiredDecodePacket_browser = 1;
  Object.defineProperty(decodePacket_browser, "__esModule", { value: true });
  decodePacket_browser.decodePacket = void 0;
  const commons_js_1 = requireCommons();
  const base64_arraybuffer_js_1 = requireBase64Arraybuffer();
  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
      return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: commons_js_1.PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: commons_js_1.PACKET_TYPES_REVERSE[type]
    };
  };
  decodePacket_browser.decodePacket = decodePacket;
  const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
      const decoded = (0, base64_arraybuffer_js_1.decode)(data);
      return mapBinary(decoded, binaryType);
    } else {
      return { base64: true, data };
    }
  };
  const mapBinary = (data, binaryType) => {
    switch (binaryType) {
      case "blob":
        if (data instanceof Blob) {
          return data;
        } else {
          return new Blob([data]);
        }
      case "arraybuffer":
      default:
        if (data instanceof ArrayBuffer) {
          return data;
        } else {
          return data.buffer;
        }
    }
  };
  return decodePacket_browser;
}
var hasRequiredCjs$3;
function requireCjs$3() {
  if (hasRequiredCjs$3)
    return cjs$1;
  hasRequiredCjs$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = exports.createPacketDecoderStream = exports.createPacketEncoderStream = void 0;
    const encodePacket_js_1 = requireEncodePacket_browser();
    Object.defineProperty(exports, "encodePacket", { enumerable: true, get: function() {
      return encodePacket_js_1.encodePacket;
    } });
    const decodePacket_js_1 = requireDecodePacket_browser();
    Object.defineProperty(exports, "decodePacket", { enumerable: true, get: function() {
      return decodePacket_js_1.decodePacket;
    } });
    const commons_js_1 = requireCommons();
    const SEPARATOR = String.fromCharCode(30);
    const encodePayload = (packets, callback) => {
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports.encodePayload = encodePayload;
    const decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports.decodePayload = decodePayload;
    function createPacketEncoderStream() {
      return new TransformStream({
        transform(packet, controller) {
          (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
            const payloadLength = encodedPacket.length;
            let header;
            if (payloadLength < 126) {
              header = new Uint8Array(1);
              new DataView(header.buffer).setUint8(0, payloadLength);
            } else if (payloadLength < 65536) {
              header = new Uint8Array(3);
              const view = new DataView(header.buffer);
              view.setUint8(0, 126);
              view.setUint16(1, payloadLength);
            } else {
              header = new Uint8Array(9);
              const view = new DataView(header.buffer);
              view.setUint8(0, 127);
              view.setBigUint64(1, BigInt(payloadLength));
            }
            if (packet.data && typeof packet.data !== "string") {
              header[0] |= 128;
            }
            controller.enqueue(header);
            controller.enqueue(encodedPacket);
          });
        }
      });
    }
    exports.createPacketEncoderStream = createPacketEncoderStream;
    let TEXT_DECODER;
    function totalLength(chunks) {
      return chunks.reduce((acc, chunk2) => acc + chunk2.length, 0);
    }
    function concatChunks(chunks, size2) {
      if (chunks[0].length === size2) {
        return chunks.shift();
      }
      const buffer = new Uint8Array(size2);
      let j = 0;
      for (let i = 0; i < size2; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
          chunks.shift();
          j = 0;
        }
      }
      if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
      }
      return buffer;
    }
    function createPacketDecoderStream(maxPayload, binaryType) {
      if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
      }
      const chunks = [];
      let state = 0;
      let expectedLength = -1;
      let isBinary2 = false;
      return new TransformStream({
        transform(chunk2, controller) {
          chunks.push(chunk2);
          while (true) {
            if (state === 0) {
              if (totalLength(chunks) < 1) {
                break;
              }
              const header = concatChunks(chunks, 1);
              isBinary2 = (header[0] & 128) === 128;
              expectedLength = header[0] & 127;
              if (expectedLength < 126) {
                state = 3;
              } else if (expectedLength === 126) {
                state = 1;
              } else {
                state = 2;
              }
            } else if (state === 1) {
              if (totalLength(chunks) < 2) {
                break;
              }
              const headerArray = concatChunks(chunks, 2);
              expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
              state = 3;
            } else if (state === 2) {
              if (totalLength(chunks) < 8) {
                break;
              }
              const headerArray = concatChunks(chunks, 8);
              const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
              const n = view.getUint32(0);
              if (n > Math.pow(2, 53 - 32) - 1) {
                controller.enqueue(commons_js_1.ERROR_PACKET);
                break;
              }
              expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
              state = 3;
            } else {
              if (totalLength(chunks) < expectedLength) {
                break;
              }
              const data = concatChunks(chunks, expectedLength);
              controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
              state = 0;
            }
            if (expectedLength === 0 || expectedLength > maxPayload) {
              controller.enqueue(commons_js_1.ERROR_PACKET);
              break;
            }
          }
        }
      });
    }
    exports.createPacketDecoderStream = createPacketDecoderStream;
    exports.protocol = 4;
  })(cjs$1);
  return cjs$1;
}
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb2;
  for (var i = 0; i < callbacks.length; i++) {
    cb2 = callbacks[i];
    if (cb2 === fn || cb2.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Emitter
}, Symbol.toStringTag, { value: "Module" }));
var util = {};
var globalThis_browser = {};
var hasRequiredGlobalThis_browser;
function requireGlobalThis_browser() {
  if (hasRequiredGlobalThis_browser)
    return globalThis_browser;
  hasRequiredGlobalThis_browser = 1;
  Object.defineProperty(globalThis_browser, "__esModule", { value: true });
  globalThis_browser.globalThisShim = void 0;
  globalThis_browser.globalThisShim = (() => {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  })();
  return globalThis_browser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.byteLength = util.installTimerFunctions = util.pick = void 0;
  const globalThis_js_1 = requireGlobalThis_browser();
  function pick2(obj, ...attr) {
    return attr.reduce((acc, k) => {
      if (obj.hasOwnProperty(k)) {
        acc[k] = obj[k];
      }
      return acc;
    }, {});
  }
  util.pick = pick2;
  const NATIVE_SET_TIMEOUT = globalThis_js_1.globalThisShim.setTimeout;
  const NATIVE_CLEAR_TIMEOUT = globalThis_js_1.globalThisShim.clearTimeout;
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);
    } else {
      obj.setTimeoutFn = globalThis_js_1.globalThisShim.setTimeout.bind(globalThis_js_1.globalThisShim);
      obj.clearTimeoutFn = globalThis_js_1.globalThisShim.clearTimeout.bind(globalThis_js_1.globalThisShim);
    }
  }
  util.installTimerFunctions = installTimerFunctions;
  const BASE64_OVERHEAD = 1.33;
  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    }
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }
  util.byteLength = byteLength;
  function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
      c = str.charCodeAt(i);
      if (c < 128) {
        length += 1;
      } else if (c < 2048) {
        length += 2;
      } else if (c < 55296 || c >= 57344) {
        length += 3;
      } else {
        i++;
        length += 4;
      }
    }
    return length;
  }
  return util;
}
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var define_process_env_default = {};
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = define_process_env_default.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var parseqs = {};
var hasRequiredParseqs;
function requireParseqs() {
  if (hasRequiredParseqs)
    return parseqs;
  hasRequiredParseqs = 1;
  Object.defineProperty(parseqs, "__esModule", { value: true });
  parseqs.decode = parseqs.encode = void 0;
  function encode(obj) {
    let str = "";
    for (let i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length)
          str += "&";
        str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
      }
    }
    return str;
  }
  parseqs.encode = encode;
  function decode(qs) {
    let qry = {};
    let pairs2 = qs.split("&");
    for (let i = 0, l = pairs2.length; i < l; i++) {
      let pair = pairs2[i].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  }
  parseqs.decode = decode;
  return parseqs;
}
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport)
    return transport;
  hasRequiredTransport = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(transport, "__esModule", { value: true });
  transport.Transport = transport.TransportError = void 0;
  const engine_io_parser_1 = requireCjs$3();
  const component_emitter_1 = esm;
  const util_js_1 = requireUtil();
  const debug_1 = __importDefault(requireBrowser());
  const parseqs_js_1 = requireParseqs();
  const debug = (0, debug_1.default)("engine.io-client:transport");
  class TransportError extends Error {
    constructor(reason, description, context) {
      super(reason);
      this.description = description;
      this.context = context;
      this.type = "TransportError";
    }
  }
  transport.TransportError = TransportError;
  class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
      super();
      this.writable = false;
      (0, util_js_1.installTimerFunctions)(this, opts);
      this.opts = opts;
      this.query = opts.query;
      this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
      super.emitReserved("error", new TransportError(reason, description, context));
      return this;
    }
    /**
     * Opens the transport.
     */
    open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */
    close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        debug("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
      this.readyState = "open";
      this.writable = true;
      super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
      const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
      super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
      this.readyState = "closed";
      super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) {
    }
    createUri(schema, query = {}) {
      return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
    _hostname() {
      const hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    }
    _query(query) {
      const encodedQuery = (0, parseqs_js_1.encode)(query);
      return encodedQuery.length ? "?" + encodedQuery : "";
    }
  }
  transport.Transport = Transport;
  return transport;
}
var yeast = {};
var hasRequiredYeast;
function requireYeast() {
  if (hasRequiredYeast)
    return yeast;
  hasRequiredYeast = 1;
  Object.defineProperty(yeast, "__esModule", { value: true });
  yeast.yeast = yeast.decode = yeast.encode = void 0;
  const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map2 = {};
  let seed = 0, i = 0, prev;
  function encode(num) {
    let encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  yeast.encode = encode;
  function decode(str) {
    let decoded = 0;
    for (i = 0; i < str.length; i++) {
      decoded = decoded * length + map2[str.charAt(i)];
    }
    return decoded;
  }
  yeast.decode = decode;
  function yeast$1() {
    const now2 = encode(+/* @__PURE__ */ new Date());
    if (now2 !== prev)
      return seed = 0, prev = now2;
    return now2 + "." + encode(seed++);
  }
  yeast.yeast = yeast$1;
  for (; i < length; i++)
    map2[alphabet[i]] = i;
  return yeast;
}
var xmlhttprequest_browser = {};
var hasCors = {};
var hasRequiredHasCors;
function requireHasCors() {
  if (hasRequiredHasCors)
    return hasCors;
  hasRequiredHasCors = 1;
  Object.defineProperty(hasCors, "__esModule", { value: true });
  hasCors.hasCORS = void 0;
  let value = false;
  try {
    value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
  } catch (err) {
  }
  hasCors.hasCORS = value;
  return hasCors;
}
var hasRequiredXmlhttprequest_browser;
function requireXmlhttprequest_browser() {
  if (hasRequiredXmlhttprequest_browser)
    return xmlhttprequest_browser;
  hasRequiredXmlhttprequest_browser = 1;
  Object.defineProperty(xmlhttprequest_browser, "__esModule", { value: true });
  xmlhttprequest_browser.createCookieJar = xmlhttprequest_browser.XHR = void 0;
  const has_cors_js_1 = requireHasCors();
  const globalThis_js_1 = requireGlobalThis_browser();
  function XHR(opts) {
    const xdomain = opts.xdomain;
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {
    }
    if (!xdomain) {
      try {
        return new globalThis_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
  }
  xmlhttprequest_browser.XHR = XHR;
  function createCookieJar() {
  }
  xmlhttprequest_browser.createCookieJar = createCookieJar;
  return xmlhttprequest_browser;
}
var hasRequiredPolling;
function requirePolling() {
  if (hasRequiredPolling)
    return polling;
  hasRequiredPolling = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(polling, "__esModule", { value: true });
  polling.Request = polling.Polling = void 0;
  const transport_js_1 = requireTransport();
  const debug_1 = __importDefault(requireBrowser());
  const yeast_js_1 = requireYeast();
  const engine_io_parser_1 = requireCjs$3();
  const xmlhttprequest_js_1 = requireXmlhttprequest_browser();
  const component_emitter_1 = esm;
  const util_js_1 = requireUtil();
  const globalThis_js_1 = requireGlobalThis_browser();
  const debug = (0, debug_1.default)("engine.io-client:polling");
  function empty() {
  }
  const hasXHR2 = function() {
    const xhr = new xmlhttprequest_js_1.XHR({
      xdomain: false
    });
    return null != xhr.responseType;
  }();
  class Polling extends transport_js_1.Transport {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
      super(opts);
      this.polling = false;
      if (typeof location !== "undefined") {
        const isSSL = "https:" === location.protocol;
        let port = location.port;
        if (!port) {
          port = isSSL ? "443" : "80";
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      }
      const forceBase64 = opts && opts.forceBase64;
      this.supportsBinary = hasXHR2 && !forceBase64;
      if (this.opts.withCredentials) {
        this.cookieJar = (0, xmlhttprequest_js_1.createCookieJar)();
      }
    }
    get name() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
      this.readyState = "pausing";
      const pause = () => {
        debug("paused");
        this.readyState = "paused";
        onPause();
      };
      if (this.polling || !this.writable) {
        let total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
      debug("polling got data %s", data);
      const callback = (packet) => {
        if ("opening" === this.readyState && packet.type === "open") {
          this.onOpen();
        }
        if ("close" === packet.type) {
          this.onClose({ description: "transport closed by the server" });
          return false;
        }
        this.onPacket(packet);
      };
      (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
      const close = () => {
        debug("writing close packet");
        this.write([{ type: "close" }]);
      };
      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
      this.writable = false;
      (0, engine_io_parser_1.encodePayload)(packets, (data) => {
        this.doWrite(data, () => {
          this.writable = true;
          this.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema = this.opts.secure ? "https" : "http";
      const query = this.query || {};
      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
    request(opts = {}) {
      Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
      return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
      const req = this.request({
        method: "POST",
        data
      });
      req.on("success", fn);
      req.on("error", (xhrStatus, context) => {
        this.onError("xhr post error", xhrStatus, context);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
      debug("xhr poll");
      const req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", (xhrStatus, context) => {
        this.onError("xhr poll error", xhrStatus, context);
      });
      this.pollXhr = req;
    }
  }
  polling.Polling = Polling;
  class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(uri, opts) {
      super();
      (0, util_js_1.installTimerFunctions)(this, opts);
      this.opts = opts;
      this.method = opts.method || "GET";
      this.uri = uri;
      this.data = void 0 !== opts.data ? opts.data : null;
      this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    create() {
      var _a;
      const opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      const xhr = this.xhr = new xmlhttprequest_js_1.XHR(opts);
      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, true);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (let i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {
        }
        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        xhr.onreadystatechange = () => {
          var _a2;
          if (xhr.readyState === 3) {
            (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(xhr);
          }
          if (4 !== xhr.readyState)
            return;
          if (200 === xhr.status || 1223 === xhr.status) {
            this.onLoad();
          } else {
            this.setTimeoutFn(() => {
              this.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        this.setTimeoutFn(() => {
          this.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    onError(err) {
      this.emitReserved("error", err, this.xhr);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      this.xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    onLoad() {
      const data = this.xhr.responseText;
      if (data !== null) {
        this.emitReserved("data", data);
        this.emitReserved("success");
        this.cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
      this.cleanup();
    }
  }
  polling.Request = Request;
  Request.requestsCount = 0;
  Request.requests = {};
  if (typeof document !== "undefined") {
    if (typeof attachEvent === "function") {
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      const terminationEvent = "onpagehide" in globalThis_js_1.globalThisShim ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (let i in Request.requests) {
      if (Request.requests.hasOwnProperty(i)) {
        Request.requests[i].abort();
      }
    }
  }
  return polling;
}
var websocket = {};
var websocketConstructor_browser = {};
var hasRequiredWebsocketConstructor_browser;
function requireWebsocketConstructor_browser() {
  if (hasRequiredWebsocketConstructor_browser)
    return websocketConstructor_browser;
  hasRequiredWebsocketConstructor_browser = 1;
  Object.defineProperty(websocketConstructor_browser, "__esModule", { value: true });
  websocketConstructor_browser.defaultBinaryType = websocketConstructor_browser.usingBrowserWebSocket = websocketConstructor_browser.WebSocket = websocketConstructor_browser.nextTick = void 0;
  const globalThis_js_1 = requireGlobalThis_browser();
  websocketConstructor_browser.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
      return (cb2) => Promise.resolve().then(cb2);
    } else {
      return (cb2, setTimeoutFn) => setTimeoutFn(cb2, 0);
    }
  })();
  websocketConstructor_browser.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
  websocketConstructor_browser.usingBrowserWebSocket = true;
  websocketConstructor_browser.defaultBinaryType = "arraybuffer";
  return websocketConstructor_browser;
}
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket)
    return websocket;
  hasRequiredWebsocket = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(websocket, "__esModule", { value: true });
  websocket.WS = void 0;
  const transport_js_1 = requireTransport();
  const yeast_js_1 = requireYeast();
  const util_js_1 = requireUtil();
  const websocket_constructor_js_1 = requireWebsocketConstructor_browser();
  const debug_1 = __importDefault(requireBrowser());
  const engine_io_parser_1 = requireCjs$3();
  const debug = (0, debug_1.default)("engine.io-client:websocket");
  const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  class WS extends transport_js_1.Transport {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */
    constructor(opts) {
      super(opts);
      this.supportsBinary = !opts.forceBase64;
    }
    get name() {
      return "websocket";
    }
    doOpen() {
      if (!this.check()) {
        return;
      }
      const uri = this.uri();
      const protocols = this.opts.protocols;
      const opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1.WebSocket(uri, protocols) : new websocket_constructor_js_1.WebSocket(uri) : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
      this.ws.onopen = () => {
        if (this.opts.autoUnref) {
          this.ws._socket.unref();
        }
        this.onOpen();
      };
      this.ws.onclose = (closeEvent) => this.onClose({
        description: "websocket connection closed",
        context: closeEvent
      });
      this.ws.onmessage = (ev) => this.onData(ev.data);
      this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
      this.writable = false;
      for (let i = 0; i < packets.length; i++) {
        const packet = packets[i];
        const lastPacket = i === packets.length - 1;
        (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
          const opts = {};
          if (!websocket_constructor_js_1.usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }
            if (this.opts.perMessageDeflate) {
              const len = (
                // @ts-ignore
                "string" === typeof data ? Buffer.byteLength(data) : data.length
              );
              if (len < this.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          }
          try {
            if (websocket_constructor_js_1.usingBrowserWebSocket) {
              this.ws.send(data);
            } else {
              this.ws.send(data, opts);
            }
          } catch (e) {
            debug("websocket closed before onclose event");
          }
          if (lastPacket) {
            (0, websocket_constructor_js_1.nextTick)(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema = this.opts.secure ? "wss" : "ws";
      const query = this.query || {};
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
    check() {
      return !!websocket_constructor_js_1.WebSocket;
    }
  }
  websocket.WS = WS;
  return websocket;
}
var webtransport = {};
var hasRequiredWebtransport;
function requireWebtransport() {
  if (hasRequiredWebtransport)
    return webtransport;
  hasRequiredWebtransport = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(webtransport, "__esModule", { value: true });
  webtransport.WT = void 0;
  const transport_js_1 = requireTransport();
  const websocket_constructor_js_1 = requireWebsocketConstructor_browser();
  const engine_io_parser_1 = requireCjs$3();
  const debug_1 = __importDefault(requireBrowser());
  const debug = (0, debug_1.default)("engine.io-client:webtransport");
  class WT extends transport_js_1.Transport {
    get name() {
      return "webtransport";
    }
    doOpen() {
      if (typeof WebTransport !== "function") {
        return;
      }
      this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      this.transport.closed.then(() => {
        debug("transport closed gracefully");
        this.onClose();
      }).catch((err) => {
        debug("transport closed due to %s", err);
        this.onError("webtransport error", err);
      });
      this.transport.ready.then(() => {
        this.transport.createBidirectionalStream().then((stream) => {
          const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
          const reader = stream.readable.pipeThrough(decoderStream).getReader();
          const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
          encoderStream.readable.pipeTo(stream.writable);
          this.writer = encoderStream.writable.getWriter();
          const read = () => {
            reader.read().then(({ done, value }) => {
              if (done) {
                debug("session is closed");
                return;
              }
              debug("received chunk: %o", value);
              this.onPacket(value);
              read();
            }).catch((err) => {
              debug("an error occurred while reading: %s", err);
            });
          };
          read();
          const packet = { type: "open" };
          if (this.query.sid) {
            packet.data = `{"sid":"${this.query.sid}"}`;
          }
          this.writer.write(packet).then(() => this.onOpen());
        });
      });
    }
    write(packets) {
      this.writable = false;
      for (let i = 0; i < packets.length; i++) {
        const packet = packets[i];
        const lastPacket = i === packets.length - 1;
        this.writer.write(packet).then(() => {
          if (lastPacket) {
            (0, websocket_constructor_js_1.nextTick)(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      var _a;
      (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
    }
  }
  webtransport.WT = WT;
  return webtransport;
}
var hasRequiredTransports;
function requireTransports() {
  if (hasRequiredTransports)
    return transports;
  hasRequiredTransports = 1;
  Object.defineProperty(transports, "__esModule", { value: true });
  transports.transports = void 0;
  const polling_js_1 = requirePolling();
  const websocket_js_1 = requireWebsocket();
  const webtransport_js_1 = requireWebtransport();
  transports.transports = {
    websocket: websocket_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_js_1.Polling
  };
  return transports;
}
var parseuri = {};
var hasRequiredParseuri;
function requireParseuri() {
  if (hasRequiredParseuri)
    return parseuri;
  hasRequiredParseuri = 1;
  Object.defineProperty(parseuri, "__esModule", { value: true });
  parseuri.parse = void 0;
  const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  const parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
  ];
  function parse(str) {
    if (str.length > 2e3) {
      throw "URI too long";
    }
    const src = str, b = str.indexOf("["), e = str.indexOf("]");
    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
    }
    let m = re.exec(str || ""), uri = {}, i = 14;
    while (i--) {
      uri[parts[i]] = m[i] || "";
    }
    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  }
  parseuri.parse = parse;
  function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == "/" || path.length === 0) {
      names.splice(0, 1);
    }
    if (path.slice(-1) == "/") {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }
  return parseuri;
}
var hasRequiredSocket$1;
function requireSocket$1() {
  if (hasRequiredSocket$1)
    return socket$2;
  hasRequiredSocket$1 = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(socket$2, "__esModule", { value: true });
  socket$2.Socket = void 0;
  const index_js_1 = requireTransports();
  const util_js_1 = requireUtil();
  const parseqs_js_1 = requireParseqs();
  const parseuri_js_1 = requireParseuri();
  const debug_1 = __importDefault(requireBrowser());
  const component_emitter_1 = esm;
  const engine_io_parser_1 = requireCjs$3();
  const websocket_constructor_js_1 = requireWebsocketConstructor_browser();
  const debug = (0, debug_1.default)("engine.io-client:socket");
  class Socket extends component_emitter_1.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts = {}) {
      super();
      this.binaryType = websocket_constructor_js_1.defaultBinaryType;
      this.writeBuffer = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = (0, parseuri_js_1.parse)(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
      }
      (0, util_js_1.installTimerFunctions)(this, opts);
      this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
      this.transports = opts.transports || [
        "polling",
        "websocket",
        "webtransport"
      ];
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        timestampParam: "t",
        rememberUpgrade: false,
        addTrailingSlash: true,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: false
      }, opts);
      this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
      if (typeof this.opts.query === "string") {
        this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingTimeoutTimer = null;
      if (typeof addEventListener === "function") {
        if (this.opts.closeOnBeforeunload) {
          this.beforeunloadEventListener = () => {
            if (this.transport) {
              this.transport.removeAllListeners();
              this.transport.close();
            }
          };
          addEventListener("beforeunload", this.beforeunloadEventListener, false);
        }
        if (this.hostname !== "localhost") {
          this.offlineEventListener = () => {
            this.onClose("transport close", {
              description: "network connection lost"
            });
          };
          addEventListener("offline", this.offlineEventListener, false);
        }
      }
      this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
      debug('creating transport "%s"', name);
      const query = Object.assign({}, this.opts.query);
      query.EIO = engine_io_parser_1.protocol;
      query.transport = name;
      if (this.id)
        query.sid = this.id;
      const opts = Object.assign({}, this.opts, {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug("options: %j", opts);
      return new index_js_1.transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    open() {
      let transport2;
      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport2 = "websocket";
      } else if (0 === this.transports.length) {
        this.setTimeoutFn(() => {
          this.emitReserved("error", "No transports available");
        }, 0);
        return;
      } else {
        transport2 = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport2 = this.createTransport(transport2);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }
      transport2.open();
      this.setTransport(transport2);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport2) {
      debug("setting transport %s", transport2.name);
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport2;
      transport2.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    probe(name) {
      debug('probing transport "%s"', name);
      let transport2 = this.createTransport(name);
      let failed = false;
      Socket.priorWebsocketSuccess = false;
      const onTransportOpen = () => {
        if (failed)
          return;
        debug('probe transport "%s" opened', name);
        transport2.send([{ type: "ping", data: "probe" }]);
        transport2.once("packet", (msg) => {
          if (failed)
            return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            this.upgrading = true;
            this.emitReserved("upgrading", transport2);
            if (!transport2)
              return;
            Socket.priorWebsocketSuccess = "websocket" === transport2.name;
            debug('pausing current transport "%s"', this.transport.name);
            this.transport.pause(() => {
              if (failed)
                return;
              if ("closed" === this.readyState)
                return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              this.setTransport(transport2);
              transport2.send([{ type: "upgrade" }]);
              this.emitReserved("upgrade", transport2);
              transport2 = null;
              this.upgrading = false;
              this.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            const err = new Error("probe error");
            err.transport = transport2.name;
            this.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport2.close();
        transport2 = null;
      }
      const onerror = (err) => {
        const error = new Error("probe error: " + err);
        error.transport = transport2.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        this.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport2 && to.name !== transport2.name) {
          debug('"%s" works - aborting "%s"', to.name, transport2.name);
          freezeTransport();
        }
      }
      const cleanup = () => {
        transport2.removeListener("open", onTransportOpen);
        transport2.removeListener("error", onerror);
        transport2.removeListener("close", onTransportClose);
        this.off("close", onclose);
        this.off("upgrading", onupgrade);
      };
      transport2.once("open", onTransportOpen);
      transport2.once("error", onerror);
      transport2.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        this.setTimeoutFn(() => {
          if (!failed) {
            transport2.open();
          }
        }, 200);
      } else {
        transport2.open();
      }
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
      if ("open" === this.readyState && this.opts.upgrade) {
        debug("starting upgrade probes");
        let i = 0;
        const l = this.upgrades.length;
        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        this.emitReserved("heartbeat");
        this.resetPingTimeout();
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            break;
          case "error":
            const err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.maxPayload = data.maxPayload;
      this.onOpen();
      if ("closed" === this.readyState)
        return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    resetPingTimeout() {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.pingTimeoutTimer = this.setTimeoutFn(() => {
        this.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        const packets = this.getWritablePackets();
        debug("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        this.prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    getWritablePackets() {
      const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      let payloadSize = 1;
      for (let i = 0; i < this.writeBuffer.length; i++) {
        const data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += (0, util_js_1.byteLength)(data);
        }
        if (i > 0 && payloadSize > this.maxPayload) {
          debug("only send %d out of %d packets", i, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2;
      }
      debug("payload size is %d (max: %d)", payloadSize, this.maxPayload);
      return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = void 0;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      const packet = {
        type,
        data,
        options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
      const close = () => {
        this.onClose("forced close");
        debug("socket closing - telling transport to close");
        this.transport.close();
      };
      const cleanupAndClose = () => {
        this.off("upgrade", cleanupAndClose);
        this.off("upgradeError", cleanupAndClose);
        close();
      };
      const waitForUpgrade = () => {
        this.once("upgrade", cleanupAndClose);
        this.once("upgradeError", cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", () => {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emitReserved("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        if (typeof removeEventListener === "function") {
          removeEventListener("beforeunload", this.beforeunloadEventListener, false);
          removeEventListener("offline", this.offlineEventListener, false);
        }
        this.readyState = "closed";
        this.id = null;
        this.emitReserved("close", reason, description);
        this.writeBuffer = [];
        this.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    filterUpgrades(upgrades) {
      const filteredUpgrades = [];
      let i = 0;
      const j = upgrades.length;
      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i]))
          filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  }
  socket$2.Socket = Socket;
  Socket.protocol = engine_io_parser_1.protocol;
  return socket$2;
}
var hasRequiredCjs$2;
function requireCjs$2() {
  if (hasRequiredCjs$2)
    return cjs$2;
  hasRequiredCjs$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.Socket = void 0;
    const socket_js_1 = requireSocket$1();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    exports.protocol = socket_js_1.Socket.protocol;
    var transport_js_1 = requireTransport();
    Object.defineProperty(exports, "Transport", { enumerable: true, get: function() {
      return transport_js_1.Transport;
    } });
    Object.defineProperty(exports, "TransportError", { enumerable: true, get: function() {
      return transport_js_1.TransportError;
    } });
    var index_js_1 = requireTransports();
    Object.defineProperty(exports, "transports", { enumerable: true, get: function() {
      return index_js_1.transports;
    } });
    var util_js_1 = requireUtil();
    Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function() {
      return util_js_1.installTimerFunctions;
    } });
    var parseuri_js_1 = requireParseuri();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parseuri_js_1.parse;
    } });
    var websocket_constructor_js_1 = requireWebsocketConstructor_browser();
    Object.defineProperty(exports, "nextTick", { enumerable: true, get: function() {
      return websocket_constructor_js_1.nextTick;
    } });
  })(cjs$2);
  return cjs$2;
}
var hasRequiredUrl;
function requireUrl() {
  if (hasRequiredUrl)
    return url;
  hasRequiredUrl = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(url, "__esModule", { value: true });
  url.url = void 0;
  const engine_io_client_1 = requireCjs$2();
  const debug_1 = __importDefault(requireBrowser());
  const debug = debug_1.default("socket.io-client:url");
  function url$1(uri, path = "", loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        debug("protocol-less url %s", uri);
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      debug("parse %s", uri);
      obj = engine_io_client_1.parse(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  url.url = url$1;
  return url;
}
var manager = {};
var socket$1 = {};
var cjs = {};
var binary = {};
var isBinary = {};
var hasRequiredIsBinary;
function requireIsBinary() {
  if (hasRequiredIsBinary)
    return isBinary;
  hasRequiredIsBinary = 1;
  Object.defineProperty(isBinary, "__esModule", { value: true });
  isBinary.hasBinary = isBinary.isBinary = void 0;
  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  const toString2 = Object.prototype.toString;
  const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
  const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";
  function isBinary$1(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  isBinary.isBinary = isBinary$1;
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i = 0, l = obj.length; i < l; i++) {
        if (hasBinary(obj[i])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary$1(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  isBinary.hasBinary = hasBinary;
  return isBinary;
}
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary)
    return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.reconstructPacket = binary.deconstructPacket = void 0;
  const is_binary_js_1 = requireIsBinary();
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  }
  binary.deconstructPacket = deconstructPacket;
  function _deconstructPacket(data, buffers) {
    if (!data)
      return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments;
    return packet;
  }
  binary.reconstructPacket = reconstructPacket;
  function _reconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder === true) {
      const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }
  return binary;
}
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1)
    return cjs;
  hasRequiredCjs$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
    const component_emitter_1 = esm;
    const binary_js_1 = requireBinary();
    const is_binary_js_1 = requireIsBinary();
    const debug_1 = requireBrowser();
    const debug = (0, debug_1.default)("socket.io-parser");
    const RESERVED_EVENTS = [
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
      // used by the Node.js EventEmitter
    ];
    exports.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
    class Encoder {
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if ((0, is_binary_js_1.hasBinary)(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        }
        if (null != obj.id) {
          str += obj.id;
        }
        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    }
    exports.Encoder = Encoder;
    function isObject2(value) {
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    class Decoder extends component_emitter_1.Emitter {
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf = str.substring(start, i);
          if (buf != Number(buf) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if ("/" === str.charAt(i + 1)) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if ("," === c)
              break;
            if (i === str.length)
              break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length)
              break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug("decoded %s as %j", str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return isObject2(payload);
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || isObject2(payload);
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    }
    exports.Decoder = Decoder;
    class BinaryReconstructor {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    }
  })(cjs);
  return cjs;
}
var on = {};
var hasRequiredOn;
function requireOn() {
  if (hasRequiredOn)
    return on;
  hasRequiredOn = 1;
  Object.defineProperty(on, "__esModule", { value: true });
  on.on = void 0;
  function on$1(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }
  on.on = on$1;
  return on;
}
var hasRequiredSocket;
function requireSocket() {
  if (hasRequiredSocket)
    return socket$1;
  hasRequiredSocket = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(socket$1, "__esModule", { value: true });
  socket$1.Socket = void 0;
  const socket_io_parser_1 = requireCjs$1();
  const on_js_1 = requireOn();
  const component_emitter_1 = esm;
  const debug_1 = __importDefault(requireBrowser());
  const debug = debug_1.default("socket.io-client:socket");
  const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
  });
  class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
      super();
      this.connected = false;
      this.recovered = false;
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this._queue = [];
      this._queueSeq = 0;
      this.ids = 0;
      this.acks = {};
      this.flags = {};
      this.io = io;
      this.nsp = nsp;
      if (opts && opts.auth) {
        this.auth = opts.auth;
      }
      this._opts = Object.assign({}, opts);
      if (this.io._autoConnect)
        this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
      return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
      if (this.subs)
        return;
      const io = this.io;
      this.subs = [
        on_js_1.on(io, "open", this.onopen.bind(this)),
        on_js_1.on(io, "packet", this.onpacket.bind(this)),
        on_js_1.on(io, "error", this.onerror.bind(this)),
        on_js_1.on(io, "close", this.onclose.bind(this))
      ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io["_reconnecting"])
        this.io.open();
      if ("open" === this.io._readyState)
        this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
        this._addToQueue(args);
        return this;
      }
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      if ("function" === typeof args[args.length - 1]) {
        const id = this.ids++;
        debug("emitting packet with ack id %d", id);
        const ack = args.pop();
        this._registerAckCallback(id, ack);
        packet.id = id;
      }
      const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
      var _a;
      const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
      if (timeout === void 0) {
        this.acks[id] = ack;
        return;
      }
      const timer = this.io.setTimeoutFn(() => {
        delete this.acks[id];
        for (let i = 0; i < this.sendBuffer.length; i++) {
          if (this.sendBuffer[i].id === id) {
            debug("removing packet with ack id %d from the buffer", id);
            this.sendBuffer.splice(i, 1);
          }
        }
        debug("event with ack id %d has timed out after %d ms", id, timeout);
        ack.call(this, new Error("operation has timed out"));
      }, timeout);
      const fn = (...args) => {
        this.io.clearTimeoutFn(timer);
        ack.apply(this, args);
      };
      fn.withError = true;
      this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
      return new Promise((resolve, reject2) => {
        const fn = (arg1, arg2) => {
          return arg1 ? reject2(arg1) : resolve(arg2);
        };
        fn.withError = true;
        args.push(fn);
        this.emit(ev, ...args);
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
      let ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      const packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args,
        flags: Object.assign({ fromQueue: true }, this.flags)
      };
      args.push((err, ...responseArgs) => {
        if (packet !== this._queue[0]) {
          return;
        }
        const hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > this._opts.retries) {
            debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
            this._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          debug("packet [%d] was successfully sent", packet.id);
          this._queue.shift();
          if (ack) {
            ack(null, ...responseArgs);
          }
        }
        packet.pending = false;
        return this._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
      debug("draining queue");
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      const packet = this._queue[0];
      if (packet.pending && !force) {
        debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      debug("sending packet [%d] (try nÂ°%d)", packet.id, packet.tryCount);
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
      packet.nsp = this.nsp;
      this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
      debug("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth((data) => {
          this._sendConnectPacket(data);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT,
        data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
      debug("close (%s)", reason);
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
      this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
      Object.keys(this.acks).forEach((id) => {
        const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
        if (!isBuffered) {
          const ack = this.acks[id];
          delete this.acks[id];
          if (ack.withError) {
            ack.call(this, new Error("socket has been disconnected"));
          }
        }
      });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
      const sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace)
        return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this.destroy();
          const err = new Error(packet.data.message);
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
      const args = packet.data || [];
      debug("emitting event %j", args);
      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
    emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      super.emit.apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
      const self2 = this;
      let sent = false;
      return function(...args) {
        if (sent)
          return;
        sent = true;
        debug("sending ack %j", args);
        self2.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
      const ack = this.acks[packet.id];
      if (typeof ack !== "function") {
        debug("bad ack %s", packet.id);
        return;
      }
      delete this.acks[packet.id];
      debug("calling ack %s with %j", packet.id, packet.data);
      if (ack.withError) {
        packet.data.unshift(null);
      }
      ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.recovered = pid && this._pid === pid;
      this._pid = pid;
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
      this.receiveBuffer.forEach((args) => this.emitEvent(args));
      this.receiveBuffer = [];
      this.sendBuffer.forEach((packet) => {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
      if (this.subs) {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs = void 0;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
      this.flags.timeout = timeout;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyOutgoingListeners;
        for (let i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const listeners = this._anyOutgoingListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, packet.data);
        }
      }
    }
  }
  socket$1.Socket = Socket;
  return socket$1;
}
var backo2 = {};
var hasRequiredBacko2;
function requireBacko2() {
  if (hasRequiredBacko2)
    return backo2;
  hasRequiredBacko2 = 1;
  Object.defineProperty(backo2, "__esModule", { value: true });
  backo2.Backoff = void 0;
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  backo2.Backoff = Backoff;
  Backoff.prototype.duration = function() {
    var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms2);
      ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
    }
    return Math.min(ms2, this.max) | 0;
  };
  Backoff.prototype.reset = function() {
    this.attempts = 0;
  };
  Backoff.prototype.setMin = function(min2) {
    this.ms = min2;
  };
  Backoff.prototype.setMax = function(max2) {
    this.max = max2;
  };
  Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
  };
  return backo2;
}
var hasRequiredManager;
function requireManager() {
  if (hasRequiredManager)
    return manager;
  hasRequiredManager = 1;
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(manager, "__esModule", { value: true });
  manager.Manager = void 0;
  const engine_io_client_1 = requireCjs$2();
  const socket_js_1 = requireSocket();
  const parser = __importStar(requireCjs$1());
  const on_js_1 = requireOn();
  const backo2_js_1 = requireBacko2();
  const component_emitter_1 = esm;
  const debug_1 = __importDefault(requireBrowser());
  const debug = debug_1.default("socket.io-client:manager");
  class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
      var _a;
      super();
      this.nsps = {};
      this.subs = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.opts = opts;
      engine_io_client_1.installTimerFunctions(this, opts);
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
      this.backoff = new backo2_js_1.Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
      this._readyState = "closed";
      this.uri = uri;
      const _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this._autoConnect = opts.autoConnect !== false;
      if (this._autoConnect)
        this.open();
    }
    reconnection(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
    reconnectionAttempts(v) {
      if (v === void 0)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
    reconnectionDelay(v) {
      var _a;
      if (v === void 0)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
    randomizationFactor(v) {
      var _a;
      if (v === void 0)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
    reconnectionDelayMax(v) {
      var _a;
      if (v === void 0)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
    timeout(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open"))
        return this;
      debug("opening %s", this.uri);
      this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
      const socket2 = this.engine;
      const self2 = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      const openSubDestroy = on_js_1.on(socket2, "open", function() {
        self2.onopen();
        fn && fn();
      });
      const onError = (err) => {
        debug("error");
        this.cleanup();
        this._readyState = "closed";
        this.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          this.maybeReconnectOnOpen();
        }
      };
      const errorSub = on_js_1.on(socket2, "error", onError);
      if (false !== this._timeout) {
        const timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        const timer = this.setTimeoutFn(() => {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          onError(new Error("timeout"));
          socket2.close();
        }, timeout);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
      debug("open");
      this.cleanup();
      this._readyState = "open";
      this.emitReserved("open");
      const socket2 = this.engine;
      this.subs.push(on_js_1.on(socket2, "ping", this.onping.bind(this)), on_js_1.on(socket2, "data", this.ondata.bind(this)), on_js_1.on(socket2, "error", this.onerror.bind(this)), on_js_1.on(socket2, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onclose("parse error", e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
      engine_io_client_1.nextTick(() => {
        this.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
      let socket2 = this.nsps[nsp];
      if (!socket2) {
        socket2 = new socket_js_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket2;
      } else if (this._autoConnect && !socket2.active) {
        socket2.connect();
      }
      return socket2;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket2) {
      const nsps = Object.keys(this.nsps);
      for (const nsp of nsps) {
        const socket3 = this.nsps[nsp];
        if (socket3.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
      debug("writing packet %j", packet);
      const encodedPackets = this.encoder.encode(packet);
      for (let i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
      debug("cleanup");
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
      if (this.engine)
        this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason, description) {
      debug("closed due to %s", reason);
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
      if (this._reconnecting || this.skipReconnect)
        return this;
      const self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        const delay2 = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay2);
        this._reconnecting = true;
        const timer = this.setTimeoutFn(() => {
          if (self2.skipReconnect)
            return;
          debug("attempting reconnect");
          this.emitReserved("reconnect_attempt", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open((err) => {
            if (err) {
              debug("reconnect attempt error");
              self2._reconnecting = false;
              self2.reconnect();
              this.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay2);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
      const attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }
  manager.Manager = Manager;
  return manager;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs)
    return cjs$3.exports;
  hasRequiredCjs = 1;
  (function(module, exports) {
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;
    const url_js_1 = requireUrl();
    const manager_js_1 = requireManager();
    Object.defineProperty(exports, "Manager", { enumerable: true, get: function() {
      return manager_js_1.Manager;
    } });
    const socket_js_1 = requireSocket();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    const debug_1 = __importDefault(requireBrowser());
    const debug = debug_1.default("socket.io-client");
    const cache = {};
    function lookup(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      const parsed = url_js_1.url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id = parsed.id;
      const path = parsed.path;
      const sameNamespace = cache[id] && path in cache[id]["nsps"];
      const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
      let io;
      if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug("new io instance for %s", source);
          cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
      }
      return io.socket(parsed.path, opts);
    }
    exports.io = lookup;
    exports.connect = lookup;
    exports.default = lookup;
    Object.assign(lookup, {
      Manager: manager_js_1.Manager,
      Socket: socket_js_1.Socket,
      io: lookup,
      connect: lookup
    });
    var socket_io_parser_1 = requireCjs$1();
    Object.defineProperty(exports, "protocol", { enumerable: true, get: function() {
      return socket_io_parser_1.protocol;
    } });
    module.exports = lookup;
  })(cjs$3, cjs$3.exports);
  return cjs$3.exports;
}
var skin_variants = {};
var hasRequiredSkin_variants;
function requireSkin_variants() {
  if (hasRequiredSkin_variants)
    return skin_variants;
  hasRequiredSkin_variants = 1;
  if (window.location.hash.toLowerCase() === "#skinvariantsbuilder") {
    $("#skin-variants").addClass("popup-show");
    const containers = ["editor", "background", "toolbar"];
    const colors = ["super-light", "light", "dark", "super-dark"];
    const updateSkinVariantsClasses = () => {
      const domsToUpdate = [
        $("html"),
        $("iframe[name=ace_outer]").contents().find("html"),
        $("iframe[name=ace_outer]").contents().find("iframe[name=ace_inner]").contents().find("html")
      ];
      colors.forEach((color) => {
        containers.forEach((container) => {
          domsToUpdate.forEach((el) => {
            el.removeClass(`${color}-${container}`);
          });
        });
      });
      domsToUpdate.forEach((el) => {
        el.removeClass("full-width-editor");
      });
      const newClasses = [];
      $("select.skin-variant-color").each(function() {
        newClasses.push(`${$(this).val()}-${$(this).data("container")}`);
      });
      if ($("#skin-variant-full-width").is(":checked"))
        newClasses.push("full-width-editor");
      domsToUpdate.forEach((el) => {
        el.addClass(newClasses.join(" "));
      });
      $("#skin-variants-result").val(`"skinVariants": "${newClasses.join(" ")}",`);
    };
    const updateCheckboxFromSkinClasses = () => {
      $("html").attr("class").split(" ").forEach((classItem) => {
        const container = classItem.substring(classItem.lastIndexOf("-") + 1, classItem.length);
        if (containers.indexOf(container) > -1) {
          const color = classItem.substring(0, classItem.lastIndexOf("-"));
          $(`.skin-variant-color[data-container="${container}"`).val(color);
        }
      });
      $("#skin-variant-full-width").prop("checked", $("html").hasClass("full-width-editor"));
    };
    $(".skin-variant").on("change", () => {
      updateSkinVariantsClasses();
    });
    updateCheckboxFromSkinClasses();
    updateSkinVariantsClasses();
  }
  return skin_variants;
}
// @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt
window.clientVars = {
  // This is needed to fetch /pluginfw/plugin-definitions.json, which happens before the
  // server sends the CLIENT_VARS message.
  randomVersionString: "test"
};
(function() {
  const pathComponents = location.pathname.split("/");
  const baseURL = pathComponents.slice(0, pathComponents.length - 2).join("/") + "/";
  window.$ = rjquery.jQuery;
  window.jQuery = rjquery.jQuery;
  window.browser = browserExports;
  var plugins = client_plugins;
  var hooks$1 = hooks;
  plugins.baseURL = baseURL;
  plugins.update(function() {
    window._postPluginUpdateForTestingDone = false;
    if (window._postPluginUpdateForTesting != null)
      window._postPluginUpdateForTesting();
    window._postPluginUpdateForTestingDone = true;
    $(function() {
      hooks$1.aCallAll("documentReady");
    });
    var pad2 = requirePad();
    pad2.baseURL = baseURL;
    pad2.init();
  });
  window.pad = requirePad().pad;
  window.chat = requireChat().chat;
  window.padeditbar = requirePad_editbar().padeditbar;
  window.padimpexp = requirePad_impexp().padimpexp;
  window.io = requireCjs();
  requireSkin_variants();
})();
